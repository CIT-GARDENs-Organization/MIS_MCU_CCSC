CCS PCH C Compiler, Version 5.104, 57077               17-4-25 10:10

               Filename:   build\main.lst

               ROM used:   9522 bytes (7%)
                           Largest free fragment is 65520
               RAM used:   333 (9%) at main() level
                           486 (14%) worst case
               Stack used: 2 locations (0 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   225A
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   00CA
00068:  BTFSS  F9D.5
0006A:  GOTO   0074
0006E:  BTFSC  F9E.5
00070:  GOTO   0174
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "./main.h"
.................... #ifndef MAIN_H
.................... #define MAIN_H
.................... 
.................... // PIC configuration file
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
00146:  TBLRD*+
00148:  MOVF   FF5,F
0014A:  BZ    0172
0014C:  MOVFF  FF6,1E3
00150:  MOVFF  FF7,1E4
00154:  MOVFF  FF8,1E5
00158:  MOVF   FF5,W
0015A:  BTFSS  FA4.4
0015C:  BRA    015A
0015E:  MOVLB  F
00160:  MOVWF  x1D
00162:  MOVFF  1E3,FF6
00166:  MOVFF  1E4,FF7
0016A:  MOVFF  1E5,FF8
0016E:  MOVLB  0
00170:  BRA    0146
00172:  RETURN 0
*
001C0:  DATA 0D,0A
001C2:  DATA 4F,76
001C4:  DATA 65,72
001C6:  DATA 66,6C
001C8:  DATA 6F,77
001CA:  DATA 20,42
001CC:  DATA 4F,53
001CE:  DATA 53,20
001D0:  DATA 72,65
001D2:  DATA 63,65
001D4:  DATA 69,76
001D6:  DATA 65,20
001D8:  DATA 73,69
001DA:  DATA 67,6E
001DC:  DATA 61,6C
001DE:  DATA 20,62
001E0:  DATA 75,66
001E2:  DATA 66,65
001E4:  DATA 72,21
001E6:  DATA 21,21
001E8:  DATA 0D,0A
001EA:  DATA 0D,0A
001EC:  DATA 00,00
001EE:  DATA 53,4D
001F0:  DATA 46,20
001F2:  DATA 64,61
001F4:  DATA 74,61
001F6:  DATA 20,6C
001F8:  DATA 69,73
001FA:  DATA 74,20
001FC:  DATA 69,73
001FE:  DATA 20,66
00200:  DATA 75,6C
00202:  DATA 6C,21
00204:  DATA 21,21
00206:  DATA 0D,0A
00208:  DATA 00,00
0020A:  DATA 53,4D
0020C:  DATA 46,20
0020E:  DATA 64,61
00210:  DATA 74,61
00212:  DATA 20,6C
00214:  DATA 69,73
00216:  DATA 74,20
00218:  DATA 69,73
0021A:  DATA 20,65
0021C:  DATA 6D,70
0021E:  DATA 74,79
00220:  DATA 0D,0A
00222:  DATA 00,00
00224:  DATA 66,6C
00226:  DATA 61,73
00228:  DATA 68,20
0022A:  DATA 62,75
0022C:  DATA 73,79
0022E:  DATA 0A,0D
00230:  DATA 00,00
00232:  DATA 52,65
00234:  DATA 61,64
00236:  DATA 20,49
00238:  DATA 44,3A
0023A:  DATA 00,00
0023C:  DATA 66,6C
0023E:  DATA 61,73
00240:  DATA 68,20
00242:  DATA 63,6F
00244:  DATA 6E,6E
00246:  DATA 65,63
00248:  DATA 74,20
0024A:  DATA 4F,4B
0024C:  DATA 0D,0A
0024E:  DATA 00,00
00250:  DATA 66,6C
00252:  DATA 61,73
00254:  DATA 68,20
00256:  DATA 6E,6F
00258:  DATA 74,20
0025A:  DATA 63,6F
0025C:  DATA 6E,6E
0025E:  DATA 65,63
00260:  DATA 74,0D
00262:  DATA 0A,00
00264:  DATA 65,72
00266:  DATA 72,6F
00268:  DATA 72,3A
0026A:  DATA 66,6C
0026C:  DATA 61,73
0026E:  DATA 68,20
00270:  DATA 6D,6F
00272:  DATA 64,65
00274:  DATA 6C,20
00276:  DATA 69,73
00278:  DATA 20,69
0027A:  DATA 6E,76
0027C:  DATA 61,6C
0027E:  DATA 69,64
00280:  DATA 0D,0A
00282:  DATA 00,00
00284:  DATA 66,6C
00286:  DATA 61,73
00288:  DATA 68,20
0028A:  DATA 74,69
0028C:  DATA 6D,65
0028E:  DATA 6F,75
00290:  DATA 74,0D
00292:  DATA 0A,00
00294:  DATA 66,6C
00296:  DATA 61,73
00298:  DATA 68,20
0029A:  DATA 73,65
0029C:  DATA 63,74
0029E:  DATA 6F,72
002A0:  DATA 20,65
002A2:  DATA 72,61
002A4:  DATA 73,65
002A6:  DATA 20,63
002A8:  DATA 6F,6D
002AA:  DATA 70,6C
002AC:  DATA 65,74
002AE:  DATA 65,0D
002B0:  DATA 0A,00
002B2:  DATA 65,72
002B4:  DATA 72,6F
002B6:  DATA 72,3A
002B8:  DATA 66,6C
002BA:  DATA 61,73
002BC:  DATA 68,20
002BE:  DATA 6D,6F
002C0:  DATA 64,65
002C2:  DATA 6C,20
002C4:  DATA 69,73
002C6:  DATA 20,69
002C8:  DATA 6E,76
002CA:  DATA 61,6C
002CC:  DATA 69,64
002CE:  DATA 0D,0A
002D0:  DATA 00,00
002D2:  DATA 66,6C
002D4:  DATA 61,73
002D6:  DATA 68,20
002D8:  DATA 74,69
002DA:  DATA 6D,65
002DC:  DATA 6F,75
002DE:  DATA 74,0D
002E0:  DATA 0A,00
002E2:  DATA 66,6C
002E4:  DATA 61,73
002E6:  DATA 68,20
002E8:  DATA 33,32
002EA:  DATA 6B,42
002EC:  DATA 79,74
002EE:  DATA 65,20
002F0:  DATA 73,75
002F2:  DATA 62,73
002F4:  DATA 65,63
002F6:  DATA 74,6F
002F8:  DATA 72,20
002FA:  DATA 65,72
002FC:  DATA 61,73
002FE:  DATA 65,20
00300:  DATA 63,6F
00302:  DATA 6D,70
00304:  DATA 6C,65
00306:  DATA 74,65
00308:  DATA 0D,0A
0030A:  DATA 00,00
0030C:  DATA 65,72
0030E:  DATA 72,6F
00310:  DATA 72,3A
00312:  DATA 66,6C
00314:  DATA 61,73
00316:  DATA 68,20
00318:  DATA 6D,6F
0031A:  DATA 64,65
0031C:  DATA 6C,20
0031E:  DATA 69,73
00320:  DATA 20,69
00322:  DATA 6E,76
00324:  DATA 61,6C
00326:  DATA 69,64
00328:  DATA 0D,0A
0032A:  DATA 00,00
0032C:  DATA 66,6C
0032E:  DATA 61,73
00330:  DATA 68,20
00332:  DATA 74,69
00334:  DATA 6D,65
00336:  DATA 6F,75
00338:  DATA 74,0D
0033A:  DATA 0A,00
0033C:  DATA 66,6C
0033E:  DATA 61,73
00340:  DATA 68,20
00342:  DATA 34,6B
00344:  DATA 42,79
00346:  DATA 74,65
00348:  DATA 20,73
0034A:  DATA 75,62
0034C:  DATA 73,65
0034E:  DATA 63,74
00350:  DATA 6F,72
00352:  DATA 20,65
00354:  DATA 72,61
00356:  DATA 73,65
00358:  DATA 20,63
0035A:  DATA 6F,6D
0035C:  DATA 70,6C
0035E:  DATA 65,74
00360:  DATA 65,0D
00362:  DATA 0A,00
00364:  DATA 66,6C
00366:  DATA 61,73
00368:  DATA 68,20
0036A:  DATA 74,69
0036C:  DATA 6D,65
0036E:  DATA 6F,75
00370:  DATA 74,0D
00372:  DATA 0A,00
00374:  DATA 66,6C
00376:  DATA 61,73
00378:  DATA 68,20
0037A:  DATA 77,72
0037C:  DATA 69,74
0037E:  DATA 65,20
00380:  DATA 63,6F
00382:  DATA 6D,70
00384:  DATA 6C,65
00386:  DATA 74,65
00388:  DATA 0D,0A
0038A:  DATA 00,00
0038C:  DATA 66,6C
0038E:  DATA 61,73
00390:  DATA 68,20
00392:  DATA 74,69
00394:  DATA 6D,65
00396:  DATA 6F,75
00398:  DATA 74,0D
0039A:  DATA 0A,00
0039C:  DATA 66,6C
0039E:  DATA 61,73
003A0:  DATA 68,20
003A2:  DATA 77,72
003A4:  DATA 69,74
003A6:  DATA 65,20
003A8:  DATA 63,6F
003AA:  DATA 6D,70
003AC:  DATA 6C,65
003AE:  DATA 74,65
003B0:  DATA 0D,0A
003B2:  DATA 00,00
003B4:  DATA 53,74
003B6:  DATA 61,72
003B8:  DATA 74,20
003BA:  DATA 6D,61
003BC:  DATA 6B,65
003BE:  DATA 5F,72
003C0:  DATA 65,63
003C2:  DATA 65,69
003C4:  DATA 76,65
003C6:  DATA 5F,63
003C8:  DATA 6F,6D
003CA:  DATA 6D,61
003CC:  DATA 6E,64
003CE:  DATA 0D,0A
003D0:  DATA 09,2D
003D2:  DATA 3E,20
003D4:  DATA 00,00
003D6:  DATA 45,6E
003D8:  DATA 64,20
003DA:  DATA 6D,61
003DC:  DATA 6B,65
003DE:  DATA 5F,72
003E0:  DATA 65,63
003E2:  DATA 69,76
003E4:  DATA 65,5F
003E6:  DATA 63,6F
003E8:  DATA 6D,6D
003EA:  DATA 61,6E
003EC:  DATA 64,0D
003EE:  DATA 0A,00
003F0:  DATA 73,69
003F2:  DATA 67,6E
003F4:  DATA 61,6C
003F6:  DATA 20,65
003F8:  DATA 6E,64
003FA:  DATA 20,77
003FC:  DATA 69,74
003FE:  DATA 68,20
00400:  DATA 53,46
00402:  DATA 44,0D
00404:  DATA 0A,00
00406:  DATA 64,6F
00408:  DATA 6E,27
0040A:  DATA 74,20
0040C:  DATA 66,69
0040E:  DATA 6E,64
00410:  DATA 20,53
00412:  DATA 46,44
00414:  DATA 0D,0A
00416:  DATA 00,00
00418:  DATA 09,2D
0041A:  DATA 3E,20
0041C:  DATA 49,6E
0041E:  DATA 76,61
00420:  DATA 6C,69
00422:  DATA 64,20
00424:  DATA 46,72
00426:  DATA 61,6D
00428:  DATA 65,20
0042A:  DATA 49,44
0042C:  DATA 20,72
0042E:  DATA 65,63
00430:  DATA 65,69
00432:  DATA 76,65
00434:  DATA 64,3A
00436:  DATA 20,25
00438:  DATA 58,0D
0043A:  DATA 0A,00
0043C:  DATA 09,2D
0043E:  DATA 3E,20
00440:  DATA 43,52
00442:  DATA 43,20
00444:  DATA 65,72
00446:  DATA 72,6F
00448:  DATA 72,21
0044A:  DATA 0D,0A
0044C:  DATA 00,00
0044E:  DATA 09,09
00450:  DATA 2D,3E
00452:  DATA 20,72
00454:  DATA 65,63
00456:  DATA 65,69
00458:  DATA 76,65
0045A:  DATA 64,20
0045C:  DATA 43,52
0045E:  DATA 43,3A
00460:  DATA 20,25
00462:  DATA 58,0D
00464:  DATA 0A,00
00466:  DATA 09,09
00468:  DATA 20,20
0046A:  DATA 20,63
0046C:  DATA 6F,6C
0046E:  DATA 6C,65
00470:  DATA 63,74
00472:  DATA 20,43
00474:  DATA 52,43
00476:  DATA 20,3A
00478:  DATA 20,25
0047A:  DATA 58,0D
0047C:  DATA 0A,00
0047E:  DATA 09,2D
00480:  DATA 3E,20
00482:  DATA 49,6E
00484:  DATA 76,61
00486:  DATA 6C,69
00488:  DATA 64,20
0048A:  DATA 64,65
0048C:  DATA 76,69
0048E:  DATA 63,65
00490:  DATA 20,49
00492:  DATA 44,20
00494:  DATA 72,65
00496:  DATA 63,65
00498:  DATA 69,76
0049A:  DATA 65,64
0049C:  DATA 0D,0A
0049E:  DATA 00,00
004A0:  DATA 09,09
004A2:  DATA 2D,3E
004A4:  DATA 20,72
004A6:  DATA 65,63
004A8:  DATA 65,69
004AA:  DATA 76,65
004AC:  DATA 64,3A
004AE:  DATA 20,20
004B0:  DATA 20,20
004B2:  DATA 20,25
004B4:  DATA 58,0D
004B6:  DATA 0A,00
004B8:  DATA 09,09
004BA:  DATA 20,20
004BC:  DATA 20,4D
004BE:  DATA 79,20
004C0:  DATA 64,65
004C2:  DATA 76,69
004C4:  DATA 63,65
004C6:  DATA 20,49
004C8:  DATA 44,3A
004CA:  DATA 20,25
004CC:  DATA 58,0D
004CE:  DATA 0A,00
004D0:  DATA 54,72
004D2:  DATA 61,6E
004D4:  DATA 73,69
004D6:  DATA 74,20
004D8:  DATA 63,6F
004DA:  DATA 6D,6D
004DC:  DATA 61,6E
004DE:  DATA 64,0D
004E0:  DATA 0A,09
004E2:  DATA 2D,3E
004E4:  DATA 20,00
004E6:  DATA 21,21
004E8:  DATA 21,6F
004EA:  DATA 76,65
004EC:  DATA 72,66
004EE:  DATA 6C,6F
004F0:  DATA 77,20
004F2:  DATA 65,78
004F4:  DATA 65,63
004F6:  DATA 75,74
004F8:  DATA 65,64
004FA:  DATA 5F,6D
004FC:  DATA 69,73
004FE:  DATA 73,69
00500:  DATA 6F,6E
00502:  DATA 20,6C
00504:  DATA 69,73
00506:  DATA 74,0D
00508:  DATA 0A,00
0050A:  DATA 53,74
0050C:  DATA 61,72
0050E:  DATA 74,20
00510:  DATA 53,4D
00512:  DATA 46,20
00514:  DATA 75,73
00516:  DATA 69,6E
00518:  DATA 67,20
0051A:  DATA 72,65
0051C:  DATA 71,65
0051E:  DATA 73,74
00520:  DATA 20,73
00522:  DATA 65,61
00524:  DATA 71,75
00526:  DATA 65,6E
00528:  DATA 63,65
0052A:  DATA 0D,0A
0052C:  DATA 00,00
0052E:  DATA 45,72
00530:  DATA 72,6F
00532:  DATA 72,21
00534:  DATA 20,52
00536:  DATA 65,63
00538:  DATA 65,69
0053A:  DATA 76,69
0053C:  DATA 6E,67
0053E:  DATA 20,63
00540:  DATA 6F,6D
00542:  DATA 6D,61
00544:  DATA 6E,64
00546:  DATA 20,69
00548:  DATA 6E,63
0054A:  DATA 6F,6E
0054C:  DATA 73,69
0054E:  DATA 73,74
00550:  DATA 65,6E
00552:  DATA 74,20
00554:  DATA 77,69
00556:  DATA 74,68
00558:  DATA 20,74
0055A:  DATA 68,65
0055C:  DATA 20,64
0055E:  DATA 65,73
00560:  DATA 69,67
00562:  DATA 6E,0D
00564:  DATA 0A,00
00566:  DATA 53,4D
00568:  DATA 46,20
0056A:  DATA 75,73
0056C:  DATA 65,20
0056E:  DATA 72,65
00570:  DATA 71,75
00572:  DATA 65,73
00574:  DATA 74,20
00576:  DATA 61,6C
00578:  DATA 6C,6F
0057A:  DATA 77,65
0057C:  DATA 64,0D
0057E:  DATA 0A,00
00580:  DATA 53,4D
00582:  DATA 46,20
00584:  DATA 75,73
00586:  DATA 65,20
00588:  DATA 72,65
0058A:  DATA 71,75
0058C:  DATA 65,73
0058E:  DATA 74,20
00590:  DATA 64,65
00592:  DATA 6E,79
00594:  DATA 65,64
00596:  DATA 0D,0A
00598:  DATA 00,00
0059A:  DATA 52,65
0059C:  DATA 74,72
0059E:  DATA 79,20
005A0:  DATA 72,65
005A2:  DATA 71,75
005A4:  DATA 65,73
005A6:  DATA 74,20
005A8:  DATA 74,6F
005AA:  DATA 20,42
005AC:  DATA 4F,53
005AE:  DATA 53,20
005B0:  DATA 50,49
005B2:  DATA 43,0D
005B4:  DATA 0A,00
005B6:  DATA 45,72
005B8:  DATA 72,6F
005BA:  DATA 72,21
005BC:  DATA 20,52
005BE:  DATA 65,63
005C0:  DATA 65,69
005C2:  DATA 76,69
005C4:  DATA 6E,67
005C6:  DATA 20,63
005C8:  DATA 6F,6D
005CA:  DATA 6D,61
005CC:  DATA 6E,64
005CE:  DATA 20,69
005D0:  DATA 6E,63
005D2:  DATA 6F,6E
005D4:  DATA 73,69
005D6:  DATA 73,74
005D8:  DATA 65,6E
005DA:  DATA 74,20
005DC:  DATA 77,69
005DE:  DATA 74,68
005E0:  DATA 20,74
005E2:  DATA 68,65
005E4:  DATA 20,64
005E6:  DATA 65,73
005E8:  DATA 69,67
005EA:  DATA 6E,0D
005EC:  DATA 0A,00
005EE:  DATA 45,6E
005F0:  DATA 64,20
005F2:  DATA 53,4D
005F4:  DATA 46,20
005F6:  DATA 75,73
005F8:  DATA 69,6E
005FA:  DATA 67,20
005FC:  DATA 72,65
005FE:  DATA 71,65
00600:  DATA 73,74
00602:  DATA 20,73
00604:  DATA 65,61
00606:  DATA 71,75
00608:  DATA 65,6E
0060A:  DATA 63,65
0060C:  DATA 0D,0A
0060E:  DATA 00,00
00610:  DATA 0D,0A
00612:  DATA 54,68
00614:  DATA 69,73
00616:  DATA 20,20
00618:  DATA 6D,69
0061A:  DATA 73,73
0061C:  DATA 69,6F
0061E:  DATA 6E,20
00620:  DATA 69,73
00622:  DATA 20,65
00624:  DATA 78,65
00626:  DATA 63,75
00628:  DATA 74,65
0062A:  DATA 64,0D
0062C:  DATA 0A,09
0062E:  DATA 2D,3E
00630:  DATA 20,30
00632:  DATA 78,25
00634:  DATA 64,0D
00636:  DATA 0A,00
00638:  DATA 0D,0A
0063A:  DATA 5F,5F
0063C:  DATA 5F,5F
0063E:  DATA 5F,5F
00640:  DATA 5F,5F
00642:  DATA 5F,5F
00644:  DATA 5F,5F
00646:  DATA 5F,5F
00648:  DATA 5F,5F
0064A:  DATA 5F,5F
0064C:  DATA 5F,5F
0064E:  DATA 5F,5F
00650:  DATA 5F,5F
00652:  DATA 5F,5F
00654:  DATA 5F,5F
00656:  DATA 5F,5F
00658:  DATA 0D,0A
0065A:  DATA 5F,5F
0065C:  DATA 5F,5F
0065E:  DATA 5F,53
00660:  DATA 74,61
00662:  DATA 72,74
00664:  DATA 20,65
00666:  DATA 78,65
00668:  DATA 63,75
0066A:  DATA 74,65
0066C:  DATA 5F,6D
0066E:  DATA 69,73
00670:  DATA 73,69
00672:  DATA 6F,6E
00674:  DATA 5F,5F
00676:  DATA 5F,5F
00678:  DATA 5F,0D
0067A:  DATA 0A,0D
0067C:  DATA 0A,00
0067E:  DATA 43,6F
00680:  DATA 6D,6D
00682:  DATA 61,6E
00684:  DATA 64,20
00686:  DATA 49,44
00688:  DATA 3A,20
0068A:  DATA 25,58
0068C:  DATA 0D,0A
0068E:  DATA 0D,0A
00690:  DATA 00,00
00692:  DATA 09,09
00694:  DATA 2D,3E
00696:  DATA 20,49
00698:  DATA 6E,76
0069A:  DATA 61,6C
0069C:  DATA 69,64
0069E:  DATA 20,43
006A0:  DATA 4D,44
006A2:  DATA 20,49
006A4:  DATA 44,21
006A6:  DATA 0D,0A
006A8:  DATA 00,00
006AA:  DATA 0D,0A
006AC:  DATA 5F,5F
006AE:  DATA 5F,5F
006B0:  DATA 5F,5F
006B2:  DATA 45,6E
006B4:  DATA 64,20
006B6:  DATA 65,78
006B8:  DATA 65,63
006BA:  DATA 75,74
006BC:  DATA 65,5F
006BE:  DATA 6D,69
006C0:  DATA 73,73
006C2:  DATA 69,6F
006C4:  DATA 6E,5F
006C6:  DATA 5F,5F
006C8:  DATA 5F,5F
006CA:  DATA 5F,0D
006CC:  DATA 0A,5F
006CE:  DATA 5F,5F
006D0:  DATA 5F,5F
006D2:  DATA 5F,5F
006D4:  DATA 5F,5F
006D6:  DATA 5F,5F
006D8:  DATA 5F,5F
006DA:  DATA 5F,5F
006DC:  DATA 5F,5F
006DE:  DATA 5F,5F
006E0:  DATA 5F,5F
006E2:  DATA 5F,5F
006E4:  DATA 5F,5F
006E6:  DATA 5F,5F
006E8:  DATA 5F,5F
006EA:  DATA 5F,5F
006EC:  DATA 0D,0A
006EE:  DATA 00,00
006F0:  DATA 53,74
006F2:  DATA 61,72
006F4:  DATA 74,20
006F6:  DATA 65,78
006F8:  DATA 61,6D
006FA:  DATA 70,6C
006FC:  DATA 65,5F
006FE:  DATA 30,30
00700:  DATA 0D,0A
00702:  DATA 00,00
00704:  DATA 70,61
00706:  DATA 72,61
00708:  DATA 6D,65
0070A:  DATA 74,65
0070C:  DATA 72,20
0070E:  DATA 3A,20
00710:  DATA 00,00
00712:  DATA 28,54
00714:  DATA 68,69
00716:  DATA 73,20
00718:  DATA 6D,69
0071A:  DATA 73,73
0071C:  DATA 69,6F
0071E:  DATA 6E,20
00720:  DATA 63,61
00722:  DATA 6E,20
00724:  DATA 65,78
00726:  DATA 65,63
00728:  DATA 75,74
0072A:  DATA 65,20
0072C:  DATA 6D,61
0072E:  DATA 6E,79
00730:  DATA 20,74
00732:  DATA 69,6D
00734:  DATA 65,20
00736:  DATA 61,73
00738:  DATA 20,79
0073A:  DATA 6F,75
0073C:  DATA 20,77
0073E:  DATA 61,6E
00740:  DATA 74,29
00742:  DATA 0D,0A
00744:  DATA 00,00
00746:  DATA 65,78
00748:  DATA 65,63
0074A:  DATA 75,74
0074C:  DATA 69,6E
0074E:  DATA 67,00
00750:  DATA 2E,0D
00752:  DATA 0A,00
00754:  DATA 6F,72
00756:  DATA 64,65
00758:  DATA 72,20
0075A:  DATA 43,6F
0075C:  DATA 70,79
0075E:  DATA 20,73
00760:  DATA 6D,66
00762:  DATA 5F,64
00764:  DATA 61,74
00766:  DATA 61,0D
00768:  DATA 0A,00
0076A:  DATA 45,6E
0076C:  DATA 64,20
0076E:  DATA 65,78
00770:  DATA 61,6D
00772:  DATA 70,6C
00774:  DATA 65,5F
00776:  DATA 30,30
00778:  DATA 0D,0A
0077A:  DATA 00,00
0077C:  DATA 53,74
0077E:  DATA 61,72
00780:  DATA 74,20
00782:  DATA 65,78
00784:  DATA 61,6D
00786:  DATA 70,6C
00788:  DATA 65,5F
0078A:  DATA 30,31
0078C:  DATA 0D,0A
0078E:  DATA 00,00
00790:  DATA 70,61
00792:  DATA 72,61
00794:  DATA 6D,65
00796:  DATA 74,65
00798:  DATA 72,20
0079A:  DATA 3A,20
0079C:  DATA 00,00
0079E:  DATA 54,68
007A0:  DATA 69,73
007A2:  DATA 20,6D
007A4:  DATA 69,73
007A6:  DATA 73,69
007A8:  DATA 6F,6E
007AA:  DATA 20,77
007AC:  DATA 61,69
007AE:  DATA 74,20
007B0:  DATA 66,6F
007B2:  DATA 72,20
007B4:  DATA 35,20
007B6:  DATA 73,65
007B8:  DATA 63,6F
007BA:  DATA 6E,64
007BC:  DATA 73,0D
007BE:  DATA 0A,00
007C0:  DATA 65,78
007C2:  DATA 65,63
007C4:  DATA 75,74
007C6:  DATA 69,6E
007C8:  DATA 67,00
007CA:  DATA 45,6E
007CC:  DATA 64,20
007CE:  DATA 65,78
007D0:  DATA 61,6D
007D2:  DATA 70,6C
007D4:  DATA 65,5F
007D6:  DATA 30,31
007D8:  DATA 0D,0A
007DA:  DATA 00,00
007DC:  DATA 53,74
007DE:  DATA 61,72
007E0:  DATA 74,20
007E2:  DATA 65,78
007E4:  DATA 61,6D
007E6:  DATA 70,6C
007E8:  DATA 65,5F
007EA:  DATA 30,32
007EC:  DATA 0D,0A
007EE:  DATA 00,00
007F0:  DATA 70,61
007F2:  DATA 72,61
007F4:  DATA 6D,65
007F6:  DATA 74,65
007F8:  DATA 72,20
007FA:  DATA 3A,20
007FC:  DATA 00,00
007FE:  DATA 54,68
00800:  DATA 69,73
00802:  DATA 20,6D
00804:  DATA 69,73
00806:  DATA 73,69
00808:  DATA 6F,6E
0080A:  DATA 20,77
0080C:  DATA 69,6C
0080E:  DATA 6C,20
00810:  DATA 66,69
00812:  DATA 72,73
00814:  DATA 74,20
00816:  DATA 61,63
00818:  DATA 63,65
0081A:  DATA 73,73
0081C:  DATA 20,73
0081E:  DATA 6D,66
00820:  DATA 20,61
00822:  DATA 6E,64
00824:  DATA 20,74
00826:  DATA 68,65
00828:  DATA 6E,20
0082A:  DATA 77,61
0082C:  DATA 69,74
0082E:  DATA 20,66
00830:  DATA 6F,72
00832:  DATA 20,35
00834:  DATA 20,73
00836:  DATA 65,63
00838:  DATA 6F,6E
0083A:  DATA 64,73
0083C:  DATA 0D,0A
0083E:  DATA 00,00
00840:  DATA 41,63
00842:  DATA 63,65
00844:  DATA 73,73
00846:  DATA 20,74
00848:  DATA 6F,20
0084A:  DATA 53,4D
0084C:  DATA 46,00
0084E:  DATA 45,6E
00850:  DATA 64,20
00852:  DATA 75,73
00854:  DATA 65,20
00856:  DATA 53,4D
00858:  DATA 46,0D
0085A:  DATA 0A,00
0085C:  DATA 77,61
0085E:  DATA 69,74
00860:  DATA 20,66
00862:  DATA 6F,72
00864:  DATA 20,31
00866:  DATA 30,20
00868:  DATA 73,65
0086A:  DATA 63,6F
0086C:  DATA 6E,6F
0086E:  DATA 64,73
00870:  DATA 20,28
00872:  DATA 65,78
00874:  DATA 65,63
00876:  DATA 20,6D
00878:  DATA 69,73
0087A:  DATA 73,69
0087C:  DATA 6F,6E
0087E:  DATA 20,73
00880:  DATA 69,6D
00882:  DATA 29,0D
00884:  DATA 0A,00
00886:  DATA 46,61
00888:  DATA 69,6C
0088A:  DATA 75,72
0088C:  DATA 65,20
0088E:  DATA 74,6F
00890:  DATA 20,41
00892:  DATA 63,63
00894:  DATA 65,73
00896:  DATA 73,20
00898:  DATA 74,6F
0089A:  DATA 20,53
0089C:  DATA 4D,46
0089E:  DATA 00,00
008A0:  DATA 45,6E
008A2:  DATA 64,20
008A4:  DATA 65,78
008A6:  DATA 61,6D
008A8:  DATA 70,6C
008AA:  DATA 65,5F
008AC:  DATA 30,32
008AE:  DATA 0D,0A
008B0:  DATA 00,00
008B2:  DATA 44,65
008B4:  DATA 73,74
008B6:  DATA 69,6E
008B8:  DATA 61,74
008BA:  DATA 69,6F
008BC:  DATA 6E,20
008BE:  DATA 61,64
008C0:  DATA 64,72
008C2:  DATA 65,73
008C4:  DATA 73,3A
008C6:  DATA 20,09
008C8:  DATA 30,78
008CA:  DATA 25,30
008CC:  DATA 38,4C
008CE:  DATA 58,0D
008D0:  DATA 0A,00
008D2:  DATA 53,6F
008D4:  DATA 75,72
008D6:  DATA 63,65
008D8:  DATA 20,61
008DA:  DATA 64,64
008DC:  DATA 72,65
008DE:  DATA 73,73
008E0:  DATA 3A,20
008E2:  DATA 09,30
008E4:  DATA 78,25
008E6:  DATA 30,38
008E8:  DATA 4C,58
008EA:  DATA 0D,0A
008EC:  DATA 00,00
008EE:  DATA 44,61
008F0:  DATA 74,61
008F2:  DATA 20,73
008F4:  DATA 69,7A
008F6:  DATA 65,3A
008F8:  DATA 20,09
008FA:  DATA 09,20
008FC:  DATA 20,25
008FE:  DATA 30,38
00900:  DATA 4C,58
00902:  DATA 0D,0A
00904:  DATA 00,00
00906:  DATA 43,6F
00908:  DATA 70,79
0090A:  DATA 69,6E
0090C:  DATA 67,2E
0090E:  DATA 00,00
00910:  DATA 2E,0D
00912:  DATA 0A,00
00914:  DATA 5F,5F
00916:  DATA 5F,5F
00918:  DATA 5F,5F
0091A:  DATA 5F,5F
0091C:  DATA 5F,45
0091E:  DATA 6E,64
00920:  DATA 20,63
00922:  DATA 6F,70
00924:  DATA 79,5F
00926:  DATA 64,61
00928:  DATA 74,61
0092A:  DATA 5F,5F
0092C:  DATA 5F,5F
0092E:  DATA 5F,5F
00930:  DATA 5F,5F
00932:  DATA 5F,0D
00934:  DATA 0A,5F
00936:  DATA 5F,5F
00938:  DATA 5F,5F
0093A:  DATA 5F,5F
0093C:  DATA 5F,5F
0093E:  DATA 5F,5F
00940:  DATA 5F,5F
00942:  DATA 5F,5F
00944:  DATA 5F,5F
00946:  DATA 5F,5F
00948:  DATA 5F,5F
0094A:  DATA 5F,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,5F
00950:  DATA 5F,5F
00952:  DATA 5F,0D
00954:  DATA 0A,0D
00956:  DATA 0A,00
00958:  DATA 53,74
0095A:  DATA 61,72
0095C:  DATA 74,20
0095E:  DATA 73,65
00960:  DATA 74,74
00962:  DATA 69,6E
00964:  DATA 67,0D
00966:  DATA 0A,00
00968:  DATA 45,6E
0096A:  DATA 64,20
0096C:  DATA 73,65
0096E:  DATA 74,74
00970:  DATA 69,6E
00972:  DATA 67,0D
00974:  DATA 0A,00
00976:  DATA 0D,0A
00978:  DATA 53,74
0097A:  DATA 61,72
0097C:  DATA 74,20
0097E:  DATA 65,78
00980:  DATA 65,63
00982:  DATA 75,74
00984:  DATA 65,5F
00986:  DATA 63,6F
00988:  DATA 6D,6D
0098A:  DATA 61,6E
0098C:  DATA 64,0D
0098E:  DATA 0A,00
00990:  DATA 09,2D
00992:  DATA 3E,20
00994:  DATA 55,70
00996:  DATA 6C,69
00998:  DATA 6E,6B
0099A:  DATA 20,63
0099C:  DATA 6F,6D
0099E:  DATA 6D,61
009A0:  DATA 6E,64
009A2:  DATA 0D,0A
009A4:  DATA 00,00
009A6:  DATA 09,20
009A8:  DATA 20,20
009AA:  DATA 54,72
009AC:  DATA 61,6E
009AE:  DATA 73,6D
009B0:  DATA 69,74
009B2:  DATA 20,41
009B4:  DATA 63,6B
009B6:  DATA 6E,6F
009B8:  DATA 6C,65
009BA:  DATA 67,64
009BC:  DATA 65,0D
009BE:  DATA 0A,00
009C0:  DATA 09,2D
009C2:  DATA 3E,20
009C4:  DATA 53,74
009C6:  DATA 61,74
009C8:  DATA 75,73
009CA:  DATA 20,63
009CC:  DATA 68,65
009CE:  DATA 63,6B
009D0:  DATA 0D,0A
009D2:  DATA 00,00
009D4:  DATA 09,09
009D6:  DATA 2D,3E
009D8:  DATA 20,4D
009DA:  DATA 79,20
009DC:  DATA 73,74
009DE:  DATA 61,74
009E0:  DATA 75,73
009E2:  DATA 20,69
009E4:  DATA 73,20
009E6:  DATA 25,64
009E8:  DATA 0D,0A
009EA:  DATA 00,00
009EC:  DATA 09,20
009EE:  DATA 20,20
009F0:  DATA 54,72
009F2:  DATA 61,6E
009F4:  DATA 73,6D
009F6:  DATA 69,74
009F8:  DATA 20,4D
009FA:  DATA 49,53
009FC:  DATA 20,4D
009FE:  DATA 43,55
00A00:  DATA 20,53
00A02:  DATA 74,61
00A04:  DATA 74,75
00A06:  DATA 73,0D
00A08:  DATA 0A,00
00A0A:  DATA 66,69
00A0C:  DATA 6E,69
00A0E:  DATA 73,68
00A10:  DATA 65,64
00A12:  DATA 20,69
00A14:  DATA 6E,20
00A16:  DATA 73,74
00A18:  DATA 61,74
00A1A:  DATA 75,73
00A1C:  DATA 5F,63
00A1E:  DATA 68,65
00A20:  DATA 63,6B
00A22:  DATA 0D,0A
00A24:  DATA 00,00
00A26:  DATA 09,2D
00A28:  DATA 3E,20
00A2A:  DATA 69,73
00A2C:  DATA 20,53
00A2E:  DATA 4D,46
00A30:  DATA 20,61
00A32:  DATA 76,61
00A34:  DATA 69,6C
00A36:  DATA 61,62
00A38:  DATA 6C,65
00A3A:  DATA 0D,0A
00A3C:  DATA 00,00
00A3E:  DATA 09,20
00A40:  DATA 20,20
00A42:  DATA 54,72
00A44:  DATA 61,6E
00A46:  DATA 73,6D
00A48:  DATA 69,74
00A4A:  DATA 20,41
00A4C:  DATA 63,6B
00A4E:  DATA 6E,6F
00A50:  DATA 6C,65
00A52:  DATA 67,64
00A54:  DATA 65,0D
00A56:  DATA 0A,00
00A58:  DATA 09,09
00A5A:  DATA 2D,3E
00A5C:  DATA 20,61
00A5E:  DATA 6C,6C
00A60:  DATA 6F,77
00A62:  DATA 64,0D
00A64:  DATA 0A,00
00A66:  DATA 09,09
00A68:  DATA 2D,3E
00A6A:  DATA 20,64
00A6C:  DATA 65,6E
00A6E:  DATA 79,65
00A70:  DATA 64,0D
00A72:  DATA 0A,00
00A74:  DATA 0D,0A
00A76:  DATA 0D,0A
00A78:  DATA 00,00
00A7A:  DATA 5F,5F
00A7C:  DATA 5F,5F
00A7E:  DATA 5F,5F
00A80:  DATA 5F,5F
00A82:  DATA 5F,5F
00A84:  DATA 5F,53
00A86:  DATA 74,61
00A88:  DATA 72,74
00A8A:  DATA 20,6D
00A8C:  DATA 61,69
00A8E:  DATA 6E,5F
00A90:  DATA 5F,5F
00A92:  DATA 5F,5F
00A94:  DATA 5F,5F
00A96:  DATA 5F,5F
00A98:  DATA 5F,0D
00A9A:  DATA 0A,0D
00A9C:  DATA 0A,00
00A9E:  DATA 0D,0A
00AA0:  DATA 0D,0A
00AA2:  DATA 3D,3D
00AA4:  DATA 3D,3D
00AA6:  DATA 3D,3D
00AA8:  DATA 0D,0A
00AAA:  DATA 0D,0A
00AAC:  DATA 46,69
00AAE:  DATA 6E,69
00AB0:  DATA 73,68
00AB2:  DATA 65,64
00AB4:  DATA 20,70
00AB6:  DATA 72,6F
00AB8:  DATA 63,65
00ABA:  DATA 73,73
00ABC:  DATA 2E,0D
00ABE:  DATA 0A,57
00AC0:  DATA 61,69
00AC2:  DATA 74,20
00AC4:  DATA 66,6F
00AC6:  DATA 72,20
00AC8:  DATA 42,4F
00ACA:  DATA 53,53
00ACC:  DATA 20,50
00ACE:  DATA 49,43
00AD0:  DATA 20,74
00AD2:  DATA 75,72
00AD4:  DATA 6E,20
00AD6:  DATA 6F,66
00AD8:  DATA 66,20
00ADA:  DATA 6D,65
00ADC:  DATA 00,00
00ADE:  DATA 45,6E
00AE0:  DATA 64,20
00AE2:  DATA 6D,61
00AE4:  DATA 69,6E
00AE6:  DATA 0D,0A
00AE8:  DATA 00,00
*
00B4C:  MOVLB  1
00B4E:  BTFSC  xDD.7
00B50:  BRA    0B76
00B52:  MOVLW  0F
00B54:  MOVWF  00
00B56:  SWAPF  xDC,W
00B58:  ANDWF  00,F
00B5A:  MOVLW  0A
00B5C:  SUBWF  00,W
00B5E:  BC    0B66
00B60:  MOVLW  30
00B62:  ADDWF  00,F
00B64:  BRA    0B6A
00B66:  MOVF   xDD,W
00B68:  ADDWF  00,F
00B6A:  MOVF   00,W
00B6C:  BTFSS  FA4.4
00B6E:  BRA    0B6C
00B70:  MOVLB  F
00B72:  MOVWF  x1D
00B74:  MOVLB  1
00B76:  MOVLW  0F
00B78:  ANDWF  xDC,F
00B7A:  MOVLW  0A
00B7C:  SUBWF  xDC,W
00B7E:  BC    0B84
00B80:  MOVLW  30
00B82:  BRA    0B88
00B84:  BCF    xDD.7
00B86:  MOVF   xDD,W
00B88:  ADDWF  xDC,F
00B8A:  MOVF   xDC,W
00B8C:  BTFSS  FA4.4
00B8E:  BRA    0B8C
00B90:  MOVLB  F
00B92:  MOVWF  x1D
00B94:  MOVLB  0
00B96:  RETURN 0
*
00C28:  TBLRD*+
00C2A:  MOVFF  FF6,1DD
00C2E:  MOVFF  FF7,1DE
00C32:  MOVFF  FF8,1DF
00C36:  MOVF   FF5,W
00C38:  BTFSS  FA4.4
00C3A:  BRA    0C38
00C3C:  MOVLB  F
00C3E:  MOVWF  x1D
00C40:  MOVFF  1DD,FF6
00C44:  MOVFF  1DE,FF7
00C48:  MOVFF  1DF,FF8
00C4C:  MOVLB  1
00C4E:  DECFSZ xDC,F
00C50:  BRA    0C54
00C52:  BRA    0C58
00C54:  MOVLB  0
00C56:  BRA    0C28
00C58:  MOVLB  0
00C5A:  RETURN 0
*
01094:  TSTFSZ 01
01096:  BRA    109E
01098:  TSTFSZ 02
0109A:  BRA    10A0
0109C:  BRA    10AC
0109E:  INCF   02,F
010A0:  MOVFF  00,FEE
010A4:  DECFSZ 01,F
010A6:  BRA    10A0
010A8:  DECFSZ 02,F
010AA:  BRA    10A0
010AC:  GOTO   10CC (RETURN)
*
01268:  MOVLB  1
0126A:  MOVF   x5C,W
0126C:  CLRF   01
0126E:  SUBWF  x5B,W
01270:  BC    1278
01272:  MOVFF  15B,00
01276:  BRA    1290
01278:  CLRF   00
0127A:  MOVLW  08
0127C:  MOVWF  x5D
0127E:  RLCF   x5B,F
01280:  RLCF   00,F
01282:  MOVF   x5C,W
01284:  SUBWF  00,W
01286:  BTFSC  FD8.0
01288:  MOVWF  00
0128A:  RLCF   01,F
0128C:  DECFSZ x5D,F
0128E:  BRA    127E
01290:  MOVLB  0
01292:  RETURN 0
01294:  MOVLW  20
01296:  MOVLB  1
01298:  BTFSS  x56.4
0129A:  MOVLW  30
0129C:  MOVWF  x57
0129E:  MOVFF  155,00
012A2:  BTFSS  00.7
012A4:  BRA    12B6
012A6:  COMF   00,F
012A8:  INCF   00,F
012AA:  MOVFF  00,155
012AE:  MOVLW  2D
012B0:  MOVWF  x57
012B2:  BSF    x56.7
012B4:  BSF    x56.0
012B6:  MOVF   01,W
012B8:  MOVFF  155,15B
012BC:  MOVLW  64
012BE:  MOVWF  x5C
012C0:  MOVLB  0
012C2:  RCALL  1268
012C4:  MOVFF  00,155
012C8:  MOVLW  30
012CA:  ADDWF  01,W
012CC:  MOVLB  1
012CE:  MOVWF  x58
012D0:  MOVFF  155,15B
012D4:  MOVLW  0A
012D6:  MOVWF  x5C
012D8:  MOVLB  0
012DA:  RCALL  1268
012DC:  MOVLW  30
012DE:  ADDWF  00,W
012E0:  MOVLB  1
012E2:  MOVWF  x5A
012E4:  MOVLW  30
012E6:  ADDWF  01,W
012E8:  MOVWF  x59
012EA:  MOVFF  157,00
012EE:  MOVLW  30
012F0:  SUBWF  x58,W
012F2:  BZ    12FC
012F4:  BSF    x56.1
012F6:  BTFSC  x56.7
012F8:  BSF    x56.2
012FA:  BRA    1320
012FC:  MOVFF  157,158
01300:  MOVLW  20
01302:  MOVWF  x57
01304:  MOVLW  30
01306:  SUBWF  x59,W
01308:  BZ    1312
0130A:  BSF    x56.0
0130C:  BTFSC  x56.7
0130E:  BSF    x56.1
01310:  BRA    1320
01312:  BTFSS  FD8.2
01314:  BSF    x56.0
01316:  BNZ   1320
01318:  MOVFF  158,159
0131C:  MOVLW  20
0131E:  MOVWF  x58
01320:  BTFSC  x56.2
01322:  BRA    132E
01324:  BTFSC  x56.1
01326:  BRA    133A
01328:  BTFSC  x56.0
0132A:  BRA    1346
0132C:  BRA    1352
0132E:  MOVF   x57,W
01330:  BTFSS  FA4.4
01332:  BRA    1330
01334:  MOVLB  F
01336:  MOVWF  x1D
01338:  MOVLB  1
0133A:  MOVF   x58,W
0133C:  BTFSS  FA4.4
0133E:  BRA    133C
01340:  MOVLB  F
01342:  MOVWF  x1D
01344:  MOVLB  1
01346:  MOVF   x59,W
01348:  BTFSS  FA4.4
0134A:  BRA    1348
0134C:  MOVLB  F
0134E:  MOVWF  x1D
01350:  MOVLB  1
01352:  MOVF   x5A,W
01354:  BTFSS  FA4.4
01356:  BRA    1354
01358:  MOVLB  F
0135A:  MOVWF  x1D
0135C:  MOVLB  0
0135E:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... // pin assignment etc
.................... #include "config.h"
.................... #ifndef CONFIG_H
.................... #define CONFIG_H
.................... 
.................... #device ADC=12
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... 
.................... // clock
.................... #use delay(crystal=16MHz, clock=16MHz)
*
01402:  MOVLW  01
01404:  MOVWF  FEA
01406:  MOVLW  A5
01408:  MOVWF  FE9
0140A:  MOVF   FEF,W
0140C:  BZ    142A
0140E:  MOVLW  05
01410:  MOVWF  01
01412:  CLRF   00
01414:  DECFSZ 00,F
01416:  BRA    1414
01418:  DECFSZ 01,F
0141A:  BRA    1412
0141C:  MOVLW  2E
0141E:  MOVWF  00
01420:  DECFSZ 00,F
01422:  BRA    1420
01424:  BRA    1426
01426:  DECFSZ FEF,F
01428:  BRA    140E
0142A:  RETURN 0
.................... 
.................... 
.................... // uart
.................... #pin_select U1TX = PIN_F7
.................... #pin_select U1RX = PIN_F5
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_F7,rcv=PIN_F5,bits=8,stream=BOSS)
*
010E0:  BTFSS  F9E.4
010E2:  BRA    10E0
010E4:  MOVWF  FAD
010E6:  GOTO   110A (RETURN)
.................... 
.................... #pin_select U2TX = PIN_D3
.................... #pin_select U2RX = PIN_D2
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_D3,rcv=PIN_D2,bits=8,stream=PC)
.................... 
.................... #pin_select U3TX = PIN_E5
.................... #pin_select U3RX = PIN_E4
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_E5,rcv=PIN_E4,bits=8,stream=PORT3)
.................... 
.................... #pin_select U4TX = PIN_E3
.................... #pin_select U4RX = PIN_F2
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_E3,rcv=PIN_F2,bits=8,stream=PORT4)
.................... 
.................... // spi
.................... #define SPI0_CS PIN_A2
.................... #use spi (MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1,BAUD=1000000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
.................... 
.................... #define SPI1_CS PIN_B3
.................... #use spi (MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4,BAUD=1000000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "./lib/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x00,
....................     DENY  = 0x01
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile unsigned int16 duration_sec = 0;
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status = IDLE;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... volatile unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #include "./src/timer.c"
.................... #INT_TIMER0
.................... static void TIMER0_isr(void)
.................... {
....................    // every 0.01 sec interrupts
....................    set_timer0(100);
*
000CA:  CLRF   FD7
000CC:  MOVLW  64
000CE:  MOVWF  FD6
000D0:  NOP   
.................... 
....................    if (++subsec >= 100)
000D2:  MOVLW  01
000D4:  ADDWF  20,F
000D6:  BTFSC  FD8.0
000D8:  INCF   21,F
000DA:  BTFSC  FD8.2
000DC:  INCF   22,F
000DE:  BTFSC  FD8.2
000E0:  INCF   23,F
000E2:  MOVF   23,F
000E4:  BNZ   00F4
000E6:  MOVF   22,F
000E8:  BNZ   00F4
000EA:  MOVF   21,F
000EC:  BNZ   00F4
000EE:  MOVF   20,W
000F0:  SUBLW  63
000F2:  BC    0140
....................    {
....................       subsec = 0;
000F4:  CLRF   23
000F6:  CLRF   22
000F8:  CLRF   21
000FA:  CLRF   20
....................       sec++;
000FC:  MOVLW  01
000FE:  ADDWF  24,F
00100:  BTFSC  FD8.0
00102:  INCF   25,F
00104:  BTFSC  FD8.2
00106:  INCF   26,F
00108:  BTFSC  FD8.2
0010A:  INCF   27,F
.................... 
....................       if (sec >= SEC_IN_A_DAY)
0010C:  MOVF   27,F
0010E:  BNZ   012A
00110:  MOVF   26,W
00112:  SUBLW  00
00114:  BC    0140
00116:  XORLW  FF
00118:  BNZ   012A
0011A:  MOVF   25,W
0011C:  SUBLW  50
0011E:  BC    0140
00120:  XORLW  FF
00122:  BNZ   012A
00124:  MOVF   24,W
00126:  SUBLW  7F
00128:  BC    0140
....................       {
....................          sec -= SEC_IN_A_DAY;
0012A:  MOVLW  80
0012C:  SUBWF  24,F
0012E:  MOVLW  51
00130:  SUBWFB 25,F
00132:  MOVLW  01
00134:  SUBWFB 26,F
00136:  MOVLW  00
00138:  SUBWFB 27,F
....................          day++;
0013A:  INCF   28,F
0013C:  BTFSC  FD8.2
0013E:  INCF   29,F
....................       }
....................    }
00140:  BCF    FF2.2
00142:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    setup_timer_0(T0_INTERNAL | T0_DIV_256 | RTCC_8_BIT);
*
00AEA:  MOVLW  D7
00AEC:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0);
00AEE:  BSF    FF2.5
00AF0:  GOTO   0B26 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... #include "./src/uart.c"
.................... #INT_RDA
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00174:  MOVF   1F,W
00176:  SUBLW  02
00178:  BZ    0180
0017A:  MOVF   1F,W
0017C:  SUBLW  05
0017E:  BNZ   0184
00180:  BTFSS  1E.0
00182:  BRA    01BA
....................    {
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00184:  MOVF   4A,W
00186:  SUBLW  1F
00188:  BNC   01A4
....................          boss_receive_buffer[boss_receive_buffer_size++] = fgetc(BOSS);
0018A:  MOVF   4A,W
0018C:  INCF   4A,F
0018E:  CLRF   03
00190:  ADDLW  2A
00192:  MOVWF  FE9
00194:  MOVLW  00
00196:  ADDWFC 03,W
00198:  MOVWF  FEA
0019A:  BTFSS  F9E.5
0019C:  BRA    019A
0019E:  MOVFF  FAE,FEF
001A2:  BRA    01BA
....................       else
....................       {
....................          fprintf(PC, "\r\nOverflow BOSS receive signal buffer!!!\r\n\r\n");
001A4:  MOVLW  C0
001A6:  MOVWF  FF6
001A8:  MOVLW  01
001AA:  MOVWF  FF7
001AC:  MOVLW  00
001AE:  MOVWF  FF8
001B0:  RCALL  0146
....................          boss_receive_buffer[RECEIVE_BUFFER_MAX-1] = fgetc(BOSS);
001B2:  BTFSS  F9E.5
001B4:  BRA    01B2
001B6:  MOVFF  FAE,49
....................       }
....................    }
001BA:  BCF    F9E.5
001BC:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    enable_interrupts(INT_RDA);
*
00AF4:  BSF    F9D.5
00AF6:  GOTO   0B28 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
010B0:  MOVFF  1A7,FEA
010B4:  MOVFF  1A6,FE9
010B8:  MOVFF  FEF,01
010BC:  MOVFF  1A5,FEA
010C0:  MOVFF  1A4,FE9
010C4:  CLRF   00
010C6:  CLRF   02
010C8:  MOVLB  0
010CA:  BRA    1094
....................    *receive_signal_size = 0;
010CC:  MOVFF  1A7,03
010D0:  MOVLB  1
010D2:  MOVFF  1A6,FE9
010D6:  MOVFF  03,FEA
010DA:  CLRF   FEF
010DC:  MOVLB  0
010DE:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... // Missions
.................... #include "mission.h"
.................... #ifndef MISSION_H
.................... #define MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 8
.................... 
.................... #include "./lib/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "./src/smf_queue.c"
.................... void enqueue_smf_data(SmfDataStruct *data)
*
0142C:  MOVLW  01
0142E:  MOVLB  1
01430:  ADDWF  x0E,W
01432:  ANDLW  0F
01434:  MOVWF  x73
.................... {   
....................    int8 next_tail = (smf_queue.smf_data_tail + 1) % SMF_DATA_SIZE;
.................... 
....................    if(next_tail == smf_queue.smf_data_head)
01436:  MOVF   x0D,W
01438:  SUBWF  x73,W
0143A:  BNZ   145E
....................       fprintf(PC, "SMF data list is full!!!\r\n");
0143C:  MOVLW  EE
0143E:  MOVWF  FF6
01440:  MOVLW  01
01442:  MOVWF  FF7
01444:  MOVLW  00
01446:  MOVWF  FF8
01448:  CLRF   1B
0144A:  BTFSC  FF2.7
0144C:  BSF    1B.7
0144E:  BCF    FF2.7
01450:  MOVLB  0
01452:  CALL   0146
01456:  BTFSC  1B.7
01458:  BSF    FF2.7
0145A:  BRA    1560
0145C:  MOVLB  1
....................       
....................    else
....................    {
....................       smf_queue.smf_data[smf_queue.smf_data_tail].dest = data->dest;
0145E:  MOVF   x0E,W
01460:  MULLW  0C
01462:  MOVF   FF3,W
01464:  CLRF   x75
01466:  MOVWF  x74
01468:  MOVLW  04
0146A:  ADDWF  x74,W
0146C:  MOVWF  01
0146E:  MOVLW  00
01470:  ADDWFC x75,W
01472:  MOVWF  03
01474:  MOVF   01,W
01476:  ADDLW  4D
01478:  MOVWF  01
0147A:  MOVLW  00
0147C:  ADDWFC 03,F
0147E:  MOVFF  01,174
01482:  MOVFF  03,175
01486:  MOVLW  04
01488:  ADDWF  x71,W
0148A:  MOVWF  FE9
0148C:  MOVLW  00
0148E:  ADDWFC x72,W
01490:  MOVWF  FEA
01492:  MOVFF  FEF,00
01496:  MOVFF  FEC,01
0149A:  MOVFF  FEC,02
0149E:  MOVFF  FEC,03
014A2:  MOVFF  175,FEA
014A6:  MOVFF  174,FE9
014AA:  MOVFF  00,FEF
014AE:  MOVFF  01,FEC
014B2:  MOVFF  02,FEC
014B6:  MOVFF  03,FEC
....................       smf_queue.smf_data[smf_queue.smf_data_tail].src = data->src;
014BA:  MOVF   x0E,W
014BC:  MULLW  0C
014BE:  MOVF   FF3,W
014C0:  CLRF   x75
014C2:  MOVWF  x74
014C4:  MOVLW  4D
014C6:  ADDWF  x74,W
014C8:  MOVWF  01
014CA:  MOVLW  00
014CC:  ADDWFC x75,W
014CE:  MOVFF  01,176
014D2:  MOVFF  171,FE9
014D6:  MOVFF  172,FEA
014DA:  MOVFF  FEF,00
014DE:  MOVFF  FEC,01
014E2:  MOVFF  FEC,02
014E6:  MOVFF  FEC,03
014EA:  MOVWF  FEA
014EC:  MOVFF  176,FE9
014F0:  MOVFF  00,FEF
014F4:  MOVFF  01,FEC
014F8:  MOVFF  02,FEC
014FC:  MOVFF  03,FEC
....................       smf_queue.smf_data[smf_queue.smf_data_tail].size = data->size;
01500:  MOVF   x0E,W
01502:  MULLW  0C
01504:  MOVF   FF3,W
01506:  CLRF   x75
01508:  MOVWF  x74
0150A:  MOVLW  08
0150C:  ADDWF  x74,W
0150E:  MOVWF  01
01510:  MOVLW  00
01512:  ADDWFC x75,W
01514:  MOVWF  03
01516:  MOVF   01,W
01518:  ADDLW  4D
0151A:  MOVWF  01
0151C:  MOVLW  00
0151E:  ADDWFC 03,F
01520:  MOVFF  01,174
01524:  MOVFF  03,175
01528:  MOVLW  08
0152A:  ADDWF  x71,W
0152C:  MOVWF  FE9
0152E:  MOVLW  00
01530:  ADDWFC x72,W
01532:  MOVWF  FEA
01534:  MOVFF  FEF,00
01538:  MOVFF  FEC,01
0153C:  MOVFF  FEC,02
01540:  MOVFF  FEC,03
01544:  MOVFF  175,FEA
01548:  MOVFF  174,FE9
0154C:  MOVFF  00,FEF
01550:  MOVFF  01,FEC
01554:  MOVFF  02,FEC
01558:  MOVFF  03,FEC
.................... 
....................       smf_queue.smf_data_tail = next_tail;
0155C:  MOVFF  173,10E
01560:  MOVLB  0
....................    }
01562:  GOTO   16F6 (RETURN)
.................... }
.................... 
.................... SmfDataStruct *dequeue_smf_data()
.................... {
....................    if (smf_queue.smf_data_head == smf_queue.smf_data_tail)
*
01D6E:  MOVLB  1
01D70:  MOVF   x0E,W
01D72:  SUBWF  x0D,W
01D74:  BNZ   1DA0
....................    {
....................       fprintf(PC, "SMF data list is empty\r\n");
01D76:  MOVLW  0A
01D78:  MOVWF  FF6
01D7A:  MOVLW  02
01D7C:  MOVWF  FF7
01D7E:  MOVLW  00
01D80:  MOVWF  FF8
01D82:  CLRF   1B
01D84:  BTFSC  FF2.7
01D86:  BSF    1B.7
01D88:  BCF    FF2.7
01D8A:  MOVLB  0
01D8C:  CALL   0146
01D90:  BTFSC  1B.7
01D92:  BSF    FF2.7
....................       return 0x00;
01D94:  MOVLW  00
01D96:  MOVWF  01
01D98:  MOVWF  02
01D9A:  BRA    1DC2
....................    }
01D9C:  BRA    1DC2
01D9E:  MOVLB  1
....................    else
....................    {
....................       int8 current_head = smf_queue.smf_data_head;
01DA0:  MOVFF  10D,150
....................       smf_queue.smf_data_head = (smf_queue.smf_data_head + 1) % SMF_DATA_SIZE;
01DA4:  MOVLW  01
01DA6:  ADDWF  x0D,W
01DA8:  ANDLW  0F
01DAA:  MOVWF  x0D
....................       return &smf_queue.smf_data[current_head];
01DAC:  MOVF   x50,W
01DAE:  MULLW  0C
01DB0:  MOVF   FF3,W
01DB2:  CLRF   03
01DB4:  ADDLW  4D
01DB6:  MOVWF  01
01DB8:  MOVLW  00
01DBA:  ADDWFC 03,F
01DBC:  MOVFF  03,02
01DC0:  MOVLB  0
....................    }
01DC2:  GOTO   1DD0 (RETURN)
.................... }
.................... 
.................... int1 is_empty_smf_data(void)
.................... {
....................    return smf_queue.smf_data_head == smf_queue.smf_data_tail;
*
01D5A:  MOVLB  1
01D5C:  MOVF   x0E,W
01D5E:  SUBWF  x0D,W
01D60:  BZ    1D66
01D62:  MOVLW  00
01D64:  BRA    1D68
01D66:  MOVLW  01
01D68:  MOVWF  01
01D6A:  MOVLB  0
01D6C:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "./lib/flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "./src/flash.c"
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////GDNS_226_FlashOperation.c////////////////////////////
.................... //////////////////////////////////ver 2.2//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////redefinition of spi communication///////////////////////
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3,write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM2);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM3);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
.................... }
.................... 
.................... int8 status_register(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
....................    #ifdef DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(DEBUG_PORT,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
.................... }
.................... 
.................... //
.................... //->success:True,fail:false
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 20);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(DEBUG_PORT,"%x ",chip_id[print_counter]);
....................       fprintf(DEBUG_PORT,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == 0x20){  
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef DEBUG
.................... //!      fprintf(DEBUG_PORT,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash sector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................    
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................    
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return;
.................... }
....................    
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "./lib/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ define ______________
.................... 
.................... #define MAIN_PIC  0x00
.................... #define COM_PIC   0x01
.................... #define RESET_PIC 0x02
.................... #define FAB_PIC   0x03
.................... #define BOSS_PIC  0x04
.................... #define APRS_PIC  0x05
.................... #define CAM_MCU   0x06
.................... #define CHO_MCU   0x07
.................... #define NAKA_PIC  0x08
.................... #define SATO_PIC  0x09
.................... #define BHU_MCU   0x0A
.................... #define CIGS_PIC  0x0B
.................... 
.................... #define SELF_DEVICE_ID APRS_PIC // <- change to your device name
.................... 
.................... 
.................... 
.................... #define SFD 0xAA
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... // __________ typedefs _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x01,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 32
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 content[CONTENT_MAX];
....................     int8 size;
....................     int1 is_exist;
.................... } Command;
.................... 
.................... // ____________ Receive Frame ID _________
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... #include "./src/communication.c"
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, {0x00}, 0, FALSE};
*
00E96:  MOVLB  1
00E98:  CLRF   xAD
00E9A:  CLRF   xAE
00E9C:  CLRF   xAF
00E9E:  CLRF   xB0
00EA0:  CLRF   xB1
00EA2:  CLRF   xB2
00EA4:  CLRF   xB3
00EA6:  CLRF   xB4
00EA8:  CLRF   xB5
00EAA:  CLRF   xB6
00EAC:  CLRF   xB7
00EAE:  CLRF   xB8
00EB0:  CLRF   xB9
00EB2:  CLRF   xBA
00EB4:  CLRF   xBB
00EB6:  CLRF   xBC
00EB8:  CLRF   xBD
00EBA:  CLRF   xBE
00EBC:  CLRF   xBF
00EBE:  CLRF   xC0
00EC0:  CLRF   xC1
00EC2:  CLRF   xC2
00EC4:  CLRF   xC3
00EC6:  CLRF   xC4
00EC8:  CLRF   xC5
00ECA:  CLRF   xC6
00ECC:  CLRF   xC7
00ECE:  CLRF   xC8
00ED0:  CLRF   xC9
00ED2:  CLRF   xCA
00ED4:  CLRF   xCB
00ED6:  CLRF   xCC
00ED8:  CLRF   xCD
00EDA:  CLRF   xCE
00EDC:  CLRF   xCF
....................    fprintf(PC, "Start make_receive_command\r\n\t-> ");
00EDE:  MOVLW  B4
00EE0:  MOVWF  FF6
00EE2:  MOVLW  03
00EE4:  MOVWF  FF7
00EE6:  MOVLW  00
00EE8:  MOVWF  FF8
00EEA:  CLRF   1B
00EEC:  BTFSC  FF2.7
00EEE:  BSF    1B.7
00EF0:  BCF    FF2.7
00EF2:  MOVLB  0
00EF4:  CALL   0146
00EF8:  BTFSC  1B.7
00EFA:  BSF    FF2.7
....................    for (int8 i = 0; i < receive_signal_size; i++)
00EFC:  MOVLB  1
00EFE:  CLRF   xD0
00F00:  MOVF   xAC,W
00F02:  SUBWF  xD0,W
00F04:  BC    0F2E
....................       fprintf(PC, "%X ", receive_signal[i]);
00F06:  MOVF   xD0,W
00F08:  ADDWF  xAA,W
00F0A:  MOVWF  FE9
00F0C:  MOVLW  00
00F0E:  ADDWFC xAB,W
00F10:  MOVWF  FEA
00F12:  MOVFF  FEF,1DC
00F16:  MOVLW  37
00F18:  MOVWF  xDD
00F1A:  MOVLB  0
00F1C:  RCALL  0B4C
00F1E:  MOVLW  20
00F20:  BTFSS  FA4.4
00F22:  BRA    0F20
00F24:  MOVLB  F
00F26:  MOVWF  x1D
00F28:  MOVLB  1
00F2A:  INCF   xD0,F
00F2C:  BRA    0F00
....................    fprintf(PC, "\r\n");
00F2E:  MOVLW  0D
00F30:  BTFSS  FA4.4
00F32:  BRA    0F30
00F34:  MOVLB  F
00F36:  MOVWF  x1D
00F38:  MOVLW  0A
00F3A:  BTFSS  FA4.4
00F3C:  BRA    0F3A
00F3E:  MOVWF  x1D
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
00F40:  MOVFF  1AB,1D8
00F44:  MOVFF  1AA,1D7
00F48:  MOVFF  1AC,1D9
00F4C:  MOVLB  0
00F4E:  BRA    0B98
00F50:  MOVFF  01,1D1
....................    if (frame_start_position == -1)
00F54:  MOVLB  1
00F56:  MOVF   xD1,W
00F58:  SUBLW  FF
00F5A:  BNZ   0F66
....................       return command;
00F5C:  MOVLW  AD
00F5E:  MOVWF  01
00F60:  MOVLW  01
00F62:  MOVWF  02
00F64:  BRA    106A
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
00F66:  MOVF   xD1,W
00F68:  ADDWF  xAA,W
00F6A:  MOVWF  01
00F6C:  MOVLW  00
00F6E:  ADDWFC xAB,W
00F70:  MOVWF  03
00F72:  MOVFF  01,1D2
00F76:  MOVWF  xD3
00F78:  MOVFF  1D2,FE9
00F7C:  MOVFF  1D3,FEA
00F80:  MOVF   FEF,W
00F82:  ANDLW  0F
00F84:  MOVWF  xD4
00F86:  MOVFF  1D4,1D7
00F8A:  MOVLB  0
00F8C:  BRA    0C5C
00F8E:  MOVFF  01,1D5
....................    if (content_size == -1)
00F92:  MOVLB  1
00F94:  MOVF   xD5,W
00F96:  SUBLW  FF
00F98:  BNZ   0FA4
....................       return command;
00F9A:  MOVLW  AD
00F9C:  MOVWF  01
00F9E:  MOVLW  01
00FA0:  MOVWF  02
00FA2:  BRA    106A
....................       
....................    int8 receive_frame_size = receive_signal_size - frame_start_position;
00FA4:  MOVF   xD1,W
00FA6:  SUBWF  xAC,W
00FA8:  MOVWF  xD6
....................    
....................    if (!check_crc(frame, receive_frame_size))
00FAA:  MOVFF  1D3,1D8
00FAE:  MOVFF  1D2,1D7
00FB2:  MOVFF  1D6,1D9
00FB6:  MOVLB  0
00FB8:  BRA    0D1E
00FBA:  MOVF   01,F
00FBC:  BNZ   0FCC
....................       return command;
00FBE:  MOVLW  AD
00FC0:  MOVWF  01
00FC2:  MOVLW  01
00FC4:  MOVWF  02
00FC6:  MOVLB  1
00FC8:  BRA    106A
00FCA:  MOVLB  0
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
00FCC:  MOVLB  1
00FCE:  MOVFF  1D2,FE9
00FD2:  MOVFF  1D3,FEA
00FD6:  MOVF   FEF,W
00FD8:  ANDLW  F0
00FDA:  MOVWF  00
00FDC:  SWAPF  00,W
00FDE:  MOVWF  xD7
00FE0:  MOVLW  0F
00FE2:  ANDWF  xD7,F
00FE4:  MOVFF  1D7,1D8
00FE8:  MOVLB  0
00FEA:  BRA    0DF0
00FEC:  MOVF   01,F
00FEE:  BNZ   0FFE
....................       return command;
00FF0:  MOVLW  AD
00FF2:  MOVWF  01
00FF4:  MOVLW  01
00FF6:  MOVWF  02
00FF8:  MOVLB  1
00FFA:  BRA    106A
00FFC:  MOVLB  0
.................... 
....................    command.frame_id = frame_id;
00FFE:  MOVFF  1D4,1AD
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
01002:  MOVLW  01
01004:  MOVLB  1
01006:  ADDWF  xD2,W
01008:  MOVWF  01
0100A:  MOVLW  00
0100C:  ADDWFC xD3,W
0100E:  MOVWF  03
01010:  MOVFF  01,1D7
01014:  MOVWF  xD8
01016:  MOVLW  02
01018:  SUBWF  xD6,W
0101A:  MOVWF  xD9
0101C:  MOVLW  01
0101E:  MOVWF  FEA
01020:  MOVLW  AE
01022:  MOVWF  FE9
01024:  MOVFF  03,FE2
01028:  MOVFF  01,FE1
0102C:  MOVF   xD9,W
0102E:  MOVWF  01
01030:  BZ    103A
01032:  MOVFF  FE6,FEE
01036:  DECFSZ 01,F
01038:  BRA    1032
....................    command.size = receive_frame_size-2;
0103A:  MOVLW  02
0103C:  SUBWF  xD6,W
0103E:  MOVWF  xCE
....................    command.is_exist = TRUE;
01040:  BSF    xCF.0
....................    fprintf(PC, "End make_recive_command\r\n");
01042:  MOVLW  D6
01044:  MOVWF  FF6
01046:  MOVLW  03
01048:  MOVWF  FF7
0104A:  MOVLW  00
0104C:  MOVWF  FF8
0104E:  CLRF   1B
01050:  BTFSC  FF2.7
01052:  BSF    1B.7
01054:  BCF    FF2.7
01056:  MOVLB  0
01058:  CALL   0146
0105C:  BTFSC  1B.7
0105E:  BSF    FF2.7
....................    return command;
01060:  MOVLW  AD
01062:  MOVWF  01
01064:  MOVLW  01
01066:  MOVWF  02
01068:  MOVLB  1
0106A:  MOVLB  0
0106C:  RETURN 0
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
00B98:  MOVLB  1
00B9A:  CLRF   xDA
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
00B9C:  CLRF   xDA
00B9E:  MOVLW  01
00BA0:  SUBWF  xD9,W
00BA2:  SUBWF  xDA,W
00BA4:  BC    0BC4
....................       if(receive_signal[i] == SFD)
00BA6:  MOVF   xDA,W
00BA8:  ADDWF  xD7,W
00BAA:  MOVWF  FE9
00BAC:  MOVLW  00
00BAE:  ADDWFC xD8,W
00BB0:  MOVWF  FEA
00BB2:  MOVF   FEF,W
00BB4:  SUBLW  AA
00BB6:  BNZ   0BC0
....................          return i+1;
00BB8:  MOVLW  01
00BBA:  ADDWF  xDA,W
00BBC:  MOVWF  01
00BBE:  BRA    0C22
00BC0:  INCF   xDA,F
00BC2:  BRA    0B9E
....................    if (receive_signal[i] == SFD)
00BC4:  MOVF   xDA,W
00BC6:  ADDWF  xD7,W
00BC8:  MOVWF  FE9
00BCA:  MOVLW  00
00BCC:  ADDWFC xD8,W
00BCE:  MOVWF  FEA
00BD0:  MOVF   FEF,W
00BD2:  SUBLW  AA
00BD4:  BNZ   0BFE
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
00BD6:  MOVLW  F0
00BD8:  MOVWF  FF6
00BDA:  MOVLW  03
00BDC:  MOVWF  FF7
00BDE:  MOVLW  00
00BE0:  MOVWF  FF8
00BE2:  CLRF   1B
00BE4:  BTFSC  FF2.7
00BE6:  BSF    1B.7
00BE8:  BCF    FF2.7
00BEA:  MOVLB  0
00BEC:  CALL   0146
00BF0:  BTFSC  1B.7
00BF2:  BSF    FF2.7
....................       return -1;
00BF4:  MOVLW  FF
00BF6:  MOVWF  01
00BF8:  MOVLB  1
00BFA:  BRA    0C22
....................    }
00BFC:  BRA    0C22
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
00BFE:  MOVLW  06
00C00:  MOVWF  FF6
00C02:  MOVLW  04
00C04:  MOVWF  FF7
00C06:  MOVLW  00
00C08:  MOVWF  FF8
00C0A:  CLRF   1B
00C0C:  BTFSC  FF2.7
00C0E:  BSF    1B.7
00C10:  BCF    FF2.7
00C12:  MOVLB  0
00C14:  CALL   0146
00C18:  BTFSC  1B.7
00C1A:  BSF    FF2.7
....................       return -1;
00C1C:  MOVLW  FF
00C1E:  MOVWF  01
00C20:  MOVLB  1
....................    }
00C22:  MOVLB  0
00C24:  GOTO   0F50 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
*
00C5C:  MOVLB  1
00C5E:  CLRF   xD8
00C60:  MOVF   xD8,W
00C62:  SUBLW  02
00C64:  BNC   0CAA
....................       if (frame_id == frame_ids[i].id)
00C66:  BCF    FD8.0
00C68:  RLCF   xD8,W
00C6A:  CLRF   xDA
00C6C:  MOVWF  xD9
00C6E:  MOVLW  17
00C70:  ADDWF  xD9,W
00C72:  MOVWF  FE9
00C74:  MOVLW  01
00C76:  ADDWFC xDA,W
00C78:  MOVWF  FEA
00C7A:  MOVF   FEF,W
00C7C:  SUBWF  xD7,W
00C7E:  BNZ   0CA6
....................          return frame_ids[i].length;
00C80:  BCF    FD8.0
00C82:  RLCF   xD8,W
00C84:  CLRF   xDA
00C86:  MOVWF  xD9
00C88:  MOVLW  01
00C8A:  ADDWF  xD9,W
00C8C:  MOVWF  01
00C8E:  MOVLW  00
00C90:  ADDWFC xDA,W
00C92:  MOVWF  03
00C94:  MOVF   01,W
00C96:  ADDLW  17
00C98:  MOVWF  FE9
00C9A:  MOVLW  01
00C9C:  ADDWFC 03,W
00C9E:  MOVWF  FEA
00CA0:  MOVFF  FEF,01
00CA4:  BRA    0CE4
00CA6:  INCF   xD8,F
00CA8:  BRA    0C60
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
00CAA:  MOVLW  18
00CAC:  MOVWF  FF6
00CAE:  MOVLW  04
00CB0:  MOVWF  FF7
00CB2:  MOVLW  00
00CB4:  MOVWF  FF8
00CB6:  MOVLW  1F
00CB8:  MOVWF  xDC
00CBA:  MOVLB  0
00CBC:  RCALL  0C28
00CBE:  MOVFF  1D7,1DC
00CC2:  MOVLW  37
00CC4:  MOVLB  1
00CC6:  MOVWF  xDD
00CC8:  MOVLB  0
00CCA:  RCALL  0B4C
00CCC:  MOVLW  0D
00CCE:  BTFSS  FA4.4
00CD0:  BRA    0CCE
00CD2:  MOVLB  F
00CD4:  MOVWF  x1D
00CD6:  MOVLW  0A
00CD8:  BTFSS  FA4.4
00CDA:  BRA    0CD8
00CDC:  MOVWF  x1D
....................    return -1;
00CDE:  MOVLW  FF
00CE0:  MOVWF  01
00CE2:  MOVLB  1
00CE4:  MOVLB  0
00CE6:  GOTO   0F8E (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
*
00D1E:  MOVLW  01
00D20:  MOVLB  1
00D22:  SUBWF  xD9,W
00D24:  ADDWF  xD7,W
00D26:  MOVWF  FE9
00D28:  MOVLW  00
00D2A:  ADDWFC xD8,W
00D2C:  MOVWF  FEA
00D2E:  MOVFF  FEF,1DA
00D32:  MOVLW  01
00D34:  SUBWF  xD9,W
00D36:  MOVWF  xDC
00D38:  MOVFF  1D8,1DE
00D3C:  MOVFF  1D7,1DD
00D40:  MOVWF  xDF
00D42:  MOVLB  0
00D44:  RCALL  0CEA
00D46:  MOVFF  01,1DB
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
00D4A:  MOVLB  1
00D4C:  MOVF   xDB,W
00D4E:  SUBWF  xDA,W
00D50:  BNZ   0D5A
....................       return TRUE;
00D52:  MOVLW  01
00D54:  MOVWF  01
00D56:  BRA    0DEA
00D58:  BRA    0DEA
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
00D5A:  MOVLW  3C
00D5C:  MOVWF  FF6
00D5E:  MOVLW  04
00D60:  MOVWF  FF7
00D62:  MOVLW  00
00D64:  MOVWF  FF8
00D66:  CLRF   1B
00D68:  BTFSC  FF2.7
00D6A:  BSF    1B.7
00D6C:  BCF    FF2.7
00D6E:  MOVLB  0
00D70:  CALL   0146
00D74:  BTFSC  1B.7
00D76:  BSF    FF2.7
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
00D78:  MOVLW  4E
00D7A:  MOVWF  FF6
00D7C:  MOVLW  04
00D7E:  MOVWF  FF7
00D80:  MOVLW  00
00D82:  MOVWF  FF8
00D84:  MOVLW  13
00D86:  MOVLB  1
00D88:  MOVWF  xDC
00D8A:  MOVLB  0
00D8C:  RCALL  0C28
00D8E:  MOVFF  1DA,1DC
00D92:  MOVLW  37
00D94:  MOVLB  1
00D96:  MOVWF  xDD
00D98:  MOVLB  0
00D9A:  RCALL  0B4C
00D9C:  MOVLW  0D
00D9E:  BTFSS  FA4.4
00DA0:  BRA    0D9E
00DA2:  MOVLB  F
00DA4:  MOVWF  x1D
00DA6:  MOVLW  0A
00DA8:  BTFSS  FA4.4
00DAA:  BRA    0DA8
00DAC:  MOVWF  x1D
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
00DAE:  MOVLW  66
00DB0:  MOVWF  FF6
00DB2:  MOVLW  04
00DB4:  MOVWF  FF7
00DB6:  MOVLW  00
00DB8:  MOVWF  FF8
00DBA:  MOVLW  13
00DBC:  MOVLB  1
00DBE:  MOVWF  xDC
00DC0:  MOVLB  0
00DC2:  RCALL  0C28
00DC4:  MOVFF  1DB,1DC
00DC8:  MOVLW  37
00DCA:  MOVLB  1
00DCC:  MOVWF  xDD
00DCE:  MOVLB  0
00DD0:  RCALL  0B4C
00DD2:  MOVLW  0D
00DD4:  BTFSS  FA4.4
00DD6:  BRA    0DD4
00DD8:  MOVLB  F
00DDA:  MOVWF  x1D
00DDC:  MOVLW  0A
00DDE:  BTFSS  FA4.4
00DE0:  BRA    0DDE
00DE2:  MOVWF  x1D
....................       return FALSE;
00DE4:  MOVLW  00
00DE6:  MOVWF  01
00DE8:  MOVLB  1
....................    }
00DEA:  MOVLB  0
00DEC:  GOTO   0FBA (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
00DF0:  MOVLB  1
00DF2:  MOVF   xD8,W
00DF4:  SUBLW  05
00DF6:  BNZ   0E00
....................       return TRUE;
00DF8:  MOVLW  01
00DFA:  MOVWF  01
00DFC:  BRA    0E90
00DFE:  BRA    0E90
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
00E00:  MOVLW  7E
00E02:  MOVWF  FF6
00E04:  MOVLW  04
00E06:  MOVWF  FF7
00E08:  MOVLW  00
00E0A:  MOVWF  FF8
00E0C:  CLRF   1B
00E0E:  BTFSC  FF2.7
00E10:  BSF    1B.7
00E12:  BCF    FF2.7
00E14:  MOVLB  0
00E16:  CALL   0146
00E1A:  BTFSC  1B.7
00E1C:  BSF    FF2.7
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
00E1E:  MOVLW  A0
00E20:  MOVWF  FF6
00E22:  MOVLW  04
00E24:  MOVWF  FF7
00E26:  MOVLW  00
00E28:  MOVWF  FF8
00E2A:  MOVLW  13
00E2C:  MOVLB  1
00E2E:  MOVWF  xDC
00E30:  MOVLB  0
00E32:  RCALL  0C28
00E34:  MOVFF  1D8,1DC
00E38:  MOVLW  37
00E3A:  MOVLB  1
00E3C:  MOVWF  xDD
00E3E:  MOVLB  0
00E40:  RCALL  0B4C
00E42:  MOVLW  0D
00E44:  BTFSS  FA4.4
00E46:  BRA    0E44
00E48:  MOVLB  F
00E4A:  MOVWF  x1D
00E4C:  MOVLW  0A
00E4E:  BTFSS  FA4.4
00E50:  BRA    0E4E
00E52:  MOVWF  x1D
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
00E54:  MOVLW  B8
00E56:  MOVWF  FF6
00E58:  MOVLW  04
00E5A:  MOVWF  FF7
00E5C:  MOVLW  00
00E5E:  MOVWF  FF8
00E60:  MOVLW  13
00E62:  MOVLB  1
00E64:  MOVWF  xDC
00E66:  MOVLB  0
00E68:  RCALL  0C28
00E6A:  MOVLW  05
00E6C:  MOVLB  1
00E6E:  MOVWF  xDC
00E70:  MOVLW  37
00E72:  MOVWF  xDD
00E74:  MOVLB  0
00E76:  RCALL  0B4C
00E78:  MOVLW  0D
00E7A:  BTFSS  FA4.4
00E7C:  BRA    0E7A
00E7E:  MOVLB  F
00E80:  MOVWF  x1D
00E82:  MOVLW  0A
00E84:  BTFSS  FA4.4
00E86:  BRA    0E84
00E88:  MOVWF  x1D
....................       return FALSE;  
00E8A:  MOVLW  00
00E8C:  MOVWF  01
00E8E:  MOVLB  1
....................    }
00E90:  MOVLB  0
00E92:  GOTO   0FEC (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
01178:  MOVLW  AA
0117A:  MOVLB  1
0117C:  MOVWF  xA8
....................    data[1] = (BOSS_PIC << 4) | frame_id;
0117E:  MOVF   xA4,W
01180:  IORLW  40
01182:  MOVWF  xA9
....................    memcpy(&data[2], content, size);
01184:  MOVLW  01
01186:  MOVWF  FEA
01188:  MOVLW  AA
0118A:  MOVWF  FE9
0118C:  MOVFF  1A6,FE2
01190:  MOVFF  1A5,FE1
01194:  MOVF   xA7,W
01196:  MOVWF  01
01198:  BZ    11A2
0119A:  MOVFF  FE6,FEE
0119E:  DECFSZ 01,F
011A0:  BRA    119A
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
011A2:  MOVLW  02
011A4:  ADDWF  xA7,W
011A6:  MOVWF  xB8
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
011A8:  CLRF   03
011AA:  MOVF   xB8,W
011AC:  ADDLW  A8
011AE:  MOVWF  01
011B0:  MOVLW  01
011B2:  ADDWFC 03,F
011B4:  MOVFF  01,1BA
011B8:  MOVFF  03,1BB
011BC:  MOVLW  01
011BE:  SUBWF  xB8,W
011C0:  MOVWF  xBC
011C2:  MOVLW  01
011C4:  MOVWF  xDE
011C6:  MOVLW  A9
011C8:  MOVWF  xDD
011CA:  MOVFF  1BC,1DF
011CE:  MOVLB  0
011D0:  RCALL  0CEA
011D2:  MOVFF  1BB,FEA
011D6:  MOVFF  1BA,FE9
011DA:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
011DE:  MOVLW  01
011E0:  MOVLB  1
011E2:  ADDWF  xB8,W
011E4:  MOVWF  xB9
....................    
....................    transmit(data, data_size);
011E6:  MOVLW  01
011E8:  MOVWF  xBB
011EA:  MOVLW  A8
011EC:  MOVWF  xBA
011EE:  MOVFF  1B9,1BC
011F2:  MOVLB  0
011F4:  BRA    10EA
011F6:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
010EA:  MOVLB  1
010EC:  CLRF   xBD
010EE:  MOVF   xBC,W
010F0:  SUBWF  xBD,W
010F2:  BC    1110
....................       fputc(data[i], BOSS);
010F4:  MOVF   xBD,W
010F6:  ADDWF  xBA,W
010F8:  MOVWF  FE9
010FA:  MOVLW  00
010FC:  ADDWFC xBB,W
010FE:  MOVWF  FEA
01100:  MOVFF  FEF,1BF
01104:  MOVF   xBF,W
01106:  MOVLB  0
01108:  BRA    10E0
0110A:  MOVLB  1
0110C:  INCF   xBD,F
0110E:  BRA    10EE
....................       
....................    fprintf(PC, "Transit command\r\n\t-> ");
01110:  MOVLW  D0
01112:  MOVWF  FF6
01114:  MOVLW  04
01116:  MOVWF  FF7
01118:  MOVLW  00
0111A:  MOVWF  FF8
0111C:  CLRF   1B
0111E:  BTFSC  FF2.7
01120:  BSF    1B.7
01122:  BCF    FF2.7
01124:  MOVLB  0
01126:  CALL   0146
0112A:  BTFSC  1B.7
0112C:  BSF    FF2.7
....................    for(int i = 0; i < data_size; i++)
0112E:  MOVLB  1
01130:  CLRF   xBE
01132:  MOVF   xBC,W
01134:  SUBWF  xBE,W
01136:  BC    1160
....................       fprintf(PC, "%X ", data[i]);
01138:  MOVF   xBE,W
0113A:  ADDWF  xBA,W
0113C:  MOVWF  FE9
0113E:  MOVLW  00
01140:  ADDWFC xBB,W
01142:  MOVWF  FEA
01144:  MOVFF  FEF,1DC
01148:  MOVLW  37
0114A:  MOVWF  xDD
0114C:  MOVLB  0
0114E:  RCALL  0B4C
01150:  MOVLW  20
01152:  BTFSS  FA4.4
01154:  BRA    1152
01156:  MOVLB  F
01158:  MOVWF  x1D
0115A:  MOVLB  1
0115C:  INCF   xBE,F
0115E:  BRA    1132
....................    fprintf(PC, "\r\n");
01160:  MOVLW  0D
01162:  BTFSS  FA4.4
01164:  BRA    1162
01166:  MOVLB  F
01168:  MOVWF  x1D
0116A:  MOVLW  0A
0116C:  BTFSS  FA4.4
0116E:  BRA    116C
01170:  MOVWF  x1D
01172:  MOVLB  0
01174:  GOTO   11F6 (RETURN)
.................... }
.................... 
.................... 
.................... // ______ Common _______
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size)
*
00CEA:  MOVLB  1
00CEC:  MOVFF  1DD,FE9
00CF0:  MOVFF  1DE,FEA
00CF4:  MOVFF  FEF,1E0
00CF8:  MOVLW  01
00CFA:  MOVWF  xE1
.................... {
....................    unsigned int8 crc = frame[0], i = 1;
....................    while(i < payload_size)
00CFC:  MOVF   xDF,W
00CFE:  SUBWF  xE1,W
00D00:  BC    0D16
....................       crc ^= frame[i++];
00D02:  MOVF   xE1,W
00D04:  INCF   xE1,F
00D06:  ADDWF  xDD,W
00D08:  MOVWF  FE9
00D0A:  MOVLW  00
00D0C:  ADDWFC xDE,W
00D0E:  MOVWF  FEA
00D10:  MOVF   FEF,W
00D12:  XORWF  xE0,F
00D14:  BRA    0CFC
....................    return crc;
00D16:  MOVFF  1E0,01
00D1A:  MOVLB  0
00D1C:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    return make_receive_command(receive_signal, receive_signal_size);
*
0106E:  MOVFF  153,1AB
01072:  MOVFF  152,1AA
01076:  MOVFF  154,1AC
0107A:  RCALL  0E96
0107C:  MOVFF  02,03
01080:  MOVFF  01,FE9
01084:  MOVFF  02,FEA
01088:  MOVLW  EF
0108A:  MOVWF  01
0108C:  MOVLW  0F
0108E:  MOVWF  02
01090:  GOTO   243A (RETURN)
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
011F8:  MOVLW  0F
011FA:  MOVLB  1
011FC:  MOVWF  xA4
011FE:  CLRF   xA6
01200:  CLRF   xA5
01202:  CLRF   xA7
01204:  MOVLB  0
01206:  RCALL  1178
01208:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 1);
*
0182E:  MOVLW  01
01830:  MOVLB  1
01832:  MOVWF  xA4
01834:  CLRF   xA6
01836:  MOVLW  1F
01838:  MOVWF  xA5
0183A:  MOVLW  01
0183C:  MOVWF  xA7
0183E:  MOVLB  0
01840:  RCALL  1178
01842:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // _____________ define _______________
.................... 
.................... #define EXECUTED_MISSION_SIZE 8
.................... 
.................... 
.................... // _____________ typedef ________________
.................... 
.................... typedef struct {
....................    unsigned int8 executed_mission[EXECUTED_MISSION_SIZE];
....................    int8 executed_mission_count;
.................... } ExecutedMission;
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Value management using the Singleton pattern
.................... ExecutedMission get_executed_mission();
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id);
.................... 
.................... void add_executed_mission(unsigned int8 command_id);
.................... 
.................... // Use in missions you want to execute consecutively
.................... void executed_mission_pop(void);
.................... 
.................... 
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // MIS MCU will be up and running duration_second seconds after mission completion
.................... void continue_mis_mcu(int16 duration_second);
.................... 
.................... 
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... 
.................... 
.................... #include "./src/mission_tools.c"
.................... ExecutedMission get_executed_mission()
.................... {
....................    static ExecutedMission executed_mission = {0};
....................    return executed_mission;
*
0120A:  MOVLW  1D
0120C:  MOVWF  01
0120E:  MOVLW  01
01210:  MOVWF  02
01212:  RETURN 0
.................... }
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id)
01214:  RCALL  120A
01216:  MOVFF  02,03
0121A:  MOVFF  01,FE1
0121E:  MOVFF  02,FE2
01222:  MOVLW  01
01224:  MOVWF  FEA
01226:  MOVLW  56
01228:  MOVWF  FE9
0122A:  MOVLW  09
0122C:  MOVWF  01
0122E:  MOVFF  FE6,FEE
01232:  DECFSZ 01,F
01234:  BRA    122E
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    for (int i = 0; i < executed_mission.executed_mission_count; i++)
01236:  MOVLB  1
01238:  CLRF   x5F
0123A:  MOVF   x5E,W
0123C:  SUBWF  x5F,W
0123E:  BC    125E
....................       if (command_id == executed_mission.executed_mission[i])
01240:  CLRF   03
01242:  MOVF   x5F,W
01244:  ADDLW  56
01246:  MOVWF  FE9
01248:  MOVLW  01
0124A:  ADDWFC 03,W
0124C:  MOVWF  FEA
0124E:  MOVF   FEF,W
01250:  SUBWF  x55,W
01252:  BNZ   125A
....................          return TRUE;
01254:  MOVLW  01
01256:  MOVWF  01
01258:  BRA    1262
0125A:  INCF   x5F,F
0125C:  BRA    123A
....................       
....................    return FALSE;
0125E:  MOVLW  00
01260:  MOVWF  01
01262:  MOVLB  0
01264:  GOTO   1C3C (RETURN)
.................... }
.................... 
.................... void add_executed_mission(unsigned int8 command_id)
*
01360:  RCALL  120A
01362:  MOVFF  02,03
01366:  MOVFF  01,FE1
0136A:  MOVFF  02,FE2
0136E:  MOVLW  01
01370:  MOVWF  FEA
01372:  MOVLW  56
01374:  MOVWF  FE9
01376:  MOVLW  09
01378:  MOVWF  01
0137A:  MOVFF  FE6,FEE
0137E:  DECFSZ 01,F
01380:  BRA    137A
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    if (executed_mission.executed_mission_count != EXECUTED_MISSION_SIZE)
01382:  MOVLB  1
01384:  MOVF   x5E,W
01386:  SUBLW  08
01388:  BZ    13A0
....................       executed_mission.executed_mission[executed_mission.executed_mission_count++] = command_id;
0138A:  MOVF   x5E,W
0138C:  INCF   x5E,F
0138E:  CLRF   03
01390:  ADDLW  56
01392:  MOVWF  FE9
01394:  MOVLW  01
01396:  ADDWFC 03,W
01398:  MOVWF  FEA
0139A:  MOVFF  155,FEF
0139E:  BRA    13C0
....................    else
....................       fprintf(PC, "!!!overflow executed_mission list\r\n");
013A0:  MOVLW  E6
013A2:  MOVWF  FF6
013A4:  MOVLW  04
013A6:  MOVWF  FF7
013A8:  MOVLW  00
013AA:  MOVWF  FF8
013AC:  CLRF   1B
013AE:  BTFSC  FF2.7
013B0:  BSF    1B.7
013B2:  BCF    FF2.7
013B4:  MOVLB  0
013B6:  CALL   0146
013BA:  BTFSC  1B.7
013BC:  BSF    FF2.7
013BE:  MOVLB  1
013C0:  MOVLB  0
013C2:  GOTO   1C86 (RETURN)
.................... }
.................... 
.................... 
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
*
01844:  MOVLW  0A
01846:  MOVWF  FF6
01848:  MOVLW  05
0184A:  MOVWF  FF7
0184C:  MOVLW  00
0184E:  MOVWF  FF8
01850:  CLRF   1B
01852:  BTFSC  FF2.7
01854:  BSF    1B.7
01856:  BCF    FF2.7
01858:  CALL   0146
0185C:  BTFSC  1B.7
0185E:  BSF    FF2.7
....................    status = SMF_USE_REQ;
01860:  MOVLW  04
01862:  MOVWF  1F
....................    is_use_smf_req_in_mission = TRUE;
01864:  BSF    1E.0
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
01866:  MOVLB  1
01868:  CLRF   x5B
0186A:  CLRF   x5A
0186C:  MOVF   x5B,W
0186E:  SUBLW  04
01870:  BNC   190C
01872:  BNZ   187A
01874:  MOVF   x5A,W
01876:  SUBLW  AF
01878:  BNC   190C
....................       {
....................          if (boss_receive_buffer_size > 0)
0187A:  MOVF   4A,F
0187C:  BZ    18F2
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
0187E:  CLRF   xAB
01880:  MOVLW  2A
01882:  MOVWF  xAA
01884:  MOVFF  4A,1AC
01888:  MOVLB  0
0188A:  CALL   0E96
0188E:  MOVFF  02,03
01892:  MOVFF  01,FE1
01896:  MOVFF  02,FE2
0189A:  MOVLW  01
0189C:  MOVWF  FEA
0189E:  MOVLW  5C
018A0:  MOVWF  FE9
018A2:  MOVLW  23
018A4:  MOVWF  01
018A6:  MOVFF  FE6,FEE
018AA:  DECFSZ 01,F
018AC:  BRA    18A6
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
018AE:  MOVLB  1
018B0:  CLRF   xA5
018B2:  MOVLW  2A
018B4:  MOVWF  xA4
018B6:  CLRF   xA7
018B8:  MOVLW  4A
018BA:  MOVWF  xA6
018BC:  MOVLB  0
018BE:  CALL   10B0
....................             if (command.frame_id == STATUS_CHECK)
018C2:  MOVLB  1
018C4:  DECFSZ x5C,W
018C6:  BRA    18D2
....................             {
....................                transmit_status();
018C8:  MOVLB  0
018CA:  RCALL  182E
....................                break;
018CC:  MOVLB  1
018CE:  BRA    190C
....................             }
018D0:  BRA    18F2
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
018D2:  MOVLW  2E
018D4:  MOVWF  FF6
018D6:  MOVLW  05
018D8:  MOVWF  FF7
018DA:  MOVLW  00
018DC:  MOVWF  FF8
018DE:  CLRF   1B
018E0:  BTFSC  FF2.7
018E2:  BSF    1B.7
018E4:  BCF    FF2.7
018E6:  MOVLB  0
018E8:  CALL   0146
018EC:  BTFSC  1B.7
018EE:  BSF    FF2.7
018F0:  MOVLB  1
....................             }
....................          }
....................          delay_ms(500);
018F2:  MOVLW  02
018F4:  MOVWF  xA4
018F6:  MOVLW  FA
018F8:  MOVWF  xA5
018FA:  MOVLB  0
018FC:  RCALL  1402
018FE:  MOVLB  1
01900:  DECFSZ xA4,F
01902:  BRA    18F6
01904:  INCF   x5A,F
01906:  BTFSC  FD8.2
01908:  INCF   x5B,F
0190A:  BRA    186C
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
0190C:  CLRF   x80
0190E:  CLRF   x7F
01910:  MOVF   x80,W
01912:  SUBLW  04
01914:  BTFSS  FD8.0
01916:  BRA    1A1C
01918:  BNZ   1922
0191A:  MOVF   x7F,W
0191C:  SUBLW  AF
0191E:  BTFSS  FD8.0
01920:  BRA    1A1C
....................       {
....................          if (boss_receive_buffer_size > 0)
01922:  MOVF   4A,F
01924:  BZ    1A02
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
01926:  CLRF   xAB
01928:  MOVLW  2A
0192A:  MOVWF  xAA
0192C:  MOVFF  4A,1AC
01930:  MOVLB  0
01932:  CALL   0E96
01936:  MOVFF  02,03
0193A:  MOVFF  01,FE1
0193E:  MOVFF  02,FE2
01942:  MOVLW  01
01944:  MOVWF  FEA
01946:  MOVLW  81
01948:  MOVWF  FE9
0194A:  MOVLW  23
0194C:  MOVWF  01
0194E:  MOVFF  FE6,FEE
01952:  DECFSZ 01,F
01954:  BRA    194E
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
01956:  MOVLB  1
01958:  CLRF   xA5
0195A:  MOVLW  2A
0195C:  MOVWF  xA4
0195E:  CLRF   xA7
01960:  MOVLW  4A
01962:  MOVWF  xA6
01964:  MOVLB  0
01966:  CALL   10B0
....................             if (command.frame_id == IS_SMF_AVAILABLE)
0196A:  MOVLB  1
0196C:  MOVF   x81,W
0196E:  SUBLW  02
01970:  BNZ   19E2
....................             {
....................                if (command.content[0] == ALLOW)
01972:  MOVF   x82,F
01974:  BNZ   199C
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
01976:  MOVLW  66
01978:  MOVWF  FF6
0197A:  MOVLW  05
0197C:  MOVWF  FF7
0197E:  MOVLW  00
01980:  MOVWF  FF8
01982:  CLRF   1B
01984:  BTFSC  FF2.7
01986:  BSF    1B.7
01988:  BCF    FF2.7
0198A:  MOVLB  0
0198C:  CALL   0146
01990:  BTFSC  1B.7
01992:  BSF    FF2.7
....................                   transmit_ack();
01994:  RCALL  11F8
....................                   goto NEXT;
01996:  BRA    1A20
....................                }
01998:  BRA    19DE
0199A:  MOVLB  1
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
0199C:  MOVLW  80
0199E:  MOVWF  FF6
019A0:  MOVLW  05
019A2:  MOVWF  FF7
019A4:  MOVLW  00
019A6:  MOVWF  FF8
019A8:  CLRF   1B
019AA:  BTFSC  FF2.7
019AC:  BSF    1B.7
019AE:  BCF    FF2.7
019B0:  MOVLB  0
019B2:  CALL   0146
019B6:  BTFSC  1B.7
019B8:  BSF    FF2.7
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
019BA:  MOVLW  9A
019BC:  MOVWF  FF6
019BE:  MOVLW  05
019C0:  MOVWF  FF7
019C2:  MOVLW  00
019C4:  MOVWF  FF8
019C6:  CLRF   1B
019C8:  BTFSC  FF2.7
019CA:  BSF    1B.7
019CC:  BCF    FF2.7
019CE:  CALL   0146
019D2:  BTFSC  1B.7
019D4:  BSF    FF2.7
....................                   transmit_ack();
019D6:  RCALL  11F8
....................                   break;
019D8:  MOVLB  1
019DA:  BRA    1A1C
019DC:  MOVLB  0
....................                }
....................             }
019DE:  BRA    1A00
019E0:  MOVLB  1
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
019E2:  MOVLW  B6
019E4:  MOVWF  FF6
019E6:  MOVLW  05
019E8:  MOVWF  FF7
019EA:  MOVLW  00
019EC:  MOVWF  FF8
019EE:  CLRF   1B
019F0:  BTFSC  FF2.7
019F2:  BSF    1B.7
019F4:  BCF    FF2.7
019F6:  MOVLB  0
019F8:  CALL   0146
019FC:  BTFSC  1B.7
019FE:  BSF    FF2.7
01A00:  MOVLB  1
....................             }
....................          }
....................          delay_ms(500);
01A02:  MOVLW  02
01A04:  MOVWF  xA4
01A06:  MOVLW  FA
01A08:  MOVWF  xA5
01A0A:  MOVLB  0
01A0C:  RCALL  1402
01A0E:  MOVLB  1
01A10:  DECFSZ xA4,F
01A12:  BRA    1A06
01A14:  INCF   x7F,F
01A16:  BTFSC  FD8.2
01A18:  INCF   x80,F
01A1A:  BRA    1910
....................       }
01A1C:  BRA    1868
01A1E:  MOVLB  0
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
01A20:  BCF    1E.0
....................    status = COPYING;
01A22:  MOVLW  05
01A24:  MOVWF  1F
....................    return TRUE;
01A26:  MOVLW  01
01A28:  MOVWF  01
01A2A:  BRA    1A4A
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
01A2C:  MOVLW  EE
01A2E:  MOVWF  FF6
01A30:  MOVLW  05
01A32:  MOVWF  FF7
01A34:  MOVLW  00
01A36:  MOVWF  FF8
01A38:  CLRF   1B
01A3A:  BTFSC  FF2.7
01A3C:  BSF    1B.7
01A3E:  BCF    FF2.7
01A40:  MOVLB  0
01A42:  CALL   0146
01A46:  BTFSC  1B.7
01A48:  BSF    FF2.7
01A4A:  MOVLB  0
01A4C:  GOTO   1B06 (RETURN)
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status = EXECUTING_MISSION;
01A50:  MOVLW  02
01A52:  MOVWF  1F
01A54:  GOTO   1B84 (RETURN)
.................... }
.................... 
.................... void executed_mission_pop(void)
*
013C6:  RCALL  120A
013C8:  MOVFF  02,03
013CC:  MOVFF  01,FE1
013D0:  MOVFF  02,FE2
013D4:  MOVLW  01
013D6:  MOVWF  FEA
013D8:  MOVLW  71
013DA:  MOVWF  FE9
013DC:  MOVLW  09
013DE:  MOVWF  01
013E0:  MOVFF  FE6,FEE
013E4:  DECFSZ 01,F
013E6:  BRA    13E0
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    executed_mission.executed_mission[executed_mission.executed_mission_count--] = 0x00;
013E8:  MOVLB  1
013EA:  MOVF   x79,W
013EC:  DECF   x79,F
013EE:  CLRF   03
013F0:  ADDLW  71
013F2:  MOVWF  FE9
013F4:  MOVLW  01
013F6:  ADDWFC 03,W
013F8:  MOVWF  FEA
013FA:  CLRF   FEF
013FC:  MOVLB  0
013FE:  GOTO   15E8 (RETURN)
.................... }
.................... 
.................... void continue_mis_mcu(int16 duration_second)
.................... {  
....................    duration_sec = duration_second + sec;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
*
01A58:  BTFSS  F9E.5
01A5A:  BRA    1A64
....................    {
....................       fgetc(BOSS);
01A5C:  BTFSS  F9E.5
01A5E:  BRA    1A5C
01A60:  MOVF   FAE,W
....................       transmit_status();
01A62:  RCALL  182E
....................    }
01A64:  GOTO   1BAE (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // fundamental fnction
.................... void execute_mission(unsigned int8 *content);
.................... 
.................... // missions
.................... void example_00(unsigned int8 parameter[]);
.................... void example_01(unsigned int8 parameter[]);
.................... void example_02(unsigned int8 parameter[]);
.................... 
.................... #include "./mission.c"
.................... //____________ main mission function _______________
.................... 
.................... void execute_mission(unsigned int8 *content)
*
01C14:  MOVLB  1
01C16:  MOVFF  150,FE9
01C1A:  MOVFF  151,FEA
01C1E:  MOVFF  FEF,152
01C22:  MOVLW  01
01C24:  ADDWF  x50,W
01C26:  MOVWF  01
01C28:  MOVLW  00
01C2A:  ADDWFC x51,W
01C2C:  MOVFF  01,153
01C30:  MOVWF  x54
.................... {
....................    // record to executed mission list
....................    unsigned int8 command_id = content[0];
....................    unsigned int8 *parameter = &content[1];
....................    
....................    if (is_executed_mission(command_id))
01C32:  MOVFF  152,155
01C36:  MOVLB  0
01C38:  GOTO   1214
01C3C:  MOVF   01,F
01C3E:  BZ    1C7E
....................    {
....................       fprintf(PC, "\r\nThis  mission is executed\r\n\t-> 0x%d\r\n", command_id);
01C40:  MOVLW  10
01C42:  MOVWF  FF6
01C44:  MOVLW  06
01C46:  MOVWF  FF7
01C48:  MOVLW  00
01C4A:  MOVWF  FF8
01C4C:  MOVLW  23
01C4E:  MOVLB  1
01C50:  MOVWF  xDC
01C52:  MOVLB  0
01C54:  CALL   0C28
01C58:  MOVFF  152,155
01C5C:  MOVLW  18
01C5E:  MOVLB  1
01C60:  MOVWF  x56
01C62:  MOVLB  0
01C64:  CALL   1294
01C68:  MOVLW  0D
01C6A:  BTFSS  FA4.4
01C6C:  BRA    1C6A
01C6E:  MOVLB  F
01C70:  MOVWF  x1D
01C72:  MOVLW  0A
01C74:  BTFSS  FA4.4
01C76:  BRA    1C74
01C78:  MOVWF  x1D
....................       return;
01C7A:  BRA    1D54
01C7C:  MOVLB  0
....................    }
....................    
....................    add_executed_mission(command_id);
01C7E:  MOVFF  152,155
01C82:  GOTO   1360
....................    
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
01C86:  MOVLW  38
01C88:  MOVWF  FF6
01C8A:  MOVLW  06
01C8C:  MOVWF  FF7
01C8E:  MOVLW  00
01C90:  MOVWF  FF8
01C92:  CLRF   1B
01C94:  BTFSC  FF2.7
01C96:  BSF    1B.7
01C98:  BCF    FF2.7
01C9A:  CALL   0146
01C9E:  BTFSC  1B.7
01CA0:  BSF    FF2.7
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
01CA2:  MOVLW  7E
01CA4:  MOVWF  FF6
01CA6:  MOVLW  06
01CA8:  MOVWF  FF7
01CAA:  MOVLW  00
01CAC:  MOVWF  FF8
01CAE:  MOVLW  0C
01CB0:  MOVLB  1
01CB2:  MOVWF  xDC
01CB4:  MOVLB  0
01CB6:  CALL   0C28
01CBA:  MOVFF  152,1DC
01CBE:  MOVLW  37
01CC0:  MOVLB  1
01CC2:  MOVWF  xDD
01CC4:  MOVLB  0
01CC6:  CALL   0B4C
01CCA:  MOVLW  8C
01CCC:  MOVWF  FF6
01CCE:  MOVLW  06
01CD0:  MOVWF  FF7
01CD2:  MOVLW  00
01CD4:  MOVWF  FF8
01CD6:  MOVLW  04
01CD8:  MOVLB  1
01CDA:  MOVWF  xDC
01CDC:  MOVLB  0
01CDE:  CALL   0C28
....................    switch(command_id)
01CE2:  MOVLB  1
01CE4:  MOVF   x52,W
01CE6:  XORLW  00
01CE8:  MOVLB  0
01CEA:  BZ    1CF6
01CEC:  XORLW  01
01CEE:  BZ    1D02
01CF0:  XORLW  03
01CF2:  BZ    1D0E
01CF4:  BRA    1D1A
....................    {
....................       case 0x00:
....................          example_00(parameter);
01CF6:  MOVFF  154,156
01CFA:  MOVFF  153,155
01CFE:  BRA    1566
....................          break;
01D00:  BRA    1D36
....................       case 0x01:
....................          example_01(parameter);
01D02:  MOVFF  154,156
01D06:  MOVFF  153,155
01D0A:  BRA    1716
....................          break;
01D0C:  BRA    1D36
....................       case 0x02:
....................          example_02(parameter);
01D0E:  MOVFF  154,156
01D12:  MOVFF  153,155
01D16:  BRA    1A68
....................          break;
01D18:  BRA    1D36
....................          
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
01D1A:  MOVLW  92
01D1C:  MOVWF  FF6
01D1E:  MOVLW  06
01D20:  MOVWF  FF7
01D22:  MOVLW  00
01D24:  MOVWF  FF8
01D26:  CLRF   1B
01D28:  BTFSC  FF2.7
01D2A:  BSF    1B.7
01D2C:  BCF    FF2.7
01D2E:  CALL   0146
01D32:  BTFSC  1B.7
01D34:  BSF    FF2.7
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
01D36:  MOVLW  AA
01D38:  MOVWF  FF6
01D3A:  MOVLW  06
01D3C:  MOVWF  FF7
01D3E:  MOVLW  00
01D40:  MOVWF  FF8
01D42:  CLRF   1B
01D44:  BTFSC  FF2.7
01D46:  BSF    1B.7
01D48:  BCF    FF2.7
01D4A:  CALL   0146
01D4E:  BTFSC  1B.7
01D50:  BSF    FF2.7
01D52:  MOVLB  F
01D54:  MOVLB  0
01D56:  GOTO   20EA (RETURN)
.................... }
.................... 
.................... // _________________ missions ______________________
.................... 
.................... void example_00(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_00\r\n");
*
01566:  MOVLW  F0
01568:  MOVWF  FF6
0156A:  MOVLW  06
0156C:  MOVWF  FF7
0156E:  MOVLW  00
01570:  MOVWF  FF8
01572:  CLRF   1B
01574:  BTFSC  FF2.7
01576:  BSF    1B.7
01578:  BCF    FF2.7
0157A:  CALL   0146
0157E:  BTFSC  1B.7
01580:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
01582:  MOVLW  04
01584:  MOVWF  FF6
01586:  MOVLW  07
01588:  MOVWF  FF7
0158A:  MOVLW  00
0158C:  MOVWF  FF8
0158E:  CLRF   1B
01590:  BTFSC  FF2.7
01592:  BSF    1B.7
01594:  BCF    FF2.7
01596:  CALL   0146
0159A:  BTFSC  1B.7
0159C:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
0159E:  MOVLB  1
015A0:  CLRF   x57
015A2:  MOVF   x57,W
015A4:  SUBLW  07
015A6:  BNC   15D2
....................       fprintf(PC, "%X ", parameter[i]);
015A8:  MOVF   x57,W
015AA:  ADDWF  x55,W
015AC:  MOVWF  FE9
015AE:  MOVLW  00
015B0:  ADDWFC x56,W
015B2:  MOVWF  FEA
015B4:  MOVFF  FEF,1DC
015B8:  MOVLW  37
015BA:  MOVWF  xDD
015BC:  MOVLB  0
015BE:  CALL   0B4C
015C2:  MOVLW  20
015C4:  BTFSS  FA4.4
015C6:  BRA    15C4
015C8:  MOVLB  F
015CA:  MOVWF  x1D
015CC:  MOVLB  1
015CE:  INCF   x57,F
015D0:  BRA    15A2
....................    fprintf(PC, "\r\n");
015D2:  MOVLW  0D
015D4:  BTFSS  FA4.4
015D6:  BRA    15D4
015D8:  MOVLB  F
015DA:  MOVWF  x1D
015DC:  MOVLW  0A
015DE:  BTFSS  FA4.4
015E0:  BRA    15DE
015E2:  MOVWF  x1D
....................    
....................    // accept continuous execute
....................    executed_mission_pop();
015E4:  MOVLB  0
015E6:  BRA    13C6
....................    fprintf(PC, "(This mission can execute many time as you want)\r\n");
015E8:  MOVLW  12
015EA:  MOVWF  FF6
015EC:  MOVLW  07
015EE:  MOVWF  FF7
015F0:  MOVLW  00
015F2:  MOVWF  FF8
015F4:  CLRF   1B
015F6:  BTFSC  FF2.7
015F8:  BSF    1B.7
015FA:  BCF    FF2.7
015FC:  CALL   0146
01600:  BTFSC  1B.7
01602:  BSF    FF2.7
....................     
....................    // anything do
....................    fprintf(PC, "executing");
01604:  MOVLW  46
01606:  MOVWF  FF6
01608:  MOVLW  07
0160A:  MOVWF  FF7
0160C:  MOVLW  00
0160E:  MOVWF  FF8
01610:  CLRF   1B
01612:  BTFSC  FF2.7
01614:  BSF    1B.7
01616:  BCF    FF2.7
01618:  CALL   0146
0161C:  BTFSC  1B.7
0161E:  BSF    FF2.7
....................    delay_ms(1000);
01620:  MOVLW  04
01622:  MOVLB  1
01624:  MOVWF  x71
01626:  MOVLW  FA
01628:  MOVWF  xA5
0162A:  MOVLB  0
0162C:  RCALL  1402
0162E:  MOVLB  1
01630:  DECFSZ x71,F
01632:  BRA    1626
....................    for (int8 i = 0; i < 5; i++)
01634:  CLRF   x58
01636:  MOVF   x58,W
01638:  SUBLW  04
0163A:  BNC   165E
....................    {
....................       fprintf(PC, ".");
0163C:  MOVLW  2E
0163E:  BTFSS  FA4.4
01640:  BRA    163E
01642:  MOVLB  F
01644:  MOVWF  x1D
....................       delay_ms(1000);
01646:  MOVLW  04
01648:  MOVLB  1
0164A:  MOVWF  x71
0164C:  MOVLW  FA
0164E:  MOVWF  xA5
01650:  MOVLB  0
01652:  RCALL  1402
01654:  MOVLB  1
01656:  DECFSZ x71,F
01658:  BRA    164C
0165A:  INCF   x58,F
0165C:  BRA    1636
....................    }
....................    fprintf(PC, ".\r\n");
0165E:  MOVLW  50
01660:  MOVWF  FF6
01662:  MOVLW  07
01664:  MOVWF  FF7
01666:  MOVLW  00
01668:  MOVWF  FF8
0166A:  CLRF   1B
0166C:  BTFSC  FF2.7
0166E:  BSF    1B.7
01670:  BCF    FF2.7
01672:  MOVLB  0
01674:  CALL   0146
01678:  BTFSC  1B.7
0167A:  BSF    FF2.7
....................    
....................    // order Copy to SMF data
....................    fprintf(PC, "order Copy smf_data\r\n");
0167C:  MOVLW  54
0167E:  MOVWF  FF6
01680:  MOVLW  07
01682:  MOVWF  FF7
01684:  MOVLW  00
01686:  MOVWF  FF8
01688:  CLRF   1B
0168A:  BTFSC  FF2.7
0168C:  BSF    1B.7
0168E:  BCF    FF2.7
01690:  CALL   0146
01694:  BTFSC  1B.7
01696:  BSF    FF2.7
....................    unsigned int32 smf_data_destination_address = 0x00103D00; // (in SMF)
....................    unsigned int32 fm_data_source_address = 0x00005000; // (in self Flash memory)
....................    unsigned int32 data_size = 0x00000080;
....................    SmfDataStruct data;
01698:  MOVLB  1
0169A:  CLRF   x5C
0169C:  MOVLW  10
0169E:  MOVWF  x5B
016A0:  MOVLW  3D
016A2:  MOVWF  x5A
016A4:  CLRF   x59
016A6:  CLRF   x60
016A8:  CLRF   x5F
016AA:  MOVLW  50
016AC:  MOVWF  x5E
016AE:  CLRF   x5D
016B0:  CLRF   x64
016B2:  CLRF   x63
016B4:  CLRF   x62
016B6:  MOVLW  80
016B8:  MOVWF  x61
....................    data.dest = smf_data_destination_address;
016BA:  MOVFF  15C,16C
016BE:  MOVFF  15B,16B
016C2:  MOVFF  15A,16A
016C6:  MOVFF  159,169
....................    data.src = fm_data_source_address;
016CA:  MOVFF  160,168
016CE:  MOVFF  15F,167
016D2:  MOVFF  15E,166
016D6:  MOVFF  15D,165
....................    data.size = data_size;
016DA:  MOVFF  164,170
016DE:  MOVFF  163,16F
016E2:  MOVFF  162,16E
016E6:  MOVFF  161,16D
....................    enqueue_smf_data(&data);
016EA:  MOVLW  01
016EC:  MOVWF  x72
016EE:  MOVLW  65
016F0:  MOVWF  x71
016F2:  MOVLB  0
016F4:  BRA    142C
....................    
....................    fprintf(PC, "End example_00\r\n");
016F6:  MOVLW  6A
016F8:  MOVWF  FF6
016FA:  MOVLW  07
016FC:  MOVWF  FF7
016FE:  MOVLW  00
01700:  MOVWF  FF8
01702:  CLRF   1B
01704:  BTFSC  FF2.7
01706:  BSF    1B.7
01708:  BCF    FF2.7
0170A:  CALL   0146
0170E:  BTFSC  1B.7
01710:  BSF    FF2.7
01712:  GOTO   1D36 (RETURN)
....................    
.................... }
.................... 
.................... void example_01(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_01\r\n");
01716:  MOVLW  7C
01718:  MOVWF  FF6
0171A:  MOVLW  07
0171C:  MOVWF  FF7
0171E:  MOVLW  00
01720:  MOVWF  FF8
01722:  CLRF   1B
01724:  BTFSC  FF2.7
01726:  BSF    1B.7
01728:  BCF    FF2.7
0172A:  CALL   0146
0172E:  BTFSC  1B.7
01730:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
01732:  MOVLW  90
01734:  MOVWF  FF6
01736:  MOVLW  07
01738:  MOVWF  FF7
0173A:  MOVLW  00
0173C:  MOVWF  FF8
0173E:  CLRF   1B
01740:  BTFSC  FF2.7
01742:  BSF    1B.7
01744:  BCF    FF2.7
01746:  CALL   0146
0174A:  BTFSC  1B.7
0174C:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
0174E:  MOVLB  1
01750:  CLRF   x57
01752:  MOVF   x57,W
01754:  SUBLW  07
01756:  BNC   1782
....................       fprintf(PC, "%X ", parameter[i]);
01758:  MOVF   x57,W
0175A:  ADDWF  x55,W
0175C:  MOVWF  FE9
0175E:  MOVLW  00
01760:  ADDWFC x56,W
01762:  MOVWF  FEA
01764:  MOVFF  FEF,1DC
01768:  MOVLW  37
0176A:  MOVWF  xDD
0176C:  MOVLB  0
0176E:  CALL   0B4C
01772:  MOVLW  20
01774:  BTFSS  FA4.4
01776:  BRA    1774
01778:  MOVLB  F
0177A:  MOVWF  x1D
0177C:  MOVLB  1
0177E:  INCF   x57,F
01780:  BRA    1752
....................    fprintf(PC, "\r\n");
01782:  MOVLW  0D
01784:  BTFSS  FA4.4
01786:  BRA    1784
01788:  MOVLB  F
0178A:  MOVWF  x1D
0178C:  MOVLW  0A
0178E:  BTFSS  FA4.4
01790:  BRA    178E
01792:  MOVWF  x1D
....................    
....................    fprintf(PC, "This mission wait for 5 seconds\r\n");
01794:  MOVLW  9E
01796:  MOVWF  FF6
01798:  MOVLW  07
0179A:  MOVWF  FF7
0179C:  MOVLW  00
0179E:  MOVWF  FF8
017A0:  CLRF   1B
017A2:  BTFSC  FF2.7
017A4:  BSF    1B.7
017A6:  BCF    FF2.7
017A8:  MOVLB  0
017AA:  CALL   0146
017AE:  BTFSC  1B.7
017B0:  BSF    FF2.7
....................    fprintf(PC, "executing");
017B2:  MOVLW  C0
017B4:  MOVWF  FF6
017B6:  MOVLW  07
017B8:  MOVWF  FF7
017BA:  MOVLW  00
017BC:  MOVWF  FF8
017BE:  CLRF   1B
017C0:  BTFSC  FF2.7
017C2:  BSF    1B.7
017C4:  BCF    FF2.7
017C6:  CALL   0146
017CA:  BTFSC  1B.7
017CC:  BSF    FF2.7
....................    for (int8 i = 0; i < 5; i++)
017CE:  MOVLB  1
017D0:  CLRF   x58
017D2:  MOVF   x58,W
017D4:  SUBLW  04
017D6:  BNC   17FA
....................    {
....................       delay_ms(1000);
017D8:  MOVLW  04
017DA:  MOVWF  x59
017DC:  MOVLW  FA
017DE:  MOVWF  xA5
017E0:  MOVLB  0
017E2:  RCALL  1402
017E4:  MOVLB  1
017E6:  DECFSZ x59,F
017E8:  BRA    17DC
....................       fprintf(PC, ".");
017EA:  MOVLW  2E
017EC:  BTFSS  FA4.4
017EE:  BRA    17EC
017F0:  MOVLB  F
017F2:  MOVWF  x1D
017F4:  MOVLB  1
017F6:  INCF   x58,F
017F8:  BRA    17D2
....................    }
....................    fprintf(PC, "\r\n");
017FA:  MOVLW  0D
017FC:  BTFSS  FA4.4
017FE:  BRA    17FC
01800:  MOVLB  F
01802:  MOVWF  x1D
01804:  MOVLW  0A
01806:  BTFSS  FA4.4
01808:  BRA    1806
0180A:  MOVWF  x1D
....................    fprintf(PC, "End example_01\r\n");
0180C:  MOVLW  CA
0180E:  MOVWF  FF6
01810:  MOVLW  07
01812:  MOVWF  FF7
01814:  MOVLW  00
01816:  MOVWF  FF8
01818:  CLRF   1B
0181A:  BTFSC  FF2.7
0181C:  BSF    1B.7
0181E:  BCF    FF2.7
01820:  MOVLB  0
01822:  CALL   0146
01826:  BTFSC  1B.7
01828:  BSF    FF2.7
0182A:  GOTO   1D36 (RETURN)
.................... }
.................... 
.................... void example_02(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_02\r\n");
*
01A68:  MOVLW  DC
01A6A:  MOVWF  FF6
01A6C:  MOVLW  07
01A6E:  MOVWF  FF7
01A70:  MOVLW  00
01A72:  MOVWF  FF8
01A74:  CLRF   1B
01A76:  BTFSC  FF2.7
01A78:  BSF    1B.7
01A7A:  BCF    FF2.7
01A7C:  CALL   0146
01A80:  BTFSC  1B.7
01A82:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
01A84:  MOVLW  F0
01A86:  MOVWF  FF6
01A88:  MOVLW  07
01A8A:  MOVWF  FF7
01A8C:  MOVLW  00
01A8E:  MOVWF  FF8
01A90:  CLRF   1B
01A92:  BTFSC  FF2.7
01A94:  BSF    1B.7
01A96:  BCF    FF2.7
01A98:  CALL   0146
01A9C:  BTFSC  1B.7
01A9E:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
01AA0:  MOVLB  1
01AA2:  CLRF   x57
01AA4:  MOVF   x57,W
01AA6:  SUBLW  07
01AA8:  BNC   1AD4
....................       fprintf(PC, "%X ", parameter[i]);
01AAA:  MOVF   x57,W
01AAC:  ADDWF  x55,W
01AAE:  MOVWF  FE9
01AB0:  MOVLW  00
01AB2:  ADDWFC x56,W
01AB4:  MOVWF  FEA
01AB6:  MOVFF  FEF,1DC
01ABA:  MOVLW  37
01ABC:  MOVWF  xDD
01ABE:  MOVLB  0
01AC0:  CALL   0B4C
01AC4:  MOVLW  20
01AC6:  BTFSS  FA4.4
01AC8:  BRA    1AC6
01ACA:  MOVLB  F
01ACC:  MOVWF  x1D
01ACE:  MOVLB  1
01AD0:  INCF   x57,F
01AD2:  BRA    1AA4
....................    fprintf(PC, "\r\n");
01AD4:  MOVLW  0D
01AD6:  BTFSS  FA4.4
01AD8:  BRA    1AD6
01ADA:  MOVLB  F
01ADC:  MOVWF  x1D
01ADE:  MOVLW  0A
01AE0:  BTFSS  FA4.4
01AE2:  BRA    1AE0
01AE4:  MOVWF  x1D
....................    
....................    fprintf(PC, "This mission will first access smf and then wait for 5 seconds\r\n");
01AE6:  MOVLW  FE
01AE8:  MOVWF  FF6
01AEA:  MOVLW  07
01AEC:  MOVWF  FF7
01AEE:  MOVLW  00
01AF0:  MOVWF  FF8
01AF2:  CLRF   1B
01AF4:  BTFSC  FF2.7
01AF6:  BSF    1B.7
01AF8:  BCF    FF2.7
01AFA:  MOVLB  0
01AFC:  CALL   0146
01B00:  BTFSC  1B.7
01B02:  BSF    FF2.7
....................    if (req_use_smf())
01B04:  BRA    1844
01B06:  MOVF   01,F
01B08:  BZ    1BD4
....................    {
....................       fprintf(PC, "Access to SMF");
01B0A:  MOVLW  40
01B0C:  MOVWF  FF6
01B0E:  MOVLW  08
01B10:  MOVWF  FF7
01B12:  MOVLW  00
01B14:  MOVWF  FF8
01B16:  CLRF   1B
01B18:  BTFSC  FF2.7
01B1A:  BSF    1B.7
01B1C:  BCF    FF2.7
01B1E:  CALL   0146
01B22:  BTFSC  1B.7
01B24:  BSF    FF2.7
....................       for (int8 i = 0; i < 5; i++)
01B26:  MOVLB  1
01B28:  CLRF   x58
01B2A:  MOVF   x58,W
01B2C:  SUBLW  04
01B2E:  BNC   1B52
....................       {
....................          fprintf(PC, ".");
01B30:  MOVLW  2E
01B32:  BTFSS  FA4.4
01B34:  BRA    1B32
01B36:  MOVLB  F
01B38:  MOVWF  x1D
....................          delay_ms(1000);
01B3A:  MOVLW  04
01B3C:  MOVLB  1
01B3E:  MOVWF  x5A
01B40:  MOVLW  FA
01B42:  MOVWF  xA5
01B44:  MOVLB  0
01B46:  RCALL  1402
01B48:  MOVLB  1
01B4A:  DECFSZ x5A,F
01B4C:  BRA    1B40
01B4E:  INCF   x58,F
01B50:  BRA    1B2A
....................       }
....................       fprintf(PC, "\r\n");
01B52:  MOVLW  0D
01B54:  BTFSS  FA4.4
01B56:  BRA    1B54
01B58:  MOVLB  F
01B5A:  MOVWF  x1D
01B5C:  MOVLW  0A
01B5E:  BTFSS  FA4.4
01B60:  BRA    1B5E
01B62:  MOVWF  x1D
....................       fprintf(PC, "End use SMF\r\n");
01B64:  MOVLW  4E
01B66:  MOVWF  FF6
01B68:  MOVLW  08
01B6A:  MOVWF  FF7
01B6C:  MOVLW  00
01B6E:  MOVWF  FF8
01B70:  CLRF   1B
01B72:  BTFSC  FF2.7
01B74:  BSF    1B.7
01B76:  BCF    FF2.7
01B78:  MOVLB  0
01B7A:  CALL   0146
01B7E:  BTFSC  1B.7
01B80:  BSF    FF2.7
....................       
....................       finished_use_smf();
01B82:  BRA    1A50
....................       
....................       fprintf(PC, "wait for 10 seconods (exec mission sim)\r\n");
01B84:  MOVLW  5C
01B86:  MOVWF  FF6
01B88:  MOVLW  08
01B8A:  MOVWF  FF7
01B8C:  MOVLW  00
01B8E:  MOVWF  FF8
01B90:  CLRF   1B
01B92:  BTFSC  FF2.7
01B94:  BSF    1B.7
01B96:  BCF    FF2.7
01B98:  CALL   0146
01B9C:  BTFSC  1B.7
01B9E:  BSF    FF2.7
....................       for (int8 i = 0; i < 30; i++)
01BA0:  MOVLB  1
01BA2:  CLRF   x59
01BA4:  MOVF   x59,W
01BA6:  SUBLW  1D
01BA8:  BNC   1BD0
....................       {
....................          check_and_respond_to_boss();
01BAA:  MOVLB  0
01BAC:  BRA    1A58
....................          fprintf(PC, ".");
01BAE:  MOVLW  2E
01BB0:  BTFSS  FA4.4
01BB2:  BRA    1BB0
01BB4:  MOVLB  F
01BB6:  MOVWF  x1D
....................          delay_ms(1000);
01BB8:  MOVLW  04
01BBA:  MOVLB  1
01BBC:  MOVWF  x5A
01BBE:  MOVLW  FA
01BC0:  MOVWF  xA5
01BC2:  MOVLB  0
01BC4:  RCALL  1402
01BC6:  MOVLB  1
01BC8:  DECFSZ x5A,F
01BCA:  BRA    1BBE
01BCC:  INCF   x59,F
01BCE:  BRA    1BA4
....................       }
....................    }
01BD0:  BRA    1BF2
01BD2:  MOVLB  0
....................    else
....................       fprintf(PC, "Failure to Access to SMF");
01BD4:  MOVLW  86
01BD6:  MOVWF  FF6
01BD8:  MOVLW  08
01BDA:  MOVWF  FF7
01BDC:  MOVLW  00
01BDE:  MOVWF  FF8
01BE0:  CLRF   1B
01BE2:  BTFSC  FF2.7
01BE4:  BSF    1B.7
01BE6:  BCF    FF2.7
01BE8:  CALL   0146
01BEC:  BTFSC  1B.7
01BEE:  BSF    FF2.7
01BF0:  MOVLB  1
....................       
....................    fprintf(PC, "End example_02\r\n");
01BF2:  MOVLW  A0
01BF4:  MOVWF  FF6
01BF6:  MOVLW  08
01BF8:  MOVWF  FF7
01BFA:  MOVLW  00
01BFC:  MOVWF  FF8
01BFE:  CLRF   1B
01C00:  BTFSC  FF2.7
01C02:  BSF    1B.7
01C04:  BCF    FF2.7
01C06:  MOVLB  0
01C08:  CALL   0146
01C0C:  BTFSC  1B.7
01C0E:  BSF    FF2.7
01C10:  GOTO   1D36 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... // SerialCommunication
.................... #include "./lib/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... 
.................... #endif
.................... 
.................... 
.................... // Copy to SMF
.................... #include "./lib/data_copy.h"
.................... #ifndef DATA_COPY_H
.................... #define DATA_COPY_H
.................... 
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "./src/smf_queue.c"
.................... 
.................... #endif
.................... 
.................... #include "flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "./src/flash.c"
.................... 
.................... #endif
.................... 
.................... 
.................... void copy_data(void);
.................... 
.................... 
.................... #include "./src/data_copy.c"
.................... void copy_data(void)
.................... {   
....................    while (!is_empty_smf_data())
*
01DC6:  RCALL  1D5A
01DC8:  MOVF   01,F
01DCA:  BTFSS  FD8.2
01DCC:  BRA    2032
....................    {
....................       SmfDataStruct *smf_data = dequeue_smf_data();
01DCE:  BRA    1D6E
01DD0:  MOVFF  02,14F
01DD4:  MOVFF  01,14E
....................       fprintf(PC, "Destination address: \t0x%08LX\r\n", smf_data->dest);
01DD8:  MOVLW  04
01DDA:  MOVLB  1
01DDC:  ADDWF  x4E,W
01DDE:  MOVWF  FE9
01DE0:  MOVLW  00
01DE2:  ADDWFC x4F,W
01DE4:  MOVWF  FEA
01DE6:  MOVFF  FEF,150
01DEA:  MOVFF  FEC,151
01DEE:  MOVFF  FEC,152
01DF2:  MOVFF  FEC,153
01DF6:  MOVLW  B2
01DF8:  MOVWF  FF6
01DFA:  MOVLW  08
01DFC:  MOVWF  FF7
01DFE:  MOVLW  00
01E00:  MOVWF  FF8
01E02:  MOVLW  18
01E04:  MOVWF  xDC
01E06:  MOVLB  0
01E08:  CALL   0C28
01E0C:  MOVFF  153,1DC
01E10:  MOVLW  37
01E12:  MOVLB  1
01E14:  MOVWF  xDD
01E16:  MOVLB  0
01E18:  CALL   0B4C
01E1C:  MOVFF  152,1DC
01E20:  MOVLW  37
01E22:  MOVLB  1
01E24:  MOVWF  xDD
01E26:  MOVLB  0
01E28:  CALL   0B4C
01E2C:  MOVFF  151,1DC
01E30:  MOVLW  37
01E32:  MOVLB  1
01E34:  MOVWF  xDD
01E36:  MOVLB  0
01E38:  CALL   0B4C
01E3C:  MOVFF  150,1DC
01E40:  MOVLW  37
01E42:  MOVLB  1
01E44:  MOVWF  xDD
01E46:  MOVLB  0
01E48:  CALL   0B4C
01E4C:  MOVLW  0D
01E4E:  BTFSS  FA4.4
01E50:  BRA    1E4E
01E52:  MOVLB  F
01E54:  MOVWF  x1D
01E56:  MOVLW  0A
01E58:  BTFSS  FA4.4
01E5A:  BRA    1E58
01E5C:  MOVWF  x1D
....................       fprintf(PC, "Source address: \t0x%08LX\r\n", smf_data->src);
01E5E:  MOVLB  1
01E60:  MOVFF  14E,FE9
01E64:  MOVFF  14F,FEA
01E68:  MOVFF  FEF,150
01E6C:  MOVFF  FEC,151
01E70:  MOVFF  FEC,152
01E74:  MOVFF  FEC,153
01E78:  MOVLW  D2
01E7A:  MOVWF  FF6
01E7C:  MOVLW  08
01E7E:  MOVWF  FF7
01E80:  MOVLW  00
01E82:  MOVWF  FF8
01E84:  MOVLW  13
01E86:  MOVWF  xDC
01E88:  MOVLB  0
01E8A:  CALL   0C28
01E8E:  MOVFF  153,1DC
01E92:  MOVLW  37
01E94:  MOVLB  1
01E96:  MOVWF  xDD
01E98:  MOVLB  0
01E9A:  CALL   0B4C
01E9E:  MOVFF  152,1DC
01EA2:  MOVLW  37
01EA4:  MOVLB  1
01EA6:  MOVWF  xDD
01EA8:  MOVLB  0
01EAA:  CALL   0B4C
01EAE:  MOVFF  151,1DC
01EB2:  MOVLW  37
01EB4:  MOVLB  1
01EB6:  MOVWF  xDD
01EB8:  MOVLB  0
01EBA:  CALL   0B4C
01EBE:  MOVFF  150,1DC
01EC2:  MOVLW  37
01EC4:  MOVLB  1
01EC6:  MOVWF  xDD
01EC8:  MOVLB  0
01ECA:  CALL   0B4C
01ECE:  MOVLW  0D
01ED0:  BTFSS  FA4.4
01ED2:  BRA    1ED0
01ED4:  MOVLB  F
01ED6:  MOVWF  x1D
01ED8:  MOVLW  0A
01EDA:  BTFSS  FA4.4
01EDC:  BRA    1EDA
01EDE:  MOVWF  x1D
....................       fprintf(PC, "Data size: \t\t  %08LX\r\n", smf_data->size);
01EE0:  MOVLW  08
01EE2:  MOVLB  1
01EE4:  ADDWF  x4E,W
01EE6:  MOVWF  FE9
01EE8:  MOVLW  00
01EEA:  ADDWFC x4F,W
01EEC:  MOVWF  FEA
01EEE:  MOVFF  FEF,150
01EF2:  MOVFF  FEC,151
01EF6:  MOVFF  FEC,152
01EFA:  MOVFF  FEC,153
01EFE:  MOVLW  EE
01F00:  MOVWF  FF6
01F02:  MOVLW  08
01F04:  MOVWF  FF7
01F06:  MOVLW  00
01F08:  MOVWF  FF8
01F0A:  MOVLW  0F
01F0C:  MOVWF  xDC
01F0E:  MOVLB  0
01F10:  CALL   0C28
01F14:  MOVFF  153,1DC
01F18:  MOVLW  37
01F1A:  MOVLB  1
01F1C:  MOVWF  xDD
01F1E:  MOVLB  0
01F20:  CALL   0B4C
01F24:  MOVFF  152,1DC
01F28:  MOVLW  37
01F2A:  MOVLB  1
01F2C:  MOVWF  xDD
01F2E:  MOVLB  0
01F30:  CALL   0B4C
01F34:  MOVFF  151,1DC
01F38:  MOVLW  37
01F3A:  MOVLB  1
01F3C:  MOVWF  xDD
01F3E:  MOVLB  0
01F40:  CALL   0B4C
01F44:  MOVFF  150,1DC
01F48:  MOVLW  37
01F4A:  MOVLB  1
01F4C:  MOVWF  xDD
01F4E:  MOVLB  0
01F50:  CALL   0B4C
01F54:  MOVLW  0D
01F56:  BTFSS  FA4.4
01F58:  BRA    1F56
01F5A:  MOVLB  F
01F5C:  MOVWF  x1D
01F5E:  MOVLW  0A
01F60:  BTFSS  FA4.4
01F62:  BRA    1F60
01F64:  MOVWF  x1D
....................       fprintf(PC, "Copying.");
01F66:  MOVLW  06
01F68:  MOVWF  FF6
01F6A:  MOVLW  09
01F6C:  MOVWF  FF7
01F6E:  MOVLW  00
01F70:  MOVWF  FF8
01F72:  CLRF   1B
01F74:  BTFSC  FF2.7
01F76:  BSF    1B.7
01F78:  BCF    FF2.7
01F7A:  MOVLB  0
01F7C:  CALL   0146
01F80:  BTFSC  1B.7
01F82:  BSF    FF2.7
....................       delay_ms(1000);
01F84:  MOVLW  04
01F86:  MOVLB  1
01F88:  MOVWF  x50
01F8A:  MOVLW  FA
01F8C:  MOVWF  xA5
01F8E:  MOVLB  0
01F90:  CALL   1402
01F94:  MOVLB  1
01F96:  DECFSZ x50,F
01F98:  BRA    1F8A
....................       fprintf(PC, ".");
01F9A:  MOVLW  2E
01F9C:  BTFSS  FA4.4
01F9E:  BRA    1F9C
01FA0:  MOVLB  F
01FA2:  MOVWF  x1D
....................       delay_ms(1000);
01FA4:  MOVLW  04
01FA6:  MOVLB  1
01FA8:  MOVWF  x50
01FAA:  MOVLW  FA
01FAC:  MOVWF  xA5
01FAE:  MOVLB  0
01FB0:  CALL   1402
01FB4:  MOVLB  1
01FB6:  DECFSZ x50,F
01FB8:  BRA    1FAA
....................       fprintf(PC, ".");
01FBA:  MOVLW  2E
01FBC:  BTFSS  FA4.4
01FBE:  BRA    1FBC
01FC0:  MOVLB  F
01FC2:  MOVWF  x1D
....................       delay_ms(1000);
01FC4:  MOVLW  04
01FC6:  MOVLB  1
01FC8:  MOVWF  x50
01FCA:  MOVLW  FA
01FCC:  MOVWF  xA5
01FCE:  MOVLB  0
01FD0:  CALL   1402
01FD4:  MOVLB  1
01FD6:  DECFSZ x50,F
01FD8:  BRA    1FCA
....................       fprintf(PC, ".");   
01FDA:  MOVLW  2E
01FDC:  BTFSS  FA4.4
01FDE:  BRA    1FDC
01FE0:  MOVLB  F
01FE2:  MOVWF  x1D
....................       delay_ms(1000);
01FE4:  MOVLW  04
01FE6:  MOVLB  1
01FE8:  MOVWF  x50
01FEA:  MOVLW  FA
01FEC:  MOVWF  xA5
01FEE:  MOVLB  0
01FF0:  CALL   1402
01FF4:  MOVLB  1
01FF6:  DECFSZ x50,F
01FF8:  BRA    1FEA
....................       fprintf(PC, ".\r\n");   
01FFA:  MOVLW  10
01FFC:  MOVWF  FF6
01FFE:  MOVLW  09
02000:  MOVWF  FF7
02002:  MOVLW  00
02004:  MOVWF  FF8
02006:  CLRF   1B
02008:  BTFSC  FF2.7
0200A:  BSF    1B.7
0200C:  BCF    FF2.7
0200E:  MOVLB  0
02010:  CALL   0146
02014:  BTFSC  1B.7
02016:  BSF    FF2.7
....................       delay_ms(1000);
02018:  MOVLW  04
0201A:  MOVLB  1
0201C:  MOVWF  x50
0201E:  MOVLW  FA
02020:  MOVWF  xA5
02022:  MOVLB  0
02024:  CALL   1402
02028:  MOVLB  1
0202A:  DECFSZ x50,F
0202C:  BRA    201E
0202E:  MOVLB  0
02030:  BRA    1DC6
....................    }
....................    fprintf(PC, "_________End copy_data_________\r\n______________________________\r\n\r\n");
02032:  MOVLW  14
02034:  MOVWF  FF6
02036:  MOVLW  09
02038:  MOVWF  FF7
0203A:  MOVLW  00
0203C:  MOVWF  FF8
0203E:  CLRF   1B
02040:  BTFSC  FF2.7
02042:  BSF    1B.7
02044:  BCF    FF2.7
02046:  CALL   0146
0204A:  BTFSC  1B.7
0204C:  BSF    FF2.7
0204E:  GOTO   222C (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void initialize(void)
.................... {
....................    fprintf(PC, "Start setting\r\n");
*
00AFA:  MOVLW  58
00AFC:  MOVWF  FF6
00AFE:  MOVLW  09
00B00:  MOVWF  FF7
00B02:  MOVLW  00
00B04:  MOVWF  FF8
00B06:  CLRF   1B
00B08:  BTFSC  FF2.7
00B0A:  BSF    1B.7
00B0C:  BCF    FF2.7
00B0E:  CALL   0146
00B12:  BTFSC  1B.7
00B14:  BSF    FF2.7
....................    setup_lcd(LCD_DISABLED);
00B16:  MOVLB  E
00B18:  CLRF   xD6
00B1A:  CLRF   xD7
00B1C:  CLRF   xDA
00B1E:  CLRF   xD8
00B20:  CLRF   xD9
....................    
....................    setup_timer();
00B22:  MOVLB  0
00B24:  BRA    0AEA
....................    setup_uart_to_boss();
00B26:  BRA    0AF4
.................... 
....................    enable_interrupts(GLOBAL);
00B28:  MOVLW  C0
00B2A:  IORWF  FF2,F
....................    fprintf(PC, "End setting\r\n");
00B2C:  MOVLW  68
00B2E:  MOVWF  FF6
00B30:  MOVLW  09
00B32:  MOVWF  FF7
00B34:  MOVLW  00
00B36:  MOVWF  FF8
00B38:  CLRF   1B
00B3A:  BTFSC  FF2.7
00B3C:  BSF    1B.7
00B3E:  BCF    FF2.7
00B40:  CALL   0146
00B44:  BTFSC  1B.7
00B46:  BSF    FF2.7
00B48:  GOTO   241E (RETURN)
.................... }
.................... 
.................... 
.................... // ___________ command execution ___________
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "\r\nStart execute_command\r\n");
*
02052:  MOVLW  76
02054:  MOVWF  FF6
02056:  MOVLW  09
02058:  MOVWF  FF7
0205A:  MOVLW  00
0205C:  MOVWF  FF8
0205E:  CLRF   1B
02060:  BTFSC  FF2.7
02062:  BSF    1B.7
02064:  BCF    FF2.7
02066:  CALL   0146
0206A:  BTFSC  1B.7
0206C:  BSF    FF2.7
....................    
....................    switch(command->frame_id)
0206E:  MOVLB  1
02070:  MOVF   x4C,W
02072:  MOVWF  FE9
02074:  MOVF   x4D,W
02076:  MOVWF  FEA
02078:  MOVF   FEF,W
0207A:  XORLW  00
0207C:  MOVLB  0
0207E:  BZ    208C
02080:  XORLW  01
02082:  BZ    2118
02084:  XORLW  03
02086:  BTFSC  FD8.2
02088:  BRA    21BA
0208A:  BRA    2252
....................    {
....................       case UPLINK_COMMAND:
....................          fprintf(PC, "\t-> Uplink command\r\n");
0208C:  MOVLW  90
0208E:  MOVWF  FF6
02090:  MOVLW  09
02092:  MOVWF  FF7
02094:  MOVLW  00
02096:  MOVWF  FF8
02098:  CLRF   1B
0209A:  BTFSC  FF2.7
0209C:  BSF    1B.7
0209E:  BCF    FF2.7
020A0:  CALL   0146
020A4:  BTFSC  1B.7
020A6:  BSF    FF2.7
....................          fprintf(PC, "\t   Transmit Acknolegde\r\n");
020A8:  MOVLW  A6
020AA:  MOVWF  FF6
020AC:  MOVLW  09
020AE:  MOVWF  FF7
020B0:  MOVLW  00
020B2:  MOVWF  FF8
020B4:  CLRF   1B
020B6:  BTFSC  FF2.7
020B8:  BSF    1B.7
020BA:  BCF    FF2.7
020BC:  CALL   0146
020C0:  BTFSC  1B.7
020C2:  BSF    FF2.7
....................          transmit_ack();
020C4:  CALL   11F8
.................... 
....................          status = EXECUTING_MISSION;
020C8:  MOVLW  02
020CA:  MOVWF  1F
....................          execute_mission(command->content);
020CC:  MOVLW  01
020CE:  MOVLB  1
020D0:  ADDWF  x4C,W
020D2:  MOVWF  01
020D4:  MOVLW  00
020D6:  ADDWFC x4D,W
020D8:  MOVWF  03
020DA:  MOVFF  01,14E
020DE:  MOVWF  x4F
020E0:  MOVWF  x51
020E2:  MOVFF  01,150
020E6:  MOVLB  0
020E8:  BRA    1C14
....................          if (is_empty_smf_data())
020EA:  RCALL  1D5A
020EC:  MOVF   01,F
020EE:  BZ    2112
....................          {
....................             if (duration_sec < sec)
020F0:  MOVF   27,F
020F2:  BNZ   2106
020F4:  MOVF   26,F
020F6:  BNZ   2106
020F8:  MOVF   1D,W
020FA:  SUBWF  25,W
020FC:  BNC   210C
020FE:  BNZ   2106
02100:  MOVF   24,W
02102:  SUBWF  1C,W
02104:  BC    210C
....................                status = FINISHED;
02106:  MOVLW  06
02108:  MOVWF  1F
0210A:  BRA    2110
....................             else
....................                status = IDLE;
0210C:  MOVLW  03
0210E:  MOVWF  1F
....................          }
02110:  BRA    2116
....................          else
....................             status = SMF_USE_REQ;
02112:  MOVLW  04
02114:  MOVWF  1F
....................          break;
02116:  BRA    2252
....................       
....................       case STATUS_CHECK:
....................          fprintf(PC, "\t-> Status check\r\n");
02118:  MOVLW  C0
0211A:  MOVWF  FF6
0211C:  MOVLW  09
0211E:  MOVWF  FF7
02120:  MOVLW  00
02122:  MOVWF  FF8
02124:  CLRF   1B
02126:  BTFSC  FF2.7
02128:  BSF    1B.7
0212A:  BCF    FF2.7
0212C:  CALL   0146
02130:  BTFSC  1B.7
02132:  BSF    FF2.7
....................          fprintf(PC, "\t\t-> My status is %d\r\n", status);
02134:  MOVLW  D4
02136:  MOVWF  FF6
02138:  MOVLW  09
0213A:  MOVWF  FF7
0213C:  MOVLW  00
0213E:  MOVWF  FF8
02140:  MOVLW  12
02142:  MOVLB  1
02144:  MOVWF  xDC
02146:  MOVLB  0
02148:  CALL   0C28
0214C:  MOVFF  1F,155
02150:  MOVLW  18
02152:  MOVLB  1
02154:  MOVWF  x56
02156:  MOVLB  0
02158:  CALL   1294
0215C:  MOVLW  0D
0215E:  BTFSS  FA4.4
02160:  BRA    215E
02162:  MOVLB  F
02164:  MOVWF  x1D
02166:  MOVLW  0A
02168:  BTFSS  FA4.4
0216A:  BRA    2168
0216C:  MOVWF  x1D
....................          fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
0216E:  MOVLW  EC
02170:  MOVWF  FF6
02172:  MOVLW  09
02174:  MOVWF  FF7
02176:  MOVLW  00
02178:  MOVWF  FF8
0217A:  CLRF   1B
0217C:  BTFSC  FF2.7
0217E:  BSF    1B.7
02180:  BCF    FF2.7
02182:  MOVLB  0
02184:  CALL   0146
02188:  BTFSC  1B.7
0218A:  BSF    FF2.7
....................          transmit_status();
0218C:  CALL   182E
....................          if (status == FINISHED)
02190:  MOVF   1F,W
02192:  SUBLW  06
02194:  BNZ   21B8
....................          {
....................             fprintf(PC, "finished in status_check\r\n");
02196:  MOVLW  0A
02198:  MOVWF  FF6
0219A:  MOVLW  0A
0219C:  MOVWF  FF7
0219E:  MOVLW  00
021A0:  MOVWF  FF8
021A2:  CLRF   1B
021A4:  BTFSC  FF2.7
021A6:  BSF    1B.7
021A8:  BCF    FF2.7
021AA:  CALL   0146
021AE:  BTFSC  1B.7
021B0:  BSF    FF2.7
....................             return TRUE;
021B2:  MOVLW  01
021B4:  MOVWF  01
021B6:  BRA    2256
....................          }
....................          break;
021B8:  BRA    2252
....................       
....................       case IS_SMF_AVAILABLE:
....................          fprintf(PC, "\t-> is SMF available\r\n");
021BA:  MOVLW  26
021BC:  MOVWF  FF6
021BE:  MOVLW  0A
021C0:  MOVWF  FF7
021C2:  MOVLW  00
021C4:  MOVWF  FF8
021C6:  CLRF   1B
021C8:  BTFSC  FF2.7
021CA:  BSF    1B.7
021CC:  BCF    FF2.7
021CE:  CALL   0146
021D2:  BTFSC  1B.7
021D4:  BSF    FF2.7
....................          fprintf(PC, "\t   Transmit Acknolegde\r\n");
021D6:  MOVLW  3E
021D8:  MOVWF  FF6
021DA:  MOVLW  0A
021DC:  MOVWF  FF7
021DE:  MOVLW  00
021E0:  MOVWF  FF8
021E2:  CLRF   1B
021E4:  BTFSC  FF2.7
021E6:  BSF    1B.7
021E8:  BCF    FF2.7
021EA:  CALL   0146
021EE:  BTFSC  1B.7
021F0:  BSF    FF2.7
....................          transmit_ack();
021F2:  CALL   11F8
....................          if (command->content[0] == ALLOW)
021F6:  MOVLW  01
021F8:  MOVLB  1
021FA:  ADDWF  x4C,W
021FC:  MOVWF  FE9
021FE:  MOVLW  00
02200:  ADDWFC x4D,W
02202:  MOVWF  FEA
02204:  MOVF   FEF,F
02206:  BNZ   2234
....................          {
....................             fprintf(PC, "\t\t-> allowd\r\n");
02208:  MOVLW  58
0220A:  MOVWF  FF6
0220C:  MOVLW  0A
0220E:  MOVWF  FF7
02210:  MOVLW  00
02212:  MOVWF  FF8
02214:  CLRF   1B
02216:  BTFSC  FF2.7
02218:  BSF    1B.7
0221A:  BCF    FF2.7
0221C:  MOVLB  0
0221E:  CALL   0146
02222:  BTFSC  1B.7
02224:  BSF    FF2.7
....................             status = COPYING;
02226:  MOVLW  05
02228:  MOVWF  1F
....................             copy_data();
0222A:  BRA    1DC6
....................             status = FINISHED;
0222C:  MOVLW  06
0222E:  MOVWF  1F
....................          }
02230:  BRA    2252
02232:  MOVLB  1
....................          else
....................             fprintf(PC, "\t\t-> denyed\r\n");
02234:  MOVLW  66
02236:  MOVWF  FF6
02238:  MOVLW  0A
0223A:  MOVWF  FF7
0223C:  MOVLW  00
0223E:  MOVWF  FF8
02240:  CLRF   1B
02242:  BTFSC  FF2.7
02244:  BSF    1B.7
02246:  BCF    FF2.7
02248:  MOVLB  0
0224A:  CALL   0146
0224E:  BTFSC  1B.7
02250:  BSF    FF2.7
....................    }
....................    return FALSE;
02252:  MOVLW  00
02254:  MOVWF  01
02256:  GOTO   2480 (RETURN)
.................... }
.................... 
.................... 
.................... // ___________ main functoin _______________
.................... 
.................... void main()
0225A:  CLRF   FF8
0225C:  BCF    FD0.7
0225E:  BSF    07.7
02260:  MOVLB  E
02262:  MOVLW  55
02264:  MOVWF  F7E
02266:  MOVLW  AA
02268:  MOVWF  F7E
0226A:  BCF    F66.6
0226C:  MOVLW  F8
0226E:  MOVWF  x2A
02270:  MOVLW  F5
02272:  MOVWF  x2B
02274:  MOVLW  F8
02276:  MOVWF  x2C
02278:  MOVLW  F9
0227A:  MOVWF  x2D
0227C:  MOVLW  20
0227E:  MOVWF  x1D
02280:  MOVLW  30
02282:  MOVWF  x22
02284:  MOVLW  20
02286:  MOVWF  x24
02288:  MOVLW  01
0228A:  MOVWF  x25
0228C:  MOVLW  55
0228E:  MOVWF  F7E
02290:  MOVLW  AA
02292:  MOVWF  F7E
02294:  BSF    F66.6
02296:  CLRF   F9B
02298:  CLRF   F64
0229A:  CLRF   F65
0229C:  CLRF   F66
0229E:  MOVLW  02
022A0:  MOVWF  FD3
022A2:  BSF    F67.3
022A4:  MOVLW  A0
022A6:  MOVWF  FAF
022A8:  MOVLW  01
022AA:  MOVLB  F
022AC:  MOVWF  x30
022AE:  MOVLW  A6
022B0:  MOVWF  FAC
022B2:  MOVLW  90
022B4:  MOVWF  FAB
022B6:  BSF    x31.3
022B8:  MOVLW  A0
022BA:  MOVWF  x1F
022BC:  MOVLW  01
022BE:  MOVWF  x20
022C0:  MOVLW  A6
022C2:  MOVWF  x32
022C4:  MOVLW  90
022C6:  MOVWF  x33
022C8:  BSF    x2D.3
022CA:  MOVLW  A0
022CC:  MOVWF  x2B
022CE:  MOVLW  01
022D0:  MOVWF  x2C
022D2:  MOVLW  A6
022D4:  MOVWF  x2E
022D6:  MOVLW  90
022D8:  MOVWF  x2F
022DA:  MOVLB  E
022DC:  BSF    xFD.3
022DE:  MOVLW  A0
022E0:  MOVWF  xFB
022E2:  MOVLW  01
022E4:  MOVWF  xFC
022E6:  MOVLW  A6
022E8:  MOVWF  xFE
022EA:  MOVLW  90
022EC:  MOVWF  xFF
022EE:  BSF    F92.0
022F0:  BCF    F92.1
022F2:  BCF    F92.3
022F4:  BCF    F89.3
022F6:  BSF    F93.5
022F8:  BCF    F93.4
022FA:  BCF    F93.2
022FC:  BCF    F8A.2
022FE:  CLRF   1D
02300:  CLRF   1C
02302:  BCF    1E.0
02304:  MOVLW  03
02306:  MOVWF  1F
02308:  CLRF   23
0230A:  CLRF   22
0230C:  CLRF   21
0230E:  CLRF   20
02310:  CLRF   27
02312:  CLRF   26
02314:  CLRF   25
02316:  CLRF   24
02318:  CLRF   29
0231A:  CLRF   28
0231C:  CLRF   4A
0231E:  CLRF   4C
02320:  CLRF   4B
02322:  CLRF   xD9
02324:  CLRF   xDA
02326:  CLRF   xCE
02328:  CLRF   xCF
0232A:  CLRF   xD0
0232C:  CLRF   xD1
0232E:  CLRF   xD2
02330:  CLRF   xD3
02332:  CLRF   xD4
02334:  CLRF   xD5
02336:  CLRF   x45
02338:  CLRF   x46
0233A:  CLRF   x47
0233C:  BCF    x8D.7
0233E:  BCF    x8D.6
02340:  BCF    x8D.5
02342:  MOVLB  F
02344:  CLRF   x53
02346:  CLRF   x38
02348:  CLRF   x37
0234A:  BRA    2366
0234C:  DATA 20,40
0234E:  DATA 2A,00
02350:  DATA C4,40
02352:  DATA 4D,00
02354:  DATA 0C,80
02356:  DATA 02,7C
02358:  DATA 01,01
0235A:  DATA 0B,7C
0235C:  DATA 00,09
0235E:  DATA 01,00
02360:  DATA 02,01
02362:  DATA 09,C0
02364:  DATA 00,00
02366:  MOVLW  00
02368:  MOVWF  FF8
0236A:  MOVLW  23
0236C:  MOVWF  FF7
0236E:  MOVLW  4C
02370:  MOVWF  FF6
02372:  TBLRD*+
02374:  MOVF   FF5,W
02376:  MOVWF  00
02378:  XORLW  00
0237A:  BZ    23A2
0237C:  TBLRD*+
0237E:  MOVF   FF5,W
02380:  MOVWF  01
02382:  BTFSC  FE8.7
02384:  BRA    2390
02386:  ANDLW  3F
02388:  MOVWF  FEA
0238A:  TBLRD*+
0238C:  MOVFF  FF5,FE9
02390:  BTFSC  01.6
02392:  TBLRD*+
02394:  BTFSS  01.6
02396:  TBLRD*+
02398:  MOVFF  FF5,FEE
0239C:  DCFSNZ 00,F
0239E:  BRA    2372
023A0:  BRA    2394
023A2:  CLRF   FF8
.................... {
....................    fprintf(PC, "\r\n\r\n");
023A4:  MOVLW  74
023A6:  MOVWF  FF6
023A8:  MOVLW  0A
023AA:  MOVWF  FF7
023AC:  MOVLW  00
023AE:  MOVWF  FF8
023B0:  CLRF   1B
023B2:  BTFSC  FF2.7
023B4:  BSF    1B.7
023B6:  BCF    FF2.7
023B8:  MOVLB  0
023BA:  CALL   0146
023BE:  BTFSC  1B.7
023C0:  BSF    FF2.7
....................    for (int8 i = 0; i < 3; i++)
023C2:  MOVLB  1
023C4:  CLRF   x26
023C6:  MOVF   x26,W
023C8:  SUBLW  02
023CA:  BNC   23FC
....................    {
....................       for (int8 j = 0; j < 31; j++)
023CC:  CLRF   x27
023CE:  MOVF   x27,W
023D0:  SUBLW  1E
023D2:  BNC   23E4
....................          fprintf(PC, "_");
023D4:  MOVLW  5F
023D6:  BTFSS  FA4.4
023D8:  BRA    23D6
023DA:  MOVLB  F
023DC:  MOVWF  x1D
023DE:  MOVLB  1
023E0:  INCF   x27,F
023E2:  BRA    23CE
....................       fprintf(PC, "\r\n");
023E4:  MOVLW  0D
023E6:  BTFSS  FA4.4
023E8:  BRA    23E6
023EA:  MOVLB  F
023EC:  MOVWF  x1D
023EE:  MOVLW  0A
023F0:  BTFSS  FA4.4
023F2:  BRA    23F0
023F4:  MOVWF  x1D
023F6:  MOVLB  1
023F8:  INCF   x26,F
023FA:  BRA    23C6
....................    }
....................    fprintf(PC, "___________Start main__________\r\n\r\n");
023FC:  MOVLW  7A
023FE:  MOVWF  FF6
02400:  MOVLW  0A
02402:  MOVWF  FF7
02404:  MOVLW  00
02406:  MOVWF  FF8
02408:  CLRF   1B
0240A:  BTFSC  FF2.7
0240C:  BSF    1B.7
0240E:  BCF    FF2.7
02410:  MOVLB  0
02412:  CALL   0146
02416:  BTFSC  1B.7
02418:  BSF    FF2.7
....................    
....................    
....................    initialize();
0241A:  GOTO   0AFA
....................    
....................    int1 is_finished = FALSE;
0241E:  MOVLB  1
02420:  BCF    x28.0
.................... 
....................    //Start loop
....................    while(!is_finished)
02422:  BTFSC  x28.0
02424:  BRA    24D4
....................    {
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
02426:  MOVF   4A,F
02428:  BZ    2488
....................       {
....................          Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
0242A:  CLRF   x53
0242C:  MOVLW  2A
0242E:  MOVWF  x52
02430:  MOVFF  4A,154
02434:  MOVLB  0
02436:  GOTO   106E
0243A:  MOVFF  02,03
0243E:  MOVFF  01,FE1
02442:  MOVFF  02,FE2
02446:  MOVLW  01
02448:  MOVWF  FEA
0244A:  MOVLW  29
0244C:  MOVWF  FE9
0244E:  MOVLW  23
02450:  MOVWF  01
02452:  MOVFF  FE6,FEE
02456:  DECFSZ 01,F
02458:  BRA    2452
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
0245A:  MOVLB  1
0245C:  CLRF   xA5
0245E:  MOVLW  2A
02460:  MOVWF  xA4
02462:  CLRF   xA7
02464:  MOVLW  4A
02466:  MOVWF  xA6
02468:  MOVLB  0
0246A:  CALL   10B0
....................             
....................          if(command.is_exist)
0246E:  MOVLB  1
02470:  BTFSS  x4B.0
02472:  BRA    2488
....................             is_finished = execute_command(&command); 
02474:  MOVLW  01
02476:  MOVWF  x4D
02478:  MOVLW  29
0247A:  MOVWF  x4C
0247C:  MOVLB  0
0247E:  BRA    2052
02480:  MOVLB  1
02482:  BCF    x28.0
02484:  BTFSC  01.0
02486:  BSF    x28.0
....................       }
....................       
....................       // check mis mcu duration seconds (used in mission.c \ void continue_mis_mcu(int16 duration_sec))
....................       if (status == IDLE)
02488:  MOVF   1F,W
0248A:  SUBLW  03
0248C:  BNZ   24B8
....................          if (duration_sec < sec && is_empty_smf_data())
0248E:  MOVF   27,F
02490:  BNZ   24A4
02492:  MOVF   26,F
02494:  BNZ   24A4
02496:  MOVF   1D,W
02498:  SUBWF  25,W
0249A:  BNC   24B8
0249C:  BNZ   24A4
0249E:  MOVF   24,W
024A0:  SUBWF  1C,W
024A2:  BC    24B8
024A4:  MOVLB  0
024A6:  RCALL  1D5A
024A8:  MOVF   01,F
024AA:  BTFSS  FD8.2
024AC:  BRA    24B2
024AE:  MOVLB  1
024B0:  BRA    24B8
....................             status = FINISHED;
024B2:  MOVLW  06
024B4:  MOVWF  1F
024B6:  MOVLB  1
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
024B8:  BTFSS  x28.0
024BA:  BRA    24BE
....................          break;
024BC:  BRA    24D4
....................          
....................       delay_ms(400);
024BE:  MOVLW  02
024C0:  MOVWF  x4C
024C2:  MOVLW  C8
024C4:  MOVWF  xA5
024C6:  MOVLB  0
024C8:  CALL   1402
024CC:  MOVLB  1
024CE:  DECFSZ x4C,F
024D0:  BRA    24C2
024D2:  BRA    2422
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
024D4:  MOVLW  9E
024D6:  MOVWF  FF6
024D8:  MOVLW  0A
024DA:  MOVWF  FF7
024DC:  MOVLW  00
024DE:  MOVWF  FF8
024E0:  CLRF   1B
024E2:  BTFSC  FF2.7
024E4:  BSF    1B.7
024E6:  BCF    FF2.7
024E8:  MOVLB  0
024EA:  CALL   0146
024EE:  BTFSC  1B.7
024F0:  BSF    FF2.7
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
024F2:  MOVLW  2E
024F4:  BTFSS  FA4.4
024F6:  BRA    24F4
024F8:  MOVLB  F
024FA:  MOVWF  x1D
....................       delay_ms(1000);
024FC:  MOVLW  04
024FE:  MOVLB  1
02500:  MOVWF  x4C
02502:  MOVLW  FA
02504:  MOVWF  xA5
02506:  MOVLB  0
02508:  CALL   1402
0250C:  MOVLB  1
0250E:  DECFSZ x4C,F
02510:  BRA    2502
02512:  MOVLB  0
02514:  BRA    24F2
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
02516:  MOVLW  DE
02518:  MOVWF  FF6
0251A:  MOVLW  0A
0251C:  MOVWF  FF7
0251E:  MOVLW  00
02520:  MOVWF  FF8
02522:  CLRF   1B
02524:  BTFSC  FF2.7
02526:  BSF    1B.7
02528:  BCF    FF2.7
0252A:  CALL   0146
0252E:  BTFSC  1B.7
02530:  BSF    FF2.7
.................... }
02532:  SLEEP 

Configuration Fuses:
   Word  1: F7A0   STVREN NOXINST NODEBUG BROWNOUT_SW BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
