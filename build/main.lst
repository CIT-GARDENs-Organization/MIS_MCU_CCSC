CCS PCH C Compiler, Version 5.104, 57077               24-4-25 12:27

               Filename:   build\main.lst

               ROM used:   9914 bytes (8%)
                           Largest free fragment is 65520
               RAM used:   334 (9%) at main() level
                           488 (14%) worst case
               Stack used: 2 locations (0 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   22FC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  BTFSS  FF2.5
0005E:  GOTO   0068
00062:  BTFSC  FF2.2
00064:  GOTO   00CA
00068:  BTFSS  F9D.5
0006A:  GOTO   0074
0006E:  BTFSC  F9E.5
00070:  GOTO   0174
00074:  MOVFF  0E,00
00078:  MOVFF  0F,01
0007C:  MOVFF  10,02
00080:  MOVFF  11,03
00084:  MOVFF  0C,FE9
00088:  MOVFF  07,FEA
0008C:  BSF    07.7
0008E:  MOVFF  08,FE1
00092:  MOVFF  09,FE2
00096:  MOVFF  0A,FD9
0009A:  MOVFF  0B,FDA
0009E:  MOVFF  12,FF3
000A2:  MOVFF  13,FF4
000A6:  MOVFF  14,FFA
000AA:  MOVFF  15,FF5
000AE:  MOVFF  16,FF6
000B2:  MOVFF  17,FF7
000B6:  MOVFF  18,FF8
000BA:  MOVFF  19,FFB
000BE:  MOVF   04,W
000C0:  MOVFF  06,FE0
000C4:  MOVFF  05,FD8
000C8:  RETFIE 0
.................... #include "./main.h"
.................... #ifndef MAIN_H
.................... #define MAIN_H
.................... 
.................... // PIC configuration file
.................... #include <18F67J94.h>
.................... //////////// Standard Header file for the PIC18F67J94 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F67J94
*
00146:  TBLRD*+
00148:  MOVF   FF5,F
0014A:  BZ    0172
0014C:  MOVFF  FF6,1E5
00150:  MOVFF  FF7,1E6
00154:  MOVFF  FF8,1E7
00158:  MOVF   FF5,W
0015A:  BTFSS  FA4.4
0015C:  BRA    015A
0015E:  MOVLB  F
00160:  MOVWF  x1D
00162:  MOVFF  1E5,FF6
00166:  MOVFF  1E6,FF7
0016A:  MOVFF  1E7,FF8
0016E:  MOVLB  0
00170:  BRA    0146
00172:  RETURN 0
*
001C0:  DATA 0D,0A
001C2:  DATA 4F,76
001C4:  DATA 65,72
001C6:  DATA 66,6C
001C8:  DATA 6F,77
001CA:  DATA 20,42
001CC:  DATA 4F,53
001CE:  DATA 53,20
001D0:  DATA 72,65
001D2:  DATA 63,65
001D4:  DATA 69,76
001D6:  DATA 65,20
001D8:  DATA 73,69
001DA:  DATA 67,6E
001DC:  DATA 61,6C
001DE:  DATA 20,62
001E0:  DATA 75,66
001E2:  DATA 66,65
001E4:  DATA 72,21
001E6:  DATA 21,21
001E8:  DATA 0D,0A
001EA:  DATA 0D,0A
001EC:  DATA 00,00
001EE:  DATA 53,4D
001F0:  DATA 46,20
001F2:  DATA 64,61
001F4:  DATA 74,61
001F6:  DATA 20,6C
001F8:  DATA 69,73
001FA:  DATA 74,20
001FC:  DATA 69,73
001FE:  DATA 20,66
00200:  DATA 75,6C
00202:  DATA 6C,21
00204:  DATA 21,21
00206:  DATA 0D,0A
00208:  DATA 00,00
0020A:  DATA 53,4D
0020C:  DATA 46,20
0020E:  DATA 64,61
00210:  DATA 74,61
00212:  DATA 20,6C
00214:  DATA 69,73
00216:  DATA 74,20
00218:  DATA 69,73
0021A:  DATA 20,65
0021C:  DATA 6D,70
0021E:  DATA 74,79
00220:  DATA 0D,0A
00222:  DATA 00,00
00224:  DATA 66,6C
00226:  DATA 61,73
00228:  DATA 68,20
0022A:  DATA 62,75
0022C:  DATA 73,79
0022E:  DATA 0A,0D
00230:  DATA 00,00
00232:  DATA 52,65
00234:  DATA 61,64
00236:  DATA 20,49
00238:  DATA 44,3A
0023A:  DATA 00,00
0023C:  DATA 66,6C
0023E:  DATA 61,73
00240:  DATA 68,20
00242:  DATA 63,6F
00244:  DATA 6E,6E
00246:  DATA 65,63
00248:  DATA 74,20
0024A:  DATA 4F,4B
0024C:  DATA 0D,0A
0024E:  DATA 00,00
00250:  DATA 66,6C
00252:  DATA 61,73
00254:  DATA 68,20
00256:  DATA 6E,6F
00258:  DATA 74,20
0025A:  DATA 63,6F
0025C:  DATA 6E,6E
0025E:  DATA 65,63
00260:  DATA 74,0D
00262:  DATA 0A,00
00264:  DATA 65,72
00266:  DATA 72,6F
00268:  DATA 72,3A
0026A:  DATA 66,6C
0026C:  DATA 61,73
0026E:  DATA 68,20
00270:  DATA 6D,6F
00272:  DATA 64,65
00274:  DATA 6C,20
00276:  DATA 69,73
00278:  DATA 20,69
0027A:  DATA 6E,76
0027C:  DATA 61,6C
0027E:  DATA 69,64
00280:  DATA 0D,0A
00282:  DATA 00,00
00284:  DATA 66,6C
00286:  DATA 61,73
00288:  DATA 68,20
0028A:  DATA 74,69
0028C:  DATA 6D,65
0028E:  DATA 6F,75
00290:  DATA 74,0D
00292:  DATA 0A,00
00294:  DATA 66,6C
00296:  DATA 61,73
00298:  DATA 68,20
0029A:  DATA 73,65
0029C:  DATA 63,74
0029E:  DATA 6F,72
002A0:  DATA 20,65
002A2:  DATA 72,61
002A4:  DATA 73,65
002A6:  DATA 20,63
002A8:  DATA 6F,6D
002AA:  DATA 70,6C
002AC:  DATA 65,74
002AE:  DATA 65,0D
002B0:  DATA 0A,00
002B2:  DATA 65,72
002B4:  DATA 72,6F
002B6:  DATA 72,3A
002B8:  DATA 66,6C
002BA:  DATA 61,73
002BC:  DATA 68,20
002BE:  DATA 6D,6F
002C0:  DATA 64,65
002C2:  DATA 6C,20
002C4:  DATA 69,73
002C6:  DATA 20,69
002C8:  DATA 6E,76
002CA:  DATA 61,6C
002CC:  DATA 69,64
002CE:  DATA 0D,0A
002D0:  DATA 00,00
002D2:  DATA 66,6C
002D4:  DATA 61,73
002D6:  DATA 68,20
002D8:  DATA 74,69
002DA:  DATA 6D,65
002DC:  DATA 6F,75
002DE:  DATA 74,0D
002E0:  DATA 0A,00
002E2:  DATA 66,6C
002E4:  DATA 61,73
002E6:  DATA 68,20
002E8:  DATA 33,32
002EA:  DATA 6B,42
002EC:  DATA 79,74
002EE:  DATA 65,20
002F0:  DATA 73,75
002F2:  DATA 62,73
002F4:  DATA 65,63
002F6:  DATA 74,6F
002F8:  DATA 72,20
002FA:  DATA 65,72
002FC:  DATA 61,73
002FE:  DATA 65,20
00300:  DATA 63,6F
00302:  DATA 6D,70
00304:  DATA 6C,65
00306:  DATA 74,65
00308:  DATA 0D,0A
0030A:  DATA 00,00
0030C:  DATA 65,72
0030E:  DATA 72,6F
00310:  DATA 72,3A
00312:  DATA 66,6C
00314:  DATA 61,73
00316:  DATA 68,20
00318:  DATA 6D,6F
0031A:  DATA 64,65
0031C:  DATA 6C,20
0031E:  DATA 69,73
00320:  DATA 20,69
00322:  DATA 6E,76
00324:  DATA 61,6C
00326:  DATA 69,64
00328:  DATA 0D,0A
0032A:  DATA 00,00
0032C:  DATA 66,6C
0032E:  DATA 61,73
00330:  DATA 68,20
00332:  DATA 74,69
00334:  DATA 6D,65
00336:  DATA 6F,75
00338:  DATA 74,0D
0033A:  DATA 0A,00
0033C:  DATA 66,6C
0033E:  DATA 61,73
00340:  DATA 68,20
00342:  DATA 34,6B
00344:  DATA 42,79
00346:  DATA 74,65
00348:  DATA 20,73
0034A:  DATA 75,62
0034C:  DATA 73,65
0034E:  DATA 63,74
00350:  DATA 6F,72
00352:  DATA 20,65
00354:  DATA 72,61
00356:  DATA 73,65
00358:  DATA 20,63
0035A:  DATA 6F,6D
0035C:  DATA 70,6C
0035E:  DATA 65,74
00360:  DATA 65,0D
00362:  DATA 0A,00
00364:  DATA 66,6C
00366:  DATA 61,73
00368:  DATA 68,20
0036A:  DATA 74,69
0036C:  DATA 6D,65
0036E:  DATA 6F,75
00370:  DATA 74,0D
00372:  DATA 0A,00
00374:  DATA 66,6C
00376:  DATA 61,73
00378:  DATA 68,20
0037A:  DATA 77,72
0037C:  DATA 69,74
0037E:  DATA 65,20
00380:  DATA 63,6F
00382:  DATA 6D,70
00384:  DATA 6C,65
00386:  DATA 74,65
00388:  DATA 0D,0A
0038A:  DATA 00,00
0038C:  DATA 66,6C
0038E:  DATA 61,73
00390:  DATA 68,20
00392:  DATA 74,69
00394:  DATA 6D,65
00396:  DATA 6F,75
00398:  DATA 74,0D
0039A:  DATA 0A,00
0039C:  DATA 66,6C
0039E:  DATA 61,73
003A0:  DATA 68,20
003A2:  DATA 77,72
003A4:  DATA 69,74
003A6:  DATA 65,20
003A8:  DATA 63,6F
003AA:  DATA 6D,70
003AC:  DATA 6C,65
003AE:  DATA 74,65
003B0:  DATA 0D,0A
003B2:  DATA 00,00
003B4:  DATA 53,74
003B6:  DATA 61,72
003B8:  DATA 74,20
003BA:  DATA 6D,61
003BC:  DATA 6B,65
003BE:  DATA 5F,72
003C0:  DATA 65,63
003C2:  DATA 65,69
003C4:  DATA 76,65
003C6:  DATA 5F,63
003C8:  DATA 6F,6D
003CA:  DATA 6D,61
003CC:  DATA 6E,64
003CE:  DATA 0D,0A
003D0:  DATA 09,2D
003D2:  DATA 3E,20
003D4:  DATA 00,00
003D6:  DATA 63,6F
003D8:  DATA 6E,74
003DA:  DATA 65,6E
003DC:  DATA 74,3A
003DE:  DATA 20,00
003E0:  DATA 45,6E
003E2:  DATA 64,20
003E4:  DATA 6D,61
003E6:  DATA 6B,65
003E8:  DATA 5F,72
003EA:  DATA 65,63
003EC:  DATA 69,76
003EE:  DATA 65,5F
003F0:  DATA 63,6F
003F2:  DATA 6D,6D
003F4:  DATA 61,6E
003F6:  DATA 64,0D
003F8:  DATA 0A,00
003FA:  DATA 73,69
003FC:  DATA 67,6E
003FE:  DATA 61,6C
00400:  DATA 20,65
00402:  DATA 6E,64
00404:  DATA 20,77
00406:  DATA 69,74
00408:  DATA 68,20
0040A:  DATA 53,46
0040C:  DATA 44,0D
0040E:  DATA 0A,00
00410:  DATA 64,6F
00412:  DATA 6E,27
00414:  DATA 74,20
00416:  DATA 66,69
00418:  DATA 6E,64
0041A:  DATA 20,53
0041C:  DATA 46,44
0041E:  DATA 0D,0A
00420:  DATA 00,00
00422:  DATA 09,2D
00424:  DATA 3E,20
00426:  DATA 49,6E
00428:  DATA 76,61
0042A:  DATA 6C,69
0042C:  DATA 64,20
0042E:  DATA 46,72
00430:  DATA 61,6D
00432:  DATA 65,20
00434:  DATA 49,44
00436:  DATA 20,72
00438:  DATA 65,63
0043A:  DATA 65,69
0043C:  DATA 76,65
0043E:  DATA 64,3A
00440:  DATA 20,25
00442:  DATA 58,0D
00444:  DATA 0A,00
00446:  DATA 09,2D
00448:  DATA 3E,20
0044A:  DATA 43,52
0044C:  DATA 43,20
0044E:  DATA 65,72
00450:  DATA 72,6F
00452:  DATA 72,21
00454:  DATA 0D,0A
00456:  DATA 00,00
00458:  DATA 09,09
0045A:  DATA 2D,3E
0045C:  DATA 20,72
0045E:  DATA 65,63
00460:  DATA 65,69
00462:  DATA 76,65
00464:  DATA 64,20
00466:  DATA 43,52
00468:  DATA 43,3A
0046A:  DATA 20,25
0046C:  DATA 58,0D
0046E:  DATA 0A,00
00470:  DATA 09,09
00472:  DATA 20,20
00474:  DATA 20,63
00476:  DATA 6F,6C
00478:  DATA 6C,65
0047A:  DATA 63,74
0047C:  DATA 20,43
0047E:  DATA 52,43
00480:  DATA 20,3A
00482:  DATA 20,25
00484:  DATA 58,0D
00486:  DATA 0A,00
00488:  DATA 09,2D
0048A:  DATA 3E,20
0048C:  DATA 49,6E
0048E:  DATA 76,61
00490:  DATA 6C,69
00492:  DATA 64,20
00494:  DATA 64,65
00496:  DATA 76,69
00498:  DATA 63,65
0049A:  DATA 20,49
0049C:  DATA 44,20
0049E:  DATA 72,65
004A0:  DATA 63,65
004A2:  DATA 69,76
004A4:  DATA 65,64
004A6:  DATA 0D,0A
004A8:  DATA 00,00
004AA:  DATA 09,09
004AC:  DATA 2D,3E
004AE:  DATA 20,72
004B0:  DATA 65,63
004B2:  DATA 65,69
004B4:  DATA 76,65
004B6:  DATA 64,3A
004B8:  DATA 20,20
004BA:  DATA 20,20
004BC:  DATA 20,25
004BE:  DATA 58,0D
004C0:  DATA 0A,00
004C2:  DATA 09,09
004C4:  DATA 20,20
004C6:  DATA 20,4D
004C8:  DATA 79,20
004CA:  DATA 64,65
004CC:  DATA 76,69
004CE:  DATA 63,65
004D0:  DATA 20,49
004D2:  DATA 44,3A
004D4:  DATA 20,25
004D6:  DATA 58,0D
004D8:  DATA 0A,00
004DA:  DATA 54,72
004DC:  DATA 61,6E
004DE:  DATA 73,69
004E0:  DATA 74,20
004E2:  DATA 63,6F
004E4:  DATA 6D,6D
004E6:  DATA 61,6E
004E8:  DATA 64,0D
004EA:  DATA 0A,09
004EC:  DATA 2D,3E
004EE:  DATA 20,00
004F0:  DATA 21,21
004F2:  DATA 21,6F
004F4:  DATA 76,65
004F6:  DATA 72,66
004F8:  DATA 6C,6F
004FA:  DATA 77,20
004FC:  DATA 65,78
004FE:  DATA 65,63
00500:  DATA 75,74
00502:  DATA 65,64
00504:  DATA 5F,6D
00506:  DATA 69,73
00508:  DATA 73,69
0050A:  DATA 6F,6E
0050C:  DATA 20,6C
0050E:  DATA 69,73
00510:  DATA 74,0D
00512:  DATA 0A,00
00514:  DATA 53,74
00516:  DATA 61,72
00518:  DATA 74,20
0051A:  DATA 53,4D
0051C:  DATA 46,20
0051E:  DATA 75,73
00520:  DATA 69,6E
00522:  DATA 67,20
00524:  DATA 72,65
00526:  DATA 71,65
00528:  DATA 73,74
0052A:  DATA 20,73
0052C:  DATA 65,61
0052E:  DATA 71,75
00530:  DATA 65,6E
00532:  DATA 63,65
00534:  DATA 0D,0A
00536:  DATA 00,00
00538:  DATA 45,72
0053A:  DATA 72,6F
0053C:  DATA 72,21
0053E:  DATA 20,52
00540:  DATA 65,63
00542:  DATA 65,69
00544:  DATA 76,69
00546:  DATA 6E,67
00548:  DATA 20,63
0054A:  DATA 6F,6D
0054C:  DATA 6D,61
0054E:  DATA 6E,64
00550:  DATA 20,69
00552:  DATA 6E,63
00554:  DATA 6F,6E
00556:  DATA 73,69
00558:  DATA 73,74
0055A:  DATA 65,6E
0055C:  DATA 74,20
0055E:  DATA 77,69
00560:  DATA 74,68
00562:  DATA 20,74
00564:  DATA 68,65
00566:  DATA 20,64
00568:  DATA 65,73
0056A:  DATA 69,67
0056C:  DATA 6E,0D
0056E:  DATA 0A,00
00570:  DATA 53,4D
00572:  DATA 46,20
00574:  DATA 75,73
00576:  DATA 65,20
00578:  DATA 72,65
0057A:  DATA 71,75
0057C:  DATA 65,73
0057E:  DATA 74,20
00580:  DATA 61,6C
00582:  DATA 6C,6F
00584:  DATA 77,65
00586:  DATA 64,0D
00588:  DATA 0A,00
0058A:  DATA 53,4D
0058C:  DATA 46,20
0058E:  DATA 75,73
00590:  DATA 65,20
00592:  DATA 72,65
00594:  DATA 71,75
00596:  DATA 65,73
00598:  DATA 74,20
0059A:  DATA 64,65
0059C:  DATA 6E,79
0059E:  DATA 65,64
005A0:  DATA 0D,0A
005A2:  DATA 00,00
005A4:  DATA 52,65
005A6:  DATA 74,72
005A8:  DATA 79,20
005AA:  DATA 72,65
005AC:  DATA 71,75
005AE:  DATA 65,73
005B0:  DATA 74,20
005B2:  DATA 74,6F
005B4:  DATA 20,42
005B6:  DATA 4F,53
005B8:  DATA 53,20
005BA:  DATA 50,49
005BC:  DATA 43,0D
005BE:  DATA 0A,00
005C0:  DATA 45,72
005C2:  DATA 72,6F
005C4:  DATA 72,21
005C6:  DATA 20,52
005C8:  DATA 65,63
005CA:  DATA 65,69
005CC:  DATA 76,69
005CE:  DATA 6E,67
005D0:  DATA 20,63
005D2:  DATA 6F,6D
005D4:  DATA 6D,61
005D6:  DATA 6E,64
005D8:  DATA 20,69
005DA:  DATA 6E,63
005DC:  DATA 6F,6E
005DE:  DATA 73,69
005E0:  DATA 73,74
005E2:  DATA 65,6E
005E4:  DATA 74,20
005E6:  DATA 77,69
005E8:  DATA 74,68
005EA:  DATA 20,74
005EC:  DATA 68,65
005EE:  DATA 20,64
005F0:  DATA 65,73
005F2:  DATA 69,67
005F4:  DATA 6E,0D
005F6:  DATA 0A,00
005F8:  DATA 45,6E
005FA:  DATA 64,20
005FC:  DATA 53,4D
005FE:  DATA 46,20
00600:  DATA 75,73
00602:  DATA 69,6E
00604:  DATA 67,20
00606:  DATA 72,65
00608:  DATA 71,65
0060A:  DATA 73,74
0060C:  DATA 20,73
0060E:  DATA 65,61
00610:  DATA 71,75
00612:  DATA 65,6E
00614:  DATA 63,65
00616:  DATA 0D,0A
00618:  DATA 00,00
0061A:  DATA 0D,0A
0061C:  DATA 54,68
0061E:  DATA 69,73
00620:  DATA 20,20
00622:  DATA 6D,69
00624:  DATA 73,73
00626:  DATA 69,6F
00628:  DATA 6E,20
0062A:  DATA 69,73
0062C:  DATA 20,65
0062E:  DATA 78,65
00630:  DATA 63,75
00632:  DATA 74,65
00634:  DATA 64,0D
00636:  DATA 0A,09
00638:  DATA 2D,3E
0063A:  DATA 20,30
0063C:  DATA 78,25
0063E:  DATA 64,0D
00640:  DATA 0A,00
00642:  DATA 0D,0A
00644:  DATA 5F,5F
00646:  DATA 5F,5F
00648:  DATA 5F,5F
0064A:  DATA 5F,5F
0064C:  DATA 5F,5F
0064E:  DATA 5F,5F
00650:  DATA 5F,5F
00652:  DATA 5F,5F
00654:  DATA 5F,5F
00656:  DATA 5F,5F
00658:  DATA 5F,5F
0065A:  DATA 5F,5F
0065C:  DATA 5F,5F
0065E:  DATA 5F,5F
00660:  DATA 5F,5F
00662:  DATA 0D,0A
00664:  DATA 5F,5F
00666:  DATA 5F,5F
00668:  DATA 5F,53
0066A:  DATA 74,61
0066C:  DATA 72,74
0066E:  DATA 20,65
00670:  DATA 78,65
00672:  DATA 63,75
00674:  DATA 74,65
00676:  DATA 5F,6D
00678:  DATA 69,73
0067A:  DATA 73,69
0067C:  DATA 6F,6E
0067E:  DATA 5F,5F
00680:  DATA 5F,5F
00682:  DATA 5F,0D
00684:  DATA 0A,0D
00686:  DATA 0A,00
00688:  DATA 43,6F
0068A:  DATA 6D,6D
0068C:  DATA 61,6E
0068E:  DATA 64,20
00690:  DATA 49,44
00692:  DATA 3A,20
00694:  DATA 25,58
00696:  DATA 0D,0A
00698:  DATA 0D,0A
0069A:  DATA 00,00
0069C:  DATA 09,09
0069E:  DATA 2D,3E
006A0:  DATA 20,49
006A2:  DATA 6E,76
006A4:  DATA 61,6C
006A6:  DATA 69,64
006A8:  DATA 20,43
006AA:  DATA 4D,44
006AC:  DATA 20,49
006AE:  DATA 44,21
006B0:  DATA 0D,0A
006B2:  DATA 00,00
006B4:  DATA 0D,0A
006B6:  DATA 5F,5F
006B8:  DATA 5F,5F
006BA:  DATA 5F,5F
006BC:  DATA 45,6E
006BE:  DATA 64,20
006C0:  DATA 65,78
006C2:  DATA 65,63
006C4:  DATA 75,74
006C6:  DATA 65,5F
006C8:  DATA 6D,69
006CA:  DATA 73,73
006CC:  DATA 69,6F
006CE:  DATA 6E,5F
006D0:  DATA 5F,5F
006D2:  DATA 5F,5F
006D4:  DATA 5F,0D
006D6:  DATA 0A,5F
006D8:  DATA 5F,5F
006DA:  DATA 5F,5F
006DC:  DATA 5F,5F
006DE:  DATA 5F,5F
006E0:  DATA 5F,5F
006E2:  DATA 5F,5F
006E4:  DATA 5F,5F
006E6:  DATA 5F,5F
006E8:  DATA 5F,5F
006EA:  DATA 5F,5F
006EC:  DATA 5F,5F
006EE:  DATA 5F,5F
006F0:  DATA 5F,5F
006F2:  DATA 5F,5F
006F4:  DATA 5F,5F
006F6:  DATA 0D,0A
006F8:  DATA 00,00
006FA:  DATA 53,74
006FC:  DATA 61,72
006FE:  DATA 74,20
00700:  DATA 65,78
00702:  DATA 61,6D
00704:  DATA 70,6C
00706:  DATA 65,5F
00708:  DATA 30,30
0070A:  DATA 0D,0A
0070C:  DATA 00,00
0070E:  DATA 70,61
00710:  DATA 72,61
00712:  DATA 6D,65
00714:  DATA 74,65
00716:  DATA 72,20
00718:  DATA 3A,20
0071A:  DATA 00,00
0071C:  DATA 28,54
0071E:  DATA 68,69
00720:  DATA 73,20
00722:  DATA 6D,69
00724:  DATA 73,73
00726:  DATA 69,6F
00728:  DATA 6E,20
0072A:  DATA 63,61
0072C:  DATA 6E,20
0072E:  DATA 65,78
00730:  DATA 65,63
00732:  DATA 75,74
00734:  DATA 65,20
00736:  DATA 6D,61
00738:  DATA 6E,79
0073A:  DATA 20,74
0073C:  DATA 69,6D
0073E:  DATA 65,20
00740:  DATA 61,73
00742:  DATA 20,79
00744:  DATA 6F,75
00746:  DATA 20,77
00748:  DATA 61,6E
0074A:  DATA 74,29
0074C:  DATA 0D,0A
0074E:  DATA 00,00
00750:  DATA 65,78
00752:  DATA 65,63
00754:  DATA 75,74
00756:  DATA 69,6E
00758:  DATA 67,00
0075A:  DATA 2E,0D
0075C:  DATA 0A,00
0075E:  DATA 6F,72
00760:  DATA 64,65
00762:  DATA 72,20
00764:  DATA 43,6F
00766:  DATA 70,79
00768:  DATA 20,73
0076A:  DATA 6D,66
0076C:  DATA 5F,64
0076E:  DATA 61,74
00770:  DATA 61,0D
00772:  DATA 0A,00
00774:  DATA 45,6E
00776:  DATA 64,20
00778:  DATA 65,78
0077A:  DATA 61,6D
0077C:  DATA 70,6C
0077E:  DATA 65,5F
00780:  DATA 30,30
00782:  DATA 0D,0A
00784:  DATA 00,00
00786:  DATA 53,74
00788:  DATA 61,72
0078A:  DATA 74,20
0078C:  DATA 65,78
0078E:  DATA 61,6D
00790:  DATA 70,6C
00792:  DATA 65,5F
00794:  DATA 30,31
00796:  DATA 0D,0A
00798:  DATA 00,00
0079A:  DATA 70,61
0079C:  DATA 72,61
0079E:  DATA 6D,65
007A0:  DATA 74,65
007A2:  DATA 72,20
007A4:  DATA 3A,20
007A6:  DATA 00,00
007A8:  DATA 54,68
007AA:  DATA 69,73
007AC:  DATA 20,6D
007AE:  DATA 69,73
007B0:  DATA 73,69
007B2:  DATA 6F,6E
007B4:  DATA 20,77
007B6:  DATA 61,69
007B8:  DATA 74,20
007BA:  DATA 66,6F
007BC:  DATA 72,20
007BE:  DATA 35,20
007C0:  DATA 73,65
007C2:  DATA 63,6F
007C4:  DATA 6E,64
007C6:  DATA 73,0D
007C8:  DATA 0A,00
007CA:  DATA 65,78
007CC:  DATA 65,63
007CE:  DATA 75,74
007D0:  DATA 69,6E
007D2:  DATA 67,00
007D4:  DATA 45,6E
007D6:  DATA 64,20
007D8:  DATA 65,78
007DA:  DATA 61,6D
007DC:  DATA 70,6C
007DE:  DATA 65,5F
007E0:  DATA 30,31
007E2:  DATA 0D,0A
007E4:  DATA 00,00
007E6:  DATA 53,74
007E8:  DATA 61,72
007EA:  DATA 74,20
007EC:  DATA 65,78
007EE:  DATA 61,6D
007F0:  DATA 70,6C
007F2:  DATA 65,5F
007F4:  DATA 30,32
007F6:  DATA 0D,0A
007F8:  DATA 00,00
007FA:  DATA 70,61
007FC:  DATA 72,61
007FE:  DATA 6D,65
00800:  DATA 74,65
00802:  DATA 72,20
00804:  DATA 3A,20
00806:  DATA 00,00
00808:  DATA 54,68
0080A:  DATA 69,73
0080C:  DATA 20,6D
0080E:  DATA 69,73
00810:  DATA 73,69
00812:  DATA 6F,6E
00814:  DATA 20,77
00816:  DATA 69,6C
00818:  DATA 6C,20
0081A:  DATA 66,69
0081C:  DATA 72,73
0081E:  DATA 74,20
00820:  DATA 61,63
00822:  DATA 63,65
00824:  DATA 73,73
00826:  DATA 20,73
00828:  DATA 6D,66
0082A:  DATA 20,61
0082C:  DATA 6E,64
0082E:  DATA 20,74
00830:  DATA 68,65
00832:  DATA 6E,20
00834:  DATA 77,61
00836:  DATA 69,74
00838:  DATA 20,66
0083A:  DATA 6F,72
0083C:  DATA 20,35
0083E:  DATA 20,73
00840:  DATA 65,63
00842:  DATA 6F,6E
00844:  DATA 64,73
00846:  DATA 0D,0A
00848:  DATA 00,00
0084A:  DATA 41,63
0084C:  DATA 63,65
0084E:  DATA 73,73
00850:  DATA 20,74
00852:  DATA 6F,20
00854:  DATA 53,4D
00856:  DATA 46,00
00858:  DATA 45,6E
0085A:  DATA 64,20
0085C:  DATA 75,73
0085E:  DATA 65,20
00860:  DATA 53,4D
00862:  DATA 46,0D
00864:  DATA 0A,00
00866:  DATA 77,61
00868:  DATA 69,74
0086A:  DATA 20,66
0086C:  DATA 6F,72
0086E:  DATA 20,31
00870:  DATA 30,20
00872:  DATA 73,65
00874:  DATA 63,6F
00876:  DATA 6E,6F
00878:  DATA 64,73
0087A:  DATA 20,28
0087C:  DATA 65,78
0087E:  DATA 65,63
00880:  DATA 20,6D
00882:  DATA 69,73
00884:  DATA 73,69
00886:  DATA 6F,6E
00888:  DATA 20,73
0088A:  DATA 69,6D
0088C:  DATA 29,0D
0088E:  DATA 0A,00
00890:  DATA 46,61
00892:  DATA 69,6C
00894:  DATA 75,72
00896:  DATA 65,20
00898:  DATA 74,6F
0089A:  DATA 20,41
0089C:  DATA 63,63
0089E:  DATA 65,73
008A0:  DATA 73,20
008A2:  DATA 74,6F
008A4:  DATA 20,53
008A6:  DATA 4D,46
008A8:  DATA 00,00
008AA:  DATA 45,6E
008AC:  DATA 64,20
008AE:  DATA 65,78
008B0:  DATA 61,6D
008B2:  DATA 70,6C
008B4:  DATA 65,5F
008B6:  DATA 30,32
008B8:  DATA 0D,0A
008BA:  DATA 00,00
008BC:  DATA 44,65
008BE:  DATA 73,74
008C0:  DATA 69,6E
008C2:  DATA 61,74
008C4:  DATA 69,6F
008C6:  DATA 6E,20
008C8:  DATA 61,64
008CA:  DATA 64,72
008CC:  DATA 65,73
008CE:  DATA 73,3A
008D0:  DATA 20,09
008D2:  DATA 30,78
008D4:  DATA 25,30
008D6:  DATA 38,4C
008D8:  DATA 58,0D
008DA:  DATA 0A,00
008DC:  DATA 53,6F
008DE:  DATA 75,72
008E0:  DATA 63,65
008E2:  DATA 20,61
008E4:  DATA 64,64
008E6:  DATA 72,65
008E8:  DATA 73,73
008EA:  DATA 3A,20
008EC:  DATA 09,30
008EE:  DATA 78,25
008F0:  DATA 30,38
008F2:  DATA 4C,58
008F4:  DATA 0D,0A
008F6:  DATA 00,00
008F8:  DATA 44,61
008FA:  DATA 74,61
008FC:  DATA 20,73
008FE:  DATA 69,7A
00900:  DATA 65,3A
00902:  DATA 20,09
00904:  DATA 09,20
00906:  DATA 20,25
00908:  DATA 30,38
0090A:  DATA 4C,58
0090C:  DATA 0D,0A
0090E:  DATA 00,00
00910:  DATA 43,6F
00912:  DATA 70,79
00914:  DATA 69,6E
00916:  DATA 67,2E
00918:  DATA 00,00
0091A:  DATA 2E,0D
0091C:  DATA 0A,00
0091E:  DATA 5F,5F
00920:  DATA 5F,5F
00922:  DATA 5F,5F
00924:  DATA 5F,5F
00926:  DATA 5F,45
00928:  DATA 6E,64
0092A:  DATA 20,63
0092C:  DATA 6F,70
0092E:  DATA 79,5F
00930:  DATA 64,61
00932:  DATA 74,61
00934:  DATA 5F,5F
00936:  DATA 5F,5F
00938:  DATA 5F,5F
0093A:  DATA 5F,5F
0093C:  DATA 5F,0D
0093E:  DATA 0A,5F
00940:  DATA 5F,5F
00942:  DATA 5F,5F
00944:  DATA 5F,5F
00946:  DATA 5F,5F
00948:  DATA 5F,5F
0094A:  DATA 5F,5F
0094C:  DATA 5F,5F
0094E:  DATA 5F,5F
00950:  DATA 5F,5F
00952:  DATA 5F,5F
00954:  DATA 5F,5F
00956:  DATA 5F,5F
00958:  DATA 5F,5F
0095A:  DATA 5F,5F
0095C:  DATA 5F,0D
0095E:  DATA 0A,0D
00960:  DATA 0A,00
00962:  DATA 53,74
00964:  DATA 61,72
00966:  DATA 74,20
00968:  DATA 73,65
0096A:  DATA 74,74
0096C:  DATA 69,6E
0096E:  DATA 67,0D
00970:  DATA 0A,00
00972:  DATA 45,6E
00974:  DATA 64,20
00976:  DATA 73,65
00978:  DATA 74,74
0097A:  DATA 69,6E
0097C:  DATA 67,0D
0097E:  DATA 0A,00
00980:  DATA 0D,0A
00982:  DATA 53,74
00984:  DATA 61,72
00986:  DATA 74,20
00988:  DATA 65,78
0098A:  DATA 65,63
0098C:  DATA 75,74
0098E:  DATA 65,5F
00990:  DATA 63,6F
00992:  DATA 6D,6D
00994:  DATA 61,6E
00996:  DATA 64,0D
00998:  DATA 0A,00
0099A:  DATA 09,2D
0099C:  DATA 3E,20
0099E:  DATA 55,70
009A0:  DATA 6C,69
009A2:  DATA 6E,6B
009A4:  DATA 20,63
009A6:  DATA 6F,6D
009A8:  DATA 6D,61
009AA:  DATA 6E,64
009AC:  DATA 0D,0A
009AE:  DATA 00,00
009B0:  DATA 09,20
009B2:  DATA 20,20
009B4:  DATA 54,72
009B6:  DATA 61,6E
009B8:  DATA 73,6D
009BA:  DATA 69,74
009BC:  DATA 20,41
009BE:  DATA 63,6B
009C0:  DATA 6E,6F
009C2:  DATA 6C,65
009C4:  DATA 67,64
009C6:  DATA 65,0D
009C8:  DATA 0A,00
009CA:  DATA 09,2D
009CC:  DATA 3E,20
009CE:  DATA 53,74
009D0:  DATA 61,74
009D2:  DATA 75,73
009D4:  DATA 20,63
009D6:  DATA 68,65
009D8:  DATA 63,6B
009DA:  DATA 0D,0A
009DC:  DATA 00,00
009DE:  DATA 09,09
009E0:  DATA 2D,3E
009E2:  DATA 20,4D
009E4:  DATA 79,20
009E6:  DATA 73,74
009E8:  DATA 61,74
009EA:  DATA 75,73
009EC:  DATA 20,69
009EE:  DATA 73,20
009F0:  DATA 25,64
009F2:  DATA 0D,0A
009F4:  DATA 00,00
009F6:  DATA 09,20
009F8:  DATA 20,20
009FA:  DATA 54,72
009FC:  DATA 61,6E
009FE:  DATA 73,6D
00A00:  DATA 69,74
00A02:  DATA 20,4D
00A04:  DATA 49,53
00A06:  DATA 20,4D
00A08:  DATA 43,55
00A0A:  DATA 20,53
00A0C:  DATA 74,61
00A0E:  DATA 74,75
00A10:  DATA 73,0D
00A12:  DATA 0A,00
00A14:  DATA 66,69
00A16:  DATA 6E,69
00A18:  DATA 73,68
00A1A:  DATA 65,64
00A1C:  DATA 20,69
00A1E:  DATA 6E,20
00A20:  DATA 73,74
00A22:  DATA 61,74
00A24:  DATA 75,73
00A26:  DATA 5F,63
00A28:  DATA 68,65
00A2A:  DATA 63,6B
00A2C:  DATA 0D,0A
00A2E:  DATA 00,00
00A30:  DATA 09,2D
00A32:  DATA 3E,20
00A34:  DATA 69,73
00A36:  DATA 20,53
00A38:  DATA 4D,46
00A3A:  DATA 20,61
00A3C:  DATA 76,61
00A3E:  DATA 69,6C
00A40:  DATA 61,62
00A42:  DATA 6C,65
00A44:  DATA 0D,0A
00A46:  DATA 00,00
00A48:  DATA 09,20
00A4A:  DATA 20,20
00A4C:  DATA 54,72
00A4E:  DATA 61,6E
00A50:  DATA 73,6D
00A52:  DATA 69,74
00A54:  DATA 20,41
00A56:  DATA 63,6B
00A58:  DATA 6E,6F
00A5A:  DATA 6C,65
00A5C:  DATA 67,64
00A5E:  DATA 65,0D
00A60:  DATA 0A,00
00A62:  DATA 09,09
00A64:  DATA 2D,3E
00A66:  DATA 20,61
00A68:  DATA 6C,6C
00A6A:  DATA 6F,77
00A6C:  DATA 64,0D
00A6E:  DATA 0A,00
00A70:  DATA 09,09
00A72:  DATA 2D,3E
00A74:  DATA 20,64
00A76:  DATA 65,6E
00A78:  DATA 79,65
00A7A:  DATA 64,0D
00A7C:  DATA 0A,00
00A7E:  DATA 0D,0A
00A80:  DATA 0D,0A
00A82:  DATA 00,00
00A84:  DATA 5F,5F
00A86:  DATA 5F,5F
00A88:  DATA 5F,5F
00A8A:  DATA 5F,5F
00A8C:  DATA 5F,5F
00A8E:  DATA 5F,53
00A90:  DATA 74,61
00A92:  DATA 72,74
00A94:  DATA 20,6D
00A96:  DATA 61,69
00A98:  DATA 6E,5F
00A9A:  DATA 5F,5F
00A9C:  DATA 5F,5F
00A9E:  DATA 5F,5F
00AA0:  DATA 5F,5F
00AA2:  DATA 5F,0D
00AA4:  DATA 0A,0D
00AA6:  DATA 0A,00
00AA8:  DATA 46,72
00AAA:  DATA 61,6D
00AAC:  DATA 65,49
00AAE:  DATA 44,3A
00AB0:  DATA 20,25
00AB2:  DATA 58,0D
00AB4:  DATA 0A,00
00AB6:  DATA 65,78
00AB8:  DATA 69,73
00ABA:  DATA 74,20
00ABC:  DATA 3A,20
00ABE:  DATA 25,64
00AC0:  DATA 0D,0A
00AC2:  DATA 00,00
00AC4:  DATA 63,6F
00AC6:  DATA 6E,74
00AC8:  DATA 65,6E
00ACA:  DATA 74,3A
00ACC:  DATA 20,00
00ACE:  DATA 0D,0A
00AD0:  DATA 0D,0A
00AD2:  DATA 3D,3D
00AD4:  DATA 3D,3D
00AD6:  DATA 3D,3D
00AD8:  DATA 0D,0A
00ADA:  DATA 0D,0A
00ADC:  DATA 46,69
00ADE:  DATA 6E,69
00AE0:  DATA 73,68
00AE2:  DATA 65,64
00AE4:  DATA 20,70
00AE6:  DATA 72,6F
00AE8:  DATA 63,65
00AEA:  DATA 73,73
00AEC:  DATA 2E,0D
00AEE:  DATA 0A,57
00AF0:  DATA 61,69
00AF2:  DATA 74,20
00AF4:  DATA 66,6F
00AF6:  DATA 72,20
00AF8:  DATA 42,4F
00AFA:  DATA 53,53
00AFC:  DATA 20,50
00AFE:  DATA 49,43
00B00:  DATA 20,74
00B02:  DATA 75,72
00B04:  DATA 6E,20
00B06:  DATA 6F,66
00B08:  DATA 66,20
00B0A:  DATA 6D,65
00B0C:  DATA 00,00
00B0E:  DATA 45,6E
00B10:  DATA 64,20
00B12:  DATA 6D,61
00B14:  DATA 69,6E
00B16:  DATA 0D,0A
00B18:  DATA 00,00
*
00B7C:  MOVLB  1
00B7E:  BTFSC  xDF.7
00B80:  BRA    0BA6
00B82:  MOVLW  0F
00B84:  MOVWF  00
00B86:  SWAPF  xDE,W
00B88:  ANDWF  00,F
00B8A:  MOVLW  0A
00B8C:  SUBWF  00,W
00B8E:  BC    0B96
00B90:  MOVLW  30
00B92:  ADDWF  00,F
00B94:  BRA    0B9A
00B96:  MOVF   xDF,W
00B98:  ADDWF  00,F
00B9A:  MOVF   00,W
00B9C:  BTFSS  FA4.4
00B9E:  BRA    0B9C
00BA0:  MOVLB  F
00BA2:  MOVWF  x1D
00BA4:  MOVLB  1
00BA6:  MOVLW  0F
00BA8:  ANDWF  xDE,F
00BAA:  MOVLW  0A
00BAC:  SUBWF  xDE,W
00BAE:  BC    0BB4
00BB0:  MOVLW  30
00BB2:  BRA    0BB8
00BB4:  BCF    xDF.7
00BB6:  MOVF   xDF,W
00BB8:  ADDWF  xDE,F
00BBA:  MOVF   xDE,W
00BBC:  BTFSS  FA4.4
00BBE:  BRA    0BBC
00BC0:  MOVLB  F
00BC2:  MOVWF  x1D
00BC4:  MOVLB  0
00BC6:  RETURN 0
*
00C58:  TBLRD*+
00C5A:  MOVFF  FF6,1DF
00C5E:  MOVFF  FF7,1E0
00C62:  MOVFF  FF8,1E1
00C66:  MOVF   FF5,W
00C68:  BTFSS  FA4.4
00C6A:  BRA    0C68
00C6C:  MOVLB  F
00C6E:  MOVWF  x1D
00C70:  MOVFF  1DF,FF6
00C74:  MOVFF  1E0,FF7
00C78:  MOVFF  1E1,FF8
00C7C:  MOVLB  1
00C7E:  DECFSZ xDE,F
00C80:  BRA    0C84
00C82:  BRA    0C88
00C84:  MOVLB  0
00C86:  BRA    0C58
00C88:  MOVLB  0
00C8A:  RETURN 0
*
0113A:  MOVLB  1
0113C:  MOVF   x5D,W
0113E:  CLRF   01
01140:  SUBWF  x5C,W
01142:  BC    114A
01144:  MOVFF  15C,00
01148:  BRA    1162
0114A:  CLRF   00
0114C:  MOVLW  08
0114E:  MOVWF  x5E
01150:  RLCF   x5C,F
01152:  RLCF   00,F
01154:  MOVF   x5D,W
01156:  SUBWF  00,W
01158:  BTFSC  FD8.0
0115A:  MOVWF  00
0115C:  RLCF   01,F
0115E:  DECFSZ x5E,F
01160:  BRA    1150
01162:  MOVLB  0
01164:  RETURN 0
01166:  MOVLW  20
01168:  MOVLB  1
0116A:  BTFSS  x57.4
0116C:  MOVLW  30
0116E:  MOVWF  x58
01170:  MOVFF  156,00
01174:  BTFSS  00.7
01176:  BRA    1188
01178:  COMF   00,F
0117A:  INCF   00,F
0117C:  MOVFF  00,156
01180:  MOVLW  2D
01182:  MOVWF  x58
01184:  BSF    x57.7
01186:  BSF    x57.0
01188:  MOVF   01,W
0118A:  MOVFF  156,15C
0118E:  MOVLW  64
01190:  MOVWF  x5D
01192:  MOVLB  0
01194:  RCALL  113A
01196:  MOVFF  00,156
0119A:  MOVLW  30
0119C:  ADDWF  01,W
0119E:  MOVLB  1
011A0:  MOVWF  x59
011A2:  MOVFF  156,15C
011A6:  MOVLW  0A
011A8:  MOVWF  x5D
011AA:  MOVLB  0
011AC:  RCALL  113A
011AE:  MOVLW  30
011B0:  ADDWF  00,W
011B2:  MOVLB  1
011B4:  MOVWF  x5B
011B6:  MOVLW  30
011B8:  ADDWF  01,W
011BA:  MOVWF  x5A
011BC:  MOVFF  158,00
011C0:  MOVLW  30
011C2:  SUBWF  x59,W
011C4:  BZ    11CE
011C6:  BSF    x57.1
011C8:  BTFSC  x57.7
011CA:  BSF    x57.2
011CC:  BRA    11F2
011CE:  MOVFF  158,159
011D2:  MOVLW  20
011D4:  MOVWF  x58
011D6:  MOVLW  30
011D8:  SUBWF  x5A,W
011DA:  BZ    11E4
011DC:  BSF    x57.0
011DE:  BTFSC  x57.7
011E0:  BSF    x57.1
011E2:  BRA    11F2
011E4:  BTFSS  FD8.2
011E6:  BSF    x57.0
011E8:  BNZ   11F2
011EA:  MOVFF  159,15A
011EE:  MOVLW  20
011F0:  MOVWF  x59
011F2:  BTFSC  x57.2
011F4:  BRA    1200
011F6:  BTFSC  x57.1
011F8:  BRA    120C
011FA:  BTFSC  x57.0
011FC:  BRA    1218
011FE:  BRA    1224
01200:  MOVF   x58,W
01202:  BTFSS  FA4.4
01204:  BRA    1202
01206:  MOVLB  F
01208:  MOVWF  x1D
0120A:  MOVLB  1
0120C:  MOVF   x59,W
0120E:  BTFSS  FA4.4
01210:  BRA    120E
01212:  MOVLB  F
01214:  MOVWF  x1D
01216:  MOVLB  1
01218:  MOVF   x5A,W
0121A:  BTFSS  FA4.4
0121C:  BRA    121A
0121E:  MOVLB  F
01220:  MOVWF  x1D
01222:  MOVLB  1
01224:  MOVF   x5B,W
01226:  BTFSS  FA4.4
01228:  BRA    1226
0122A:  MOVLB  F
0122C:  MOVWF  x1D
0122E:  MOVLB  0
01230:  RETURN 0
01232:  TSTFSZ 01
01234:  BRA    123C
01236:  TSTFSZ 02
01238:  BRA    123E
0123A:  BRA    124A
0123C:  INCF   02,F
0123E:  MOVFF  00,FEE
01242:  DECFSZ 01,F
01244:  BRA    123E
01246:  DECFSZ 02,F
01248:  BRA    123E
0124A:  GOTO   126A (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... // pin assignment etc
.................... #include "config.h"
.................... #ifndef CONFIG_H
.................... #define CONFIG_H
.................... 
.................... #device ADC=12
.................... 
.................... #FUSES NOWDT                    //No Watch Dog Timer
.................... 
.................... 
.................... // clock
.................... #use delay(crystal=16MHz, clock=16MHz)
*
014A8:  MOVLW  01
014AA:  MOVWF  FEA
014AC:  MOVLW  A6
014AE:  MOVWF  FE9
014B0:  MOVF   FEF,W
014B2:  BZ    14D0
014B4:  MOVLW  05
014B6:  MOVWF  01
014B8:  CLRF   00
014BA:  DECFSZ 00,F
014BC:  BRA    14BA
014BE:  DECFSZ 01,F
014C0:  BRA    14B8
014C2:  MOVLW  2E
014C4:  MOVWF  00
014C6:  DECFSZ 00,F
014C8:  BRA    14C6
014CA:  BRA    14CC
014CC:  DECFSZ FEF,F
014CE:  BRA    14B4
014D0:  RETURN 0
.................... 
.................... 
.................... // uart
.................... #pin_select U1TX = PIN_F7
.................... #pin_select U1RX = PIN_F5
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_F7,rcv=PIN_F5,bits=8,stream=BOSS)
*
0127E:  BTFSS  F9E.4
01280:  BRA    127E
01282:  MOVWF  FAD
01284:  GOTO   12A8 (RETURN)
.................... 
.................... #pin_select U2TX = PIN_D3
.................... #pin_select U2RX = PIN_D2
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_D3,rcv=PIN_D2,bits=8,stream=PC)
.................... 
.................... #pin_select U3TX = PIN_E5
.................... #pin_select U3RX = PIN_E4
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_E5,rcv=PIN_E4,bits=8,stream=PORT3)
.................... 
.................... #pin_select U4TX = PIN_E3
.................... #pin_select U4RX = PIN_F2
.................... 
.................... #use rs232(baud=9600,parity=N,xmit=PIN_E3,rcv=PIN_F2,bits=8,stream=PORT4)
.................... 
.................... // spi
.................... #define SPI0_CS PIN_A2
.................... #use spi (MASTER, CLK = PIN_A3, DI = PIN_A0, DO = PIN_A1,BAUD=1000000, MODE=0, BITS=8, STREAM=MIS_FM_STREAM)
.................... 
.................... #define SPI1_CS PIN_B3
.................... #use spi (MASTER, CLK = PIN_B2, DI = PIN_B5, DO = PIN_B4,BAUD=1000000, MODE=0, BITS=8, STREAM=SMF_STREAM)
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #include "./lib/typedef_content.h"
.................... #ifndef TYPEDEF_CONTENT_H
.................... #define TYPEDEF_CONTENT_H
.................... 
.................... // there is used in main.c
.................... 
.................... typedef enum {
....................     EXECUTING_MISSION = 0x02,
....................     IDLE              = 0x03,
....................     SMF_USE_REQ       = 0x04,
....................     COPYING           = 0x05,
....................     FINISHED          = 0x06
.................... } MisMcuStatusContent;
.................... 
.................... 
.................... typedef enum {
....................     ALLOW = 0x00,
....................     DENY  = 0x01
.................... } IsSmfAvailableContent;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/value_status.h"
.................... #ifndef VALUE_STATUS_H
.................... #define VALUE_STATUS_H
.................... 
.................... // there is used in main.c and mission
.................... 
.................... volatile unsigned int16 duration_sec = 0;
.................... volatile int1 is_use_smf_req_in_mission = FALSE;
.................... volatile int8 status = IDLE;
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/timer.h"
.................... #ifndef TIMER_H
.................... #define TIMER_H
.................... 
.................... // __________ define _________
.................... 
.................... #define SEC_IN_A_DAY 86400
.................... 
.................... 
.................... // __________ values _________
.................... 
.................... volatile unsigned int32 subsec = 0, sec = 0; //dsec -> deci second (0.01 sec)
.................... volatile unsigned int16 day = 0;
.................... 
.................... 
.................... // __________ functions _________
.................... 
.................... #INT_TIMER0
.................... static void TIMER0_isr();
.................... 
.................... 
.................... #include "./src/timer.c"
.................... #INT_TIMER0
.................... static void TIMER0_isr(void)
.................... {
....................    // every 0.01 sec interrupts
....................    set_timer0(100);
*
000CA:  CLRF   FD7
000CC:  MOVLW  64
000CE:  MOVWF  FD6
000D0:  NOP   
.................... 
....................    if (++subsec >= 100)
000D2:  MOVLW  01
000D4:  ADDWF  20,F
000D6:  BTFSC  FD8.0
000D8:  INCF   21,F
000DA:  BTFSC  FD8.2
000DC:  INCF   22,F
000DE:  BTFSC  FD8.2
000E0:  INCF   23,F
000E2:  MOVF   23,F
000E4:  BNZ   00F4
000E6:  MOVF   22,F
000E8:  BNZ   00F4
000EA:  MOVF   21,F
000EC:  BNZ   00F4
000EE:  MOVF   20,W
000F0:  SUBLW  63
000F2:  BC    0140
....................    {
....................       subsec = 0;
000F4:  CLRF   23
000F6:  CLRF   22
000F8:  CLRF   21
000FA:  CLRF   20
....................       sec++;
000FC:  MOVLW  01
000FE:  ADDWF  24,F
00100:  BTFSC  FD8.0
00102:  INCF   25,F
00104:  BTFSC  FD8.2
00106:  INCF   26,F
00108:  BTFSC  FD8.2
0010A:  INCF   27,F
.................... 
....................       if (sec >= SEC_IN_A_DAY)
0010C:  MOVF   27,F
0010E:  BNZ   012A
00110:  MOVF   26,W
00112:  SUBLW  00
00114:  BC    0140
00116:  XORLW  FF
00118:  BNZ   012A
0011A:  MOVF   25,W
0011C:  SUBLW  50
0011E:  BC    0140
00120:  XORLW  FF
00122:  BNZ   012A
00124:  MOVF   24,W
00126:  SUBLW  7F
00128:  BC    0140
....................       {
....................          sec -= SEC_IN_A_DAY;
0012A:  MOVLW  80
0012C:  SUBWF  24,F
0012E:  MOVLW  51
00130:  SUBWFB 25,F
00132:  MOVLW  01
00134:  SUBWFB 26,F
00136:  MOVLW  00
00138:  SUBWFB 27,F
....................          day++;
0013A:  INCF   28,F
0013C:  BTFSC  FD8.2
0013E:  INCF   29,F
....................       }
....................    }
00140:  BCF    FF2.2
00142:  GOTO   0074
.................... }
.................... 
.................... void setup_timer()
.................... {
....................    setup_timer_0(T0_INTERNAL | T0_DIV_256 | RTCC_8_BIT);
*
00B1A:  MOVLW  D7
00B1C:  MOVWF  FD5
....................    enable_interrupts(INT_TIMER0);
00B1E:  BSF    FF2.5
00B20:  GOTO   0B56 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... #include "./lib/uart.h"
.................... #ifndef UART_H
.................... #define UART_H
.................... 
.................... // _________ defines ________________
.................... 
.................... #define RECEIVE_BUFFER_MAX 32
.................... 
.................... 
.................... // _____________ values _______________
.................... 
.................... volatile unsigned int8 boss_receive_buffer[RECEIVE_BUFFER_MAX] = {0x00};
.................... volatile int8 boss_receive_buffer_size = 0;
.................... 
.................... 
.................... // _______________ functions ___________
.................... 
.................... #INT_RDA
.................... static void RDA_isr(void);
.................... 
.................... void setup_uart_to_boss();
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size);
.................... 
.................... 
.................... #include "./src/uart.c"
.................... #INT_RDA
.................... static void RDA_isr(void)
.................... {
....................    if (!(status == EXECUTING_MISSION || status == COPYING) || is_use_smf_req_in_mission)
*
00174:  MOVF   1F,W
00176:  SUBLW  02
00178:  BZ    0180
0017A:  MOVF   1F,W
0017C:  SUBLW  05
0017E:  BNZ   0184
00180:  BTFSS  1E.0
00182:  BRA    01BA
....................    {
....................       if (boss_receive_buffer_size < RECEIVE_BUFFER_MAX)
00184:  MOVF   4A,W
00186:  SUBLW  1F
00188:  BNC   01A4
....................          boss_receive_buffer[boss_receive_buffer_size++] = fgetc(BOSS);
0018A:  MOVF   4A,W
0018C:  INCF   4A,F
0018E:  CLRF   03
00190:  ADDLW  2A
00192:  MOVWF  FE9
00194:  MOVLW  00
00196:  ADDWFC 03,W
00198:  MOVWF  FEA
0019A:  BTFSS  F9E.5
0019C:  BRA    019A
0019E:  MOVFF  FAE,FEF
001A2:  BRA    01BA
....................       else
....................       {
....................          fprintf(PC, "\r\nOverflow BOSS receive signal buffer!!!\r\n\r\n");
001A4:  MOVLW  C0
001A6:  MOVWF  FF6
001A8:  MOVLW  01
001AA:  MOVWF  FF7
001AC:  MOVLW  00
001AE:  MOVWF  FF8
001B0:  RCALL  0146
....................          boss_receive_buffer[RECEIVE_BUFFER_MAX-1] = fgetc(BOSS);
001B2:  BTFSS  F9E.5
001B4:  BRA    01B2
001B6:  MOVFF  FAE,49
....................       }
....................    }
001BA:  BCF    F9E.5
001BC:  GOTO   0074
.................... }
.................... 
.................... void setup_uart_to_boss()
.................... {
....................    enable_interrupts(INT_RDA);
*
00B24:  BSF    F9D.5
00B26:  GOTO   0B58 (RETURN)
.................... }
.................... 
.................... void clear_receive_signal(unsigned int8 receive_signal[], int8 *receive_signal_size)
.................... {
....................    memset(receive_signal, 0x00, *receive_signal_size);
*
0124E:  MOVFF  1A8,FEA
01252:  MOVFF  1A7,FE9
01256:  MOVFF  FEF,01
0125A:  MOVFF  1A6,FEA
0125E:  MOVFF  1A5,FE9
01262:  CLRF   00
01264:  CLRF   02
01266:  MOVLB  0
01268:  BRA    1232
....................    *receive_signal_size = 0;
0126A:  MOVFF  1A8,03
0126E:  MOVLB  1
01270:  MOVFF  1A7,FE9
01274:  MOVFF  03,FEA
01278:  CLRF   FEF
0127A:  MOVLB  0
0127C:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... // Missions
.................... #include "mission.h"
.................... #ifndef MISSION_H
.................... #define MISSION_H
.................... 
.................... #define PARAMETER_LENGTH 8
.................... 
.................... #include "./lib/smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "./src/smf_queue.c"
.................... void enqueue_smf_data(SmfDataStruct *data)
*
014D2:  MOVLW  01
014D4:  MOVLB  1
014D6:  ADDWF  x0E,W
014D8:  ANDLW  0F
014DA:  MOVWF  x74
.................... {   
....................    int8 next_tail = (smf_queue.smf_data_tail + 1) % SMF_DATA_SIZE;
.................... 
....................    if(next_tail == smf_queue.smf_data_head)
014DC:  MOVF   x0D,W
014DE:  SUBWF  x74,W
014E0:  BNZ   1504
....................       fprintf(PC, "SMF data list is full!!!\r\n");
014E2:  MOVLW  EE
014E4:  MOVWF  FF6
014E6:  MOVLW  01
014E8:  MOVWF  FF7
014EA:  MOVLW  00
014EC:  MOVWF  FF8
014EE:  CLRF   1B
014F0:  BTFSC  FF2.7
014F2:  BSF    1B.7
014F4:  BCF    FF2.7
014F6:  MOVLB  0
014F8:  CALL   0146
014FC:  BTFSC  1B.7
014FE:  BSF    FF2.7
01500:  BRA    1606
01502:  MOVLB  1
....................       
....................    else
....................    {
....................       smf_queue.smf_data[smf_queue.smf_data_tail].dest = data->dest;
01504:  MOVF   x0E,W
01506:  MULLW  0C
01508:  MOVF   FF3,W
0150A:  CLRF   x76
0150C:  MOVWF  x75
0150E:  MOVLW  04
01510:  ADDWF  x75,W
01512:  MOVWF  01
01514:  MOVLW  00
01516:  ADDWFC x76,W
01518:  MOVWF  03
0151A:  MOVF   01,W
0151C:  ADDLW  4D
0151E:  MOVWF  01
01520:  MOVLW  00
01522:  ADDWFC 03,F
01524:  MOVFF  01,175
01528:  MOVFF  03,176
0152C:  MOVLW  04
0152E:  ADDWF  x72,W
01530:  MOVWF  FE9
01532:  MOVLW  00
01534:  ADDWFC x73,W
01536:  MOVWF  FEA
01538:  MOVFF  FEF,00
0153C:  MOVFF  FEC,01
01540:  MOVFF  FEC,02
01544:  MOVFF  FEC,03
01548:  MOVFF  176,FEA
0154C:  MOVFF  175,FE9
01550:  MOVFF  00,FEF
01554:  MOVFF  01,FEC
01558:  MOVFF  02,FEC
0155C:  MOVFF  03,FEC
....................       smf_queue.smf_data[smf_queue.smf_data_tail].src = data->src;
01560:  MOVF   x0E,W
01562:  MULLW  0C
01564:  MOVF   FF3,W
01566:  CLRF   x76
01568:  MOVWF  x75
0156A:  MOVLW  4D
0156C:  ADDWF  x75,W
0156E:  MOVWF  01
01570:  MOVLW  00
01572:  ADDWFC x76,W
01574:  MOVFF  01,177
01578:  MOVFF  172,FE9
0157C:  MOVFF  173,FEA
01580:  MOVFF  FEF,00
01584:  MOVFF  FEC,01
01588:  MOVFF  FEC,02
0158C:  MOVFF  FEC,03
01590:  MOVWF  FEA
01592:  MOVFF  177,FE9
01596:  MOVFF  00,FEF
0159A:  MOVFF  01,FEC
0159E:  MOVFF  02,FEC
015A2:  MOVFF  03,FEC
....................       smf_queue.smf_data[smf_queue.smf_data_tail].size = data->size;
015A6:  MOVF   x0E,W
015A8:  MULLW  0C
015AA:  MOVF   FF3,W
015AC:  CLRF   x76
015AE:  MOVWF  x75
015B0:  MOVLW  08
015B2:  ADDWF  x75,W
015B4:  MOVWF  01
015B6:  MOVLW  00
015B8:  ADDWFC x76,W
015BA:  MOVWF  03
015BC:  MOVF   01,W
015BE:  ADDLW  4D
015C0:  MOVWF  01
015C2:  MOVLW  00
015C4:  ADDWFC 03,F
015C6:  MOVFF  01,175
015CA:  MOVFF  03,176
015CE:  MOVLW  08
015D0:  ADDWF  x72,W
015D2:  MOVWF  FE9
015D4:  MOVLW  00
015D6:  ADDWFC x73,W
015D8:  MOVWF  FEA
015DA:  MOVFF  FEF,00
015DE:  MOVFF  FEC,01
015E2:  MOVFF  FEC,02
015E6:  MOVFF  FEC,03
015EA:  MOVFF  176,FEA
015EE:  MOVFF  175,FE9
015F2:  MOVFF  00,FEF
015F6:  MOVFF  01,FEC
015FA:  MOVFF  02,FEC
015FE:  MOVFF  03,FEC
.................... 
....................       smf_queue.smf_data_tail = next_tail;
01602:  MOVFF  174,10E
01606:  MOVLB  0
....................    }
01608:  GOTO   179C (RETURN)
.................... }
.................... 
.................... SmfDataStruct *dequeue_smf_data()
.................... {
....................    if (smf_queue.smf_data_head == smf_queue.smf_data_tail)
*
01E10:  MOVLB  1
01E12:  MOVF   x0E,W
01E14:  SUBWF  x0D,W
01E16:  BNZ   1E42
....................    {
....................       fprintf(PC, "SMF data list is empty\r\n");
01E18:  MOVLW  0A
01E1A:  MOVWF  FF6
01E1C:  MOVLW  02
01E1E:  MOVWF  FF7
01E20:  MOVLW  00
01E22:  MOVWF  FF8
01E24:  CLRF   1B
01E26:  BTFSC  FF2.7
01E28:  BSF    1B.7
01E2A:  BCF    FF2.7
01E2C:  MOVLB  0
01E2E:  CALL   0146
01E32:  BTFSC  1B.7
01E34:  BSF    FF2.7
....................       return 0x00;
01E36:  MOVLW  00
01E38:  MOVWF  01
01E3A:  MOVWF  02
01E3C:  BRA    1E64
....................    }
01E3E:  BRA    1E64
01E40:  MOVLB  1
....................    else
....................    {
....................       int8 current_head = smf_queue.smf_data_head;
01E42:  MOVFF  10D,151
....................       smf_queue.smf_data_head = (smf_queue.smf_data_head + 1) % SMF_DATA_SIZE;
01E46:  MOVLW  01
01E48:  ADDWF  x0D,W
01E4A:  ANDLW  0F
01E4C:  MOVWF  x0D
....................       return &smf_queue.smf_data[current_head];
01E4E:  MOVF   x51,W
01E50:  MULLW  0C
01E52:  MOVF   FF3,W
01E54:  CLRF   03
01E56:  ADDLW  4D
01E58:  MOVWF  01
01E5A:  MOVLW  00
01E5C:  ADDWFC 03,F
01E5E:  MOVFF  03,02
01E62:  MOVLB  0
....................    }
01E64:  GOTO   1E72 (RETURN)
.................... }
.................... 
.................... int1 is_empty_smf_data(void)
.................... {
....................    return smf_queue.smf_data_head == smf_queue.smf_data_tail;
*
01DFC:  MOVLB  1
01DFE:  MOVF   x0E,W
01E00:  SUBWF  x0D,W
01E02:  BZ    1E08
01E04:  MOVLW  00
01E06:  BRA    1E0A
01E08:  MOVLW  01
01E0A:  MOVWF  01
01E0C:  MOVLB  0
01E0E:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "./lib/flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "./src/flash.c"
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////GDNS_226_FlashOperation.c////////////////////////////
.................... //////////////////////////////////ver 2.2//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////redefinition of spi communication///////////////////////
.................... //send multi bytes
.................... void spi_xfer_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM0,write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2,write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3,write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes then receive multi bytes 
.................... void spi_xfer_and_read_select_stream(Flash flash_stream, int8 *write_data, unsigned int16 write_amount, int8 *read_data, unsigned int32 read_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................       for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................          read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM0);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM1);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM2);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          for(unsigned int32 spi_rcv_num = 0;spi_rcv_num < read_amount;spi_rcv_num++)
....................             read_data[spi_rcv_num] = spi_xfer(FLASH_STREAM3);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... //send multi bytes(ex:cmd) then send other multi bytes(for write multi bytes) 
.................... void spi_xfer_two_datas_select_stream(Flash flash_stream, int8 *cmd_data, unsigned int8 cmd_amount, int8 *write_data, unsigned int16 write_amount){
....................    switch(flash_stream.spi_stream_id){
....................       case SPI_0:
....................       for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, cmd_data[spi_xfer_num]);
....................       for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................          spi_xfer(FLASH_STREAM0, write_data[spi_xfer_num]);
....................          break;
....................          
....................       case SPI_1:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM1, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_2:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM2, write_data[spi_xfer_num]);
....................          break;
....................    
....................       case SPI_3:
....................          for(unsigned int8 spi_xfer_num = 0;spi_xfer_num < cmd_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, cmd_data[spi_xfer_num]);
....................          for(unsigned int16 spi_xfer_num = 0;spi_xfer_num < write_amount;spi_xfer_num++)
....................             spi_xfer(FLASH_STREAM3, write_data[spi_xfer_num]);
....................          break;
....................          
....................       default:
....................          break;
....................    }
....................    return;
.................... }
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... 
.................... void flash_setting(Flash flash_stream){
....................    output_high(flash_stream.cs_pin);
.................... }
.................... 
.................... int8 status_register(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_STATUS_REGISTER;
....................    int8 status_reg;
....................    output_low(flash_stream.cs_pin);                                              //lower the CS PIN
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, &status_reg, 1);
....................    output_high(flash_stream.cs_pin);                                             //take CS PIN higher back
....................    #ifdef DEBUG
....................       if((status_reg & 0x01) == true)                                          //masking status bit   
....................          fprintf(DEBUG_PORT,"flash busy\n\r");
....................    #endif
....................    return status_reg;  
.................... }
.................... 
.................... //
.................... //->success:True,fail:false
.................... int8 read_id(Flash flash_stream){
....................    int8 flash_cmd = CMD_READ_ID;
....................    int8 chip_id[20];
....................    output_low(flash_stream.cs_pin);
....................    spi_xfer_and_read_select_stream(flash_stream, &flash_cmd, 1, chip_id, 20);
....................    output_high(flash_stream.cs_pin);
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"Read ID:");
....................       for(int8 print_counter = 0;print_counter < 20;print_counter++)
....................          fprintf(DEBUG_PORT,"%x ",chip_id[print_counter]);
....................       fprintf(DEBUG_PORT,"\r\n");
....................    #endif
....................    //chip id check
....................    if(chip_id[0] == 0x20){  
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"flash connect OK\r\n");
....................       #endif
....................       return true;
....................    }
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"flash not connect\r\n");
....................       #endif
....................       return false;
....................    }
.................... }
.................... 
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address){
.................... //!   #ifdef DEBUG
.................... //!      fprintf(DEBUG_PORT,"Sector Erase\r\n");
.................... //!   #endif
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL128ABA\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
.................... //!      #ifdef DEBUG
.................... //!         fprintf(DEBUG_PORT,"FLASH MODEL:MT25QL01GBBB\r\n");
.................... //!      #endif
....................       flash_cmd[0] = CMD_4BYTE_SECTOR_ERASE;
....................       flash_cmd[1] = (unsigned int8)((sector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((sector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((sector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((sector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){      //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash sector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_32KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                  //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 32kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 4);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_SUBSECTOR_4KB_ERASE;
....................       flash_cmd[1] = (unsigned int8)((subsector_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((subsector_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((subsector_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((subsector_address) & 0xff);       // 0x 00 00 00 _ _
....................       
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    else{
....................       #ifdef DEBUG
....................          fprintf(DEBUG_PORT,"error:flash model is invalid\r\n");
....................       #endif
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash 4kByte subsector erase complete\r\n");
....................    #endif
....................    return;
.................... }
....................    
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address){
....................    int8 read_data;
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, &read_data, 1);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return read_data;
.................... }
....................    
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................             
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 4, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_READ;
....................       flash_cmd[1] = (unsigned int8)((read_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((read_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((read_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((read_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_and_read_select_stream(flash_stream, flash_cmd, 5, read_data, read_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    return;
.................... }
....................    
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data)
.................... {
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[4] = write_data;
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 5);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[6];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_address) & 0xff);       // 0x 00 00 00 _ _
....................       flash_cmd[5] = write_data;
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_select_stream(flash_stream, flash_cmd, 6);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount){
....................    if(flash_stream.flash_model == MT25QL128ABA){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[4];
....................       
....................       flash_cmd[0] = CMD_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
.................... 
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 4, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    else if(flash_stream.flash_model == MT25QL01GBBB){
....................       int8 write_enable_cmd = CMD_WRITE_ENABLE;
....................       unsigned int8 flash_cmd[5];
....................       
....................       flash_cmd[0] = CMD_4BYTE_PAGE_PROGRAM;
....................       flash_cmd[1] = (unsigned int8)((write_start_address>>24) & 0xff);   // 0x _ _ 00 00 00
....................       flash_cmd[2] = (unsigned int8)((write_start_address>>16) & 0xff);   // 0x 00 _ _ 00 00
....................       flash_cmd[3] = (unsigned int8)((write_start_address>>8) & 0xff);    // 0x 00 00 _ _ 00
....................       flash_cmd[4] = (unsigned int8)((write_start_address) & 0xff);       // 0x 00 00 00 _ _
....................    
....................       //Write enable sequence
....................       output_low(flash_stream.cs_pin);
....................       spi_xfer_select_stream(flash_stream, &write_enable_cmd, 1);
....................       output_high(flash_stream.cs_pin);
....................       //Write enabled
....................       output_low(flash_stream.cs_pin);
....................       ///////////////////////////////////////////////////////////////////
....................       spi_xfer_two_datas_select_stream(flash_stream, flash_cmd, 5, write_data, write_amount);
....................       //////////////////////////////////////////////////////////////////
....................       delay_us(2);
....................       output_high(flash_stream.cs_pin);            //take CS PIN higher back
....................    }
....................    
....................    //wait process finished
....................    unsigned int8 timeout_counter = 0;
....................    while((status_register(flash_stream) & 0x01) == 1){                           //masking status bit
....................       if(timeout_counter > 10)
....................          delay_ms(200);
....................       else
....................          delay_ms(10);   
....................       
....................       if(timeout_counter > 100){
....................          #ifdef DEBUG
....................             fprintf(DEBUG_PORT,"flash timeout\r\n");
....................          #endif
....................          break;
....................       }  
....................       timeout_counter++;
....................    }
....................    #ifdef DEBUG
....................       fprintf(DEBUG_PORT,"flash write complete\r\n");
....................    #endif
....................    return;
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include "./lib/mission_tools.h"
.................... #ifndef MISSION_TOOLS_H
.................... #define MISSION_TOOLS_H
.................... 
.................... #include "communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... #ifndef COMMUNICATION_H
.................... #define COMMUNICATION_H
.................... 
.................... // __________ device IDs ______________
.................... 
.................... #define MAIN_PIC  0x00
.................... #define COM_PIC   0x01
.................... #define RESET_PIC 0x02
.................... #define FAB_PIC   0x03
.................... #define BOSS_PIC  0x04
.................... #define APRS_PIC  0x05
.................... #define CAM_MCU   0x06
.................... #define CHO_MCU   0x07
.................... #define NAKA_PIC  0x08
.................... #define SATO_PIC  0x09
.................... #define BHU_MCU   0x0A
.................... #define CIGS_PIC  0x0B
.................... 
.................... #define SELF_DEVICE_ID APRS_PIC // <- change to your device name
.................... 
.................... 
.................... // ____________ SFD ______________
.................... 
.................... #define SFD 0xAA
.................... 
.................... 
.................... // ____________ typedef _____________
.................... 
.................... typedef struct {
....................     int8 id;
....................     int8 length;
.................... } FrameID;
.................... 
.................... #define CONTENT_MAX 32
.................... typedef struct {
....................     int8 frame_id;
....................     unsigned int8 content[CONTENT_MAX];
....................     int8 size;
....................     int1 is_exist;
.................... } Command;
.................... 
.................... #include "./frame.h"
.................... #ifndef FRAME_CONTENT_H
.................... #define FRAME_CONTENT_H
.................... 
.................... 
.................... // __________ Receives _________
.................... 
.................... #define UPLINK_COMMAND        0x00
.................... #define STATUS_CHECK          0x01
.................... #define IS_SMF_AVAILABLE      0x02
.................... 
.................... #define UPLINK_COMMAND_LENGTH     9
.................... #define STATUS_CHECK_LENGTH       0
.................... #define IS_SMF_AVAILABLE_LENGTH   1
.................... 
.................... volatile FrameID frame_ids[] = {
....................    {UPLINK_COMMAND, UPLINK_COMMAND_LENGTH}, 
....................    {STATUS_CHECK, STATUS_CHECK_LENGTH}, 
....................    {IS_SMF_AVAILABLE, IS_SMF_AVAILABLE_LENGTH}
.................... };
.................... 
.................... 
.................... // __________ Transmits _____________
.................... 
.................... typedef enum {
....................    MIS_MCU_STATUS = 0x01,
....................    ACK = 0x0F
.................... } TransmitFrameId;
.................... 
.................... #endif
.................... 
.................... 
.................... // ______ Receive _______
.................... 
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id);
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size);
.................... 
.................... static int1 check_device_id(unsigned int8 device_id);
.................... 
.................... 
.................... // ______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size);
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size);
.................... 
.................... // ______ Common _________
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size);
.................... 
.................... #include "./src/communication.c"
.................... Command make_receive_command(unsigned int8 receive_signal[], int8 receive_signal_size)
.................... {
....................    Command command = {0, {0x00}, 0, FALSE};
*
00EC6:  MOVLB  1
00EC8:  CLRF   xAE
00ECA:  CLRF   xAF
00ECC:  CLRF   xB0
00ECE:  CLRF   xB1
00ED0:  CLRF   xB2
00ED2:  CLRF   xB3
00ED4:  CLRF   xB4
00ED6:  CLRF   xB5
00ED8:  CLRF   xB6
00EDA:  CLRF   xB7
00EDC:  CLRF   xB8
00EDE:  CLRF   xB9
00EE0:  CLRF   xBA
00EE2:  CLRF   xBB
00EE4:  CLRF   xBC
00EE6:  CLRF   xBD
00EE8:  CLRF   xBE
00EEA:  CLRF   xBF
00EEC:  CLRF   xC0
00EEE:  CLRF   xC1
00EF0:  CLRF   xC2
00EF2:  CLRF   xC3
00EF4:  CLRF   xC4
00EF6:  CLRF   xC5
00EF8:  CLRF   xC6
00EFA:  CLRF   xC7
00EFC:  CLRF   xC8
00EFE:  CLRF   xC9
00F00:  CLRF   xCA
00F02:  CLRF   xCB
00F04:  CLRF   xCC
00F06:  CLRF   xCD
00F08:  CLRF   xCE
00F0A:  CLRF   xCF
00F0C:  CLRF   xD0
....................    fprintf(PC, "Start make_receive_command\r\n\t-> ");
00F0E:  MOVLW  B4
00F10:  MOVWF  FF6
00F12:  MOVLW  03
00F14:  MOVWF  FF7
00F16:  MOVLW  00
00F18:  MOVWF  FF8
00F1A:  CLRF   1B
00F1C:  BTFSC  FF2.7
00F1E:  BSF    1B.7
00F20:  BCF    FF2.7
00F22:  MOVLB  0
00F24:  CALL   0146
00F28:  BTFSC  1B.7
00F2A:  BSF    FF2.7
....................    for (int8 i = 0; i < receive_signal_size; i++)
00F2C:  MOVLB  1
00F2E:  CLRF   xD1
00F30:  MOVF   xAD,W
00F32:  SUBWF  xD1,W
00F34:  BC    0F5E
....................       fprintf(PC, "%X ", receive_signal[i]);
00F36:  MOVF   xD1,W
00F38:  ADDWF  xAB,W
00F3A:  MOVWF  FE9
00F3C:  MOVLW  00
00F3E:  ADDWFC xAC,W
00F40:  MOVWF  FEA
00F42:  MOVFF  FEF,1DE
00F46:  MOVLW  37
00F48:  MOVWF  xDF
00F4A:  MOVLB  0
00F4C:  RCALL  0B7C
00F4E:  MOVLW  20
00F50:  BTFSS  FA4.4
00F52:  BRA    0F50
00F54:  MOVLB  F
00F56:  MOVWF  x1D
00F58:  MOVLB  1
00F5A:  INCF   xD1,F
00F5C:  BRA    0F30
....................    fprintf(PC, "\r\n");
00F5E:  MOVLW  0D
00F60:  BTFSS  FA4.4
00F62:  BRA    0F60
00F64:  MOVLB  F
00F66:  MOVWF  x1D
00F68:  MOVLW  0A
00F6A:  BTFSS  FA4.4
00F6C:  BRA    0F6A
00F6E:  MOVWF  x1D
.................... 
....................    int8 frame_start_position = trim_receive_signal_header(receive_signal, receive_signal_size);
00F70:  MOVFF  1AC,1DA
00F74:  MOVFF  1AB,1D9
00F78:  MOVFF  1AD,1DB
00F7C:  MOVLB  0
00F7E:  BRA    0BC8
00F80:  MOVFF  01,1D2
....................    if (frame_start_position == -1)
00F84:  MOVLB  1
00F86:  MOVF   xD2,W
00F88:  SUBLW  FF
00F8A:  BNZ   0F96
....................       return command;
00F8C:  MOVLW  AE
00F8E:  MOVWF  01
00F90:  MOVLW  01
00F92:  MOVWF  02
00F94:  BRA    10FC
....................       
....................    unsigned int8 *frame = &receive_signal[frame_start_position];
00F96:  MOVF   xD2,W
00F98:  ADDWF  xAB,W
00F9A:  MOVWF  01
00F9C:  MOVLW  00
00F9E:  ADDWFC xAC,W
00FA0:  MOVFF  01,1D3
00FA4:  MOVWF  xD4
....................    fprintf(PC, "content: ");
00FA6:  MOVLW  D6
00FA8:  MOVWF  FF6
00FAA:  MOVLW  03
00FAC:  MOVWF  FF7
00FAE:  MOVLW  00
00FB0:  MOVWF  FF8
00FB2:  CLRF   1B
00FB4:  BTFSC  FF2.7
00FB6:  BSF    1B.7
00FB8:  BCF    FF2.7
00FBA:  MOVLB  0
00FBC:  CALL   0146
00FC0:  BTFSC  1B.7
00FC2:  BSF    FF2.7
....................    for(int i = 0; i < 8; i++)
00FC4:  MOVLB  1
00FC6:  CLRF   xD5
00FC8:  MOVF   xD5,W
00FCA:  SUBLW  07
00FCC:  BNC   0FF6
....................       fprintf(PC, "%X ", frame[i]);
00FCE:  MOVF   xD5,W
00FD0:  ADDWF  xD3,W
00FD2:  MOVWF  FE9
00FD4:  MOVLW  00
00FD6:  ADDWFC xD4,W
00FD8:  MOVWF  FEA
00FDA:  MOVFF  FEF,1DE
00FDE:  MOVLW  37
00FE0:  MOVWF  xDF
00FE2:  MOVLB  0
00FE4:  RCALL  0B7C
00FE6:  MOVLW  20
00FE8:  BTFSS  FA4.4
00FEA:  BRA    0FE8
00FEC:  MOVLB  F
00FEE:  MOVWF  x1D
00FF0:  MOVLB  1
00FF2:  INCF   xD5,F
00FF4:  BRA    0FC8
....................    fprintf(PC, "\r\n");
00FF6:  MOVLW  0D
00FF8:  BTFSS  FA4.4
00FFA:  BRA    0FF8
00FFC:  MOVLB  F
00FFE:  MOVWF  x1D
01000:  MOVLW  0A
01002:  BTFSS  FA4.4
01004:  BRA    1002
01006:  MOVWF  x1D
....................    
....................    int8 frame_id = frame[0] & 0x0F;
....................    int8 content_size = get_content_size(frame_id);
01008:  MOVLB  1
0100A:  MOVFF  1D3,FE9
0100E:  MOVFF  1D4,FEA
01012:  MOVF   FEF,W
01014:  ANDLW  0F
01016:  MOVWF  xD6
01018:  MOVFF  1D6,1D9
0101C:  MOVLB  0
0101E:  BRA    0C8C
01020:  MOVFF  01,1D7
....................    if (content_size == -1)
01024:  MOVLB  1
01026:  MOVF   xD7,W
01028:  SUBLW  FF
0102A:  BNZ   1036
....................       return command;
0102C:  MOVLW  AE
0102E:  MOVWF  01
01030:  MOVLW  01
01032:  MOVWF  02
01034:  BRA    10FC
....................       
....................    int8 receive_frame_size = receive_signal_size - frame_start_position;
01036:  MOVF   xD2,W
01038:  SUBWF  xAD,W
0103A:  MOVWF  xD8
....................    
....................    if (!check_crc(frame, receive_frame_size))
0103C:  MOVFF  1D4,1DA
01040:  MOVFF  1D3,1D9
01044:  MOVFF  1D8,1DB
01048:  MOVLB  0
0104A:  BRA    0D4E
0104C:  MOVF   01,F
0104E:  BNZ   105E
....................       return command;
01050:  MOVLW  AE
01052:  MOVWF  01
01054:  MOVLW  01
01056:  MOVWF  02
01058:  MOVLB  1
0105A:  BRA    10FC
0105C:  MOVLB  0
....................    
....................    if(!check_device_id((frame[0] & 0xF0) >> 4))
0105E:  MOVLB  1
01060:  MOVFF  1D3,FE9
01064:  MOVFF  1D4,FEA
01068:  MOVF   FEF,W
0106A:  ANDLW  F0
0106C:  MOVWF  00
0106E:  SWAPF  00,W
01070:  MOVWF  xD9
01072:  MOVLW  0F
01074:  ANDWF  xD9,F
01076:  MOVFF  1D9,1DA
0107A:  MOVLB  0
0107C:  BRA    0E20
0107E:  MOVF   01,F
01080:  BNZ   1090
....................       return command;
01082:  MOVLW  AE
01084:  MOVWF  01
01086:  MOVLW  01
01088:  MOVWF  02
0108A:  MOVLB  1
0108C:  BRA    10FC
0108E:  MOVLB  0
.................... 
....................    command.frame_id = frame_id;
01090:  MOVFF  1D6,1AE
....................    memcpy(command.content, &frame[1], receive_frame_size-2); // '2' is for Decive ID, Frame ID and CRC
01094:  MOVLW  01
01096:  MOVLB  1
01098:  ADDWF  xD3,W
0109A:  MOVWF  01
0109C:  MOVLW  00
0109E:  ADDWFC xD4,W
010A0:  MOVWF  03
010A2:  MOVFF  01,1D9
010A6:  MOVWF  xDA
010A8:  MOVLW  02
010AA:  SUBWF  xD8,W
010AC:  MOVWF  xDB
010AE:  MOVLW  01
010B0:  MOVWF  FEA
010B2:  MOVLW  AF
010B4:  MOVWF  FE9
010B6:  MOVFF  03,FE2
010BA:  MOVFF  01,FE1
010BE:  MOVF   xDB,W
010C0:  MOVWF  01
010C2:  BZ    10CC
010C4:  MOVFF  FE6,FEE
010C8:  DECFSZ 01,F
010CA:  BRA    10C4
....................    command.size = receive_frame_size-2;
010CC:  MOVLW  02
010CE:  SUBWF  xD8,W
010D0:  MOVWF  xCF
....................    command.is_exist = TRUE;
010D2:  BSF    xD0.0
....................    fprintf(PC, "End make_recive_command\r\n");
010D4:  MOVLW  E0
010D6:  MOVWF  FF6
010D8:  MOVLW  03
010DA:  MOVWF  FF7
010DC:  MOVLW  00
010DE:  MOVWF  FF8
010E0:  CLRF   1B
010E2:  BTFSC  FF2.7
010E4:  BSF    1B.7
010E6:  BCF    FF2.7
010E8:  MOVLB  0
010EA:  CALL   0146
010EE:  BTFSC  1B.7
010F0:  BSF    FF2.7
....................    return command;
010F2:  MOVLW  AE
010F4:  MOVWF  01
010F6:  MOVLW  01
010F8:  MOVWF  02
010FA:  MOVLB  1
010FC:  MOVLB  0
010FE:  RETURN 0
.................... }
.................... 
.................... static int8 trim_receive_signal_header(unsigned int8 receive_signal[], int8 receive_signal_size)
*
00BC8:  MOVLB  1
00BCA:  CLRF   xDC
.................... {
....................    int8 i = 0;
....................    for(i = 0; i < receive_signal_size-1; i++) // if SFD find 
00BCC:  CLRF   xDC
00BCE:  MOVLW  01
00BD0:  SUBWF  xDB,W
00BD2:  SUBWF  xDC,W
00BD4:  BC    0BF4
....................       if(receive_signal[i] == SFD)
00BD6:  MOVF   xDC,W
00BD8:  ADDWF  xD9,W
00BDA:  MOVWF  FE9
00BDC:  MOVLW  00
00BDE:  ADDWFC xDA,W
00BE0:  MOVWF  FEA
00BE2:  MOVF   FEF,W
00BE4:  SUBLW  AA
00BE6:  BNZ   0BF0
....................          return i+1;
00BE8:  MOVLW  01
00BEA:  ADDWF  xDC,W
00BEC:  MOVWF  01
00BEE:  BRA    0C52
00BF0:  INCF   xDC,F
00BF2:  BRA    0BCE
....................    if (receive_signal[i] == SFD)
00BF4:  MOVF   xDC,W
00BF6:  ADDWF  xD9,W
00BF8:  MOVWF  FE9
00BFA:  MOVLW  00
00BFC:  ADDWFC xDA,W
00BFE:  MOVWF  FEA
00C00:  MOVF   FEF,W
00C02:  SUBLW  AA
00C04:  BNZ   0C2E
....................    {
....................       fprintf(PC, "signal end with SFD\r\n");
00C06:  MOVLW  FA
00C08:  MOVWF  FF6
00C0A:  MOVLW  03
00C0C:  MOVWF  FF7
00C0E:  MOVLW  00
00C10:  MOVWF  FF8
00C12:  CLRF   1B
00C14:  BTFSC  FF2.7
00C16:  BSF    1B.7
00C18:  BCF    FF2.7
00C1A:  MOVLB  0
00C1C:  CALL   0146
00C20:  BTFSC  1B.7
00C22:  BSF    FF2.7
....................       return -1;
00C24:  MOVLW  FF
00C26:  MOVWF  01
00C28:  MOVLB  1
00C2A:  BRA    0C52
....................    }
00C2C:  BRA    0C52
....................    else
....................    {
....................       fprintf(PC, "don't find SFD\r\n");
00C2E:  MOVLW  10
00C30:  MOVWF  FF6
00C32:  MOVLW  04
00C34:  MOVWF  FF7
00C36:  MOVLW  00
00C38:  MOVWF  FF8
00C3A:  CLRF   1B
00C3C:  BTFSC  FF2.7
00C3E:  BSF    1B.7
00C40:  BCF    FF2.7
00C42:  MOVLB  0
00C44:  CALL   0146
00C48:  BTFSC  1B.7
00C4A:  BSF    FF2.7
....................       return -1;
00C4C:  MOVLW  FF
00C4E:  MOVWF  01
00C50:  MOVLB  1
....................    }
00C52:  MOVLB  0
00C54:  GOTO   0F80 (RETURN)
....................    
.................... }
.................... 
.................... static int8 get_content_size(unsigned int8 frame_id)
.................... {
....................    for (int i = 0; i < (sizeof(frame_ids) / sizeof(frame_ids[0])); i++)
*
00C8C:  MOVLB  1
00C8E:  CLRF   xDA
00C90:  MOVF   xDA,W
00C92:  SUBLW  02
00C94:  BNC   0CDA
....................       if (frame_id == frame_ids[i].id)
00C96:  BCF    FD8.0
00C98:  RLCF   xDA,W
00C9A:  CLRF   xDC
00C9C:  MOVWF  xDB
00C9E:  MOVLW  17
00CA0:  ADDWF  xDB,W
00CA2:  MOVWF  FE9
00CA4:  MOVLW  01
00CA6:  ADDWFC xDC,W
00CA8:  MOVWF  FEA
00CAA:  MOVF   FEF,W
00CAC:  SUBWF  xD9,W
00CAE:  BNZ   0CD6
....................          return frame_ids[i].length;
00CB0:  BCF    FD8.0
00CB2:  RLCF   xDA,W
00CB4:  CLRF   xDC
00CB6:  MOVWF  xDB
00CB8:  MOVLW  01
00CBA:  ADDWF  xDB,W
00CBC:  MOVWF  01
00CBE:  MOVLW  00
00CC0:  ADDWFC xDC,W
00CC2:  MOVWF  03
00CC4:  MOVF   01,W
00CC6:  ADDLW  17
00CC8:  MOVWF  FE9
00CCA:  MOVLW  01
00CCC:  ADDWFC 03,W
00CCE:  MOVWF  FEA
00CD0:  MOVFF  FEF,01
00CD4:  BRA    0D14
00CD6:  INCF   xDA,F
00CD8:  BRA    0C90
....................          
....................    fprintf(PC, "\t-> Invalid Frame ID received: %X\r\n", frame_id);
00CDA:  MOVLW  22
00CDC:  MOVWF  FF6
00CDE:  MOVLW  04
00CE0:  MOVWF  FF7
00CE2:  MOVLW  00
00CE4:  MOVWF  FF8
00CE6:  MOVLW  1F
00CE8:  MOVWF  xDE
00CEA:  MOVLB  0
00CEC:  RCALL  0C58
00CEE:  MOVFF  1D9,1DE
00CF2:  MOVLW  37
00CF4:  MOVLB  1
00CF6:  MOVWF  xDF
00CF8:  MOVLB  0
00CFA:  RCALL  0B7C
00CFC:  MOVLW  0D
00CFE:  BTFSS  FA4.4
00D00:  BRA    0CFE
00D02:  MOVLB  F
00D04:  MOVWF  x1D
00D06:  MOVLW  0A
00D08:  BTFSS  FA4.4
00D0A:  BRA    0D08
00D0C:  MOVWF  x1D
....................    return -1;
00D0E:  MOVLW  FF
00D10:  MOVWF  01
00D12:  MOVLB  1
00D14:  MOVLB  0
00D16:  GOTO   1020 (RETURN)
.................... }
.................... 
.................... static int1 check_crc(unsigned int8 frame[], int8 receive_frame_size)
*
00D4E:  MOVLW  01
00D50:  MOVLB  1
00D52:  SUBWF  xDB,W
00D54:  ADDWF  xD9,W
00D56:  MOVWF  FE9
00D58:  MOVLW  00
00D5A:  ADDWFC xDA,W
00D5C:  MOVWF  FEA
00D5E:  MOVFF  FEF,1DC
00D62:  MOVLW  01
00D64:  SUBWF  xDB,W
00D66:  MOVWF  xDE
00D68:  MOVFF  1DA,1E0
00D6C:  MOVFF  1D9,1DF
00D70:  MOVWF  xE1
00D72:  MOVLB  0
00D74:  RCALL  0D1A
00D76:  MOVFF  01,1DD
.................... {
....................    unsigned int8 received_crc = frame[receive_frame_size-1]; // '1' is for crc
....................    unsigned int8 collect_crc = calc_crc8(frame, receive_frame_size-1);
....................    if (received_crc == collect_crc)
00D7A:  MOVLB  1
00D7C:  MOVF   xDD,W
00D7E:  SUBWF  xDC,W
00D80:  BNZ   0D8A
....................       return TRUE;
00D82:  MOVLW  01
00D84:  MOVWF  01
00D86:  BRA    0E1A
00D88:  BRA    0E1A
....................    else
....................    {
....................       fprintf(PC, "\t-> CRC error!\r\n");
00D8A:  MOVLW  46
00D8C:  MOVWF  FF6
00D8E:  MOVLW  04
00D90:  MOVWF  FF7
00D92:  MOVLW  00
00D94:  MOVWF  FF8
00D96:  CLRF   1B
00D98:  BTFSC  FF2.7
00D9A:  BSF    1B.7
00D9C:  BCF    FF2.7
00D9E:  MOVLB  0
00DA0:  CALL   0146
00DA4:  BTFSC  1B.7
00DA6:  BSF    FF2.7
....................       fprintf(PC, "\t\t-> received CRC: %X\r\n", received_crc);
00DA8:  MOVLW  58
00DAA:  MOVWF  FF6
00DAC:  MOVLW  04
00DAE:  MOVWF  FF7
00DB0:  MOVLW  00
00DB2:  MOVWF  FF8
00DB4:  MOVLW  13
00DB6:  MOVLB  1
00DB8:  MOVWF  xDE
00DBA:  MOVLB  0
00DBC:  RCALL  0C58
00DBE:  MOVFF  1DC,1DE
00DC2:  MOVLW  37
00DC4:  MOVLB  1
00DC6:  MOVWF  xDF
00DC8:  MOVLB  0
00DCA:  RCALL  0B7C
00DCC:  MOVLW  0D
00DCE:  BTFSS  FA4.4
00DD0:  BRA    0DCE
00DD2:  MOVLB  F
00DD4:  MOVWF  x1D
00DD6:  MOVLW  0A
00DD8:  BTFSS  FA4.4
00DDA:  BRA    0DD8
00DDC:  MOVWF  x1D
....................       fprintf(PC, "\t\t   collect CRC : %X\r\n", collect_crc);
00DDE:  MOVLW  70
00DE0:  MOVWF  FF6
00DE2:  MOVLW  04
00DE4:  MOVWF  FF7
00DE6:  MOVLW  00
00DE8:  MOVWF  FF8
00DEA:  MOVLW  13
00DEC:  MOVLB  1
00DEE:  MOVWF  xDE
00DF0:  MOVLB  0
00DF2:  RCALL  0C58
00DF4:  MOVFF  1DD,1DE
00DF8:  MOVLW  37
00DFA:  MOVLB  1
00DFC:  MOVWF  xDF
00DFE:  MOVLB  0
00E00:  RCALL  0B7C
00E02:  MOVLW  0D
00E04:  BTFSS  FA4.4
00E06:  BRA    0E04
00E08:  MOVLB  F
00E0A:  MOVWF  x1D
00E0C:  MOVLW  0A
00E0E:  BTFSS  FA4.4
00E10:  BRA    0E0E
00E12:  MOVWF  x1D
....................       return FALSE;
00E14:  MOVLW  00
00E16:  MOVWF  01
00E18:  MOVLB  1
....................    }
00E1A:  MOVLB  0
00E1C:  GOTO   104C (RETURN)
.................... }
.................... 
.................... static int1 check_device_id(unsigned int8 device_id)
.................... {
....................    if (SELF_DEVICE_ID == device_id)
00E20:  MOVLB  1
00E22:  MOVF   xDA,W
00E24:  SUBLW  05
00E26:  BNZ   0E30
....................       return TRUE;
00E28:  MOVLW  01
00E2A:  MOVWF  01
00E2C:  BRA    0EC0
00E2E:  BRA    0EC0
....................    else
....................    {
....................       fprintf(PC, "\t-> Invalid device ID received\r\n");
00E30:  MOVLW  88
00E32:  MOVWF  FF6
00E34:  MOVLW  04
00E36:  MOVWF  FF7
00E38:  MOVLW  00
00E3A:  MOVWF  FF8
00E3C:  CLRF   1B
00E3E:  BTFSC  FF2.7
00E40:  BSF    1B.7
00E42:  BCF    FF2.7
00E44:  MOVLB  0
00E46:  CALL   0146
00E4A:  BTFSC  1B.7
00E4C:  BSF    FF2.7
....................       fprintf(PC, "\t\t-> received:     %X\r\n", device_id);
00E4E:  MOVLW  AA
00E50:  MOVWF  FF6
00E52:  MOVLW  04
00E54:  MOVWF  FF7
00E56:  MOVLW  00
00E58:  MOVWF  FF8
00E5A:  MOVLW  13
00E5C:  MOVLB  1
00E5E:  MOVWF  xDE
00E60:  MOVLB  0
00E62:  RCALL  0C58
00E64:  MOVFF  1DA,1DE
00E68:  MOVLW  37
00E6A:  MOVLB  1
00E6C:  MOVWF  xDF
00E6E:  MOVLB  0
00E70:  RCALL  0B7C
00E72:  MOVLW  0D
00E74:  BTFSS  FA4.4
00E76:  BRA    0E74
00E78:  MOVLB  F
00E7A:  MOVWF  x1D
00E7C:  MOVLW  0A
00E7E:  BTFSS  FA4.4
00E80:  BRA    0E7E
00E82:  MOVWF  x1D
....................       fprintf(PC, "\t\t   My device ID: %X\r\n", SELF_DEVICE_ID);
00E84:  MOVLW  C2
00E86:  MOVWF  FF6
00E88:  MOVLW  04
00E8A:  MOVWF  FF7
00E8C:  MOVLW  00
00E8E:  MOVWF  FF8
00E90:  MOVLW  13
00E92:  MOVLB  1
00E94:  MOVWF  xDE
00E96:  MOVLB  0
00E98:  RCALL  0C58
00E9A:  MOVLW  05
00E9C:  MOVLB  1
00E9E:  MOVWF  xDE
00EA0:  MOVLW  37
00EA2:  MOVWF  xDF
00EA4:  MOVLB  0
00EA6:  RCALL  0B7C
00EA8:  MOVLW  0D
00EAA:  BTFSS  FA4.4
00EAC:  BRA    0EAA
00EAE:  MOVLB  F
00EB0:  MOVWF  x1D
00EB2:  MOVLW  0A
00EB4:  BTFSS  FA4.4
00EB6:  BRA    0EB4
00EB8:  MOVWF  x1D
....................       return FALSE;  
00EBA:  MOVLW  00
00EBC:  MOVWF  01
00EBE:  MOVLB  1
....................    }
00EC0:  MOVLB  0
00EC2:  GOTO   107E (RETURN)
.................... }
.................... 
.................... 
.................... // _______ Transmit _______
.................... 
.................... void transmit_command(TransmitFrameId frame_id, unsigned int8 content[], int8 size)
.................... {
....................    unsigned int8 data[16];
....................    data[0] = SFD;
*
01316:  MOVLW  AA
01318:  MOVLB  1
0131A:  MOVWF  xA9
....................    data[1] = (BOSS_PIC << 4) | frame_id;
0131C:  MOVF   xA5,W
0131E:  IORLW  40
01320:  MOVWF  xAA
....................    memcpy(&data[2], content, size);
01322:  MOVLW  01
01324:  MOVWF  FEA
01326:  MOVLW  AB
01328:  MOVWF  FE9
0132A:  MOVFF  1A7,FE2
0132E:  MOVFF  1A6,FE1
01332:  MOVF   xA8,W
01334:  MOVWF  01
01336:  BZ    1340
01338:  MOVFF  FE6,FEE
0133C:  DECFSZ 01,F
0133E:  BRA    1338
....................    int8 payload_size = 2 + size; // '2' is for Device ID and Frame ID plus CRC
01340:  MOVLW  02
01342:  ADDWF  xA8,W
01344:  MOVWF  xB9
....................    data[payload_size] = calc_crc8(&data[1], payload_size-1); // '1' is for CRC
01346:  CLRF   03
01348:  MOVF   xB9,W
0134A:  ADDLW  A9
0134C:  MOVWF  01
0134E:  MOVLW  01
01350:  ADDWFC 03,F
01352:  MOVFF  01,1BB
01356:  MOVFF  03,1BC
0135A:  MOVLW  01
0135C:  SUBWF  xB9,W
0135E:  MOVWF  xBD
01360:  MOVLW  01
01362:  MOVWF  xE0
01364:  MOVLW  AA
01366:  MOVWF  xDF
01368:  MOVFF  1BD,1E1
0136C:  MOVLB  0
0136E:  RCALL  0D1A
01370:  MOVFF  1BC,FEA
01374:  MOVFF  1BB,FE9
01378:  MOVFF  01,FEF
....................    int8 data_size = payload_size + 1; // '1' is for CRC
0137C:  MOVLW  01
0137E:  MOVLB  1
01380:  ADDWF  xB9,W
01382:  MOVWF  xBA
....................    
....................    transmit(data, data_size);
01384:  MOVLW  01
01386:  MOVWF  xBC
01388:  MOVLW  A9
0138A:  MOVWF  xBB
0138C:  MOVFF  1BA,1BD
01390:  MOVLB  0
01392:  BRA    1288
01394:  RETURN 0
.................... }
.................... 
.................... static void transmit(unsigned int8 data[], int8 data_size)
.................... {
....................    for(int i = 0; i < data_size; i++)
*
01288:  MOVLB  1
0128A:  CLRF   xBE
0128C:  MOVF   xBD,W
0128E:  SUBWF  xBE,W
01290:  BC    12AE
....................       fputc(data[i], BOSS);
01292:  MOVF   xBE,W
01294:  ADDWF  xBB,W
01296:  MOVWF  FE9
01298:  MOVLW  00
0129A:  ADDWFC xBC,W
0129C:  MOVWF  FEA
0129E:  MOVFF  FEF,1C0
012A2:  MOVF   xC0,W
012A4:  MOVLB  0
012A6:  BRA    127E
012A8:  MOVLB  1
012AA:  INCF   xBE,F
012AC:  BRA    128C
....................       
....................    fprintf(PC, "Transit command\r\n\t-> ");
012AE:  MOVLW  DA
012B0:  MOVWF  FF6
012B2:  MOVLW  04
012B4:  MOVWF  FF7
012B6:  MOVLW  00
012B8:  MOVWF  FF8
012BA:  CLRF   1B
012BC:  BTFSC  FF2.7
012BE:  BSF    1B.7
012C0:  BCF    FF2.7
012C2:  MOVLB  0
012C4:  CALL   0146
012C8:  BTFSC  1B.7
012CA:  BSF    FF2.7
....................    for(int i = 0; i < data_size; i++)
012CC:  MOVLB  1
012CE:  CLRF   xBF
012D0:  MOVF   xBD,W
012D2:  SUBWF  xBF,W
012D4:  BC    12FE
....................       fprintf(PC, "%X ", data[i]);
012D6:  MOVF   xBF,W
012D8:  ADDWF  xBB,W
012DA:  MOVWF  FE9
012DC:  MOVLW  00
012DE:  ADDWFC xBC,W
012E0:  MOVWF  FEA
012E2:  MOVFF  FEF,1DE
012E6:  MOVLW  37
012E8:  MOVWF  xDF
012EA:  MOVLB  0
012EC:  RCALL  0B7C
012EE:  MOVLW  20
012F0:  BTFSS  FA4.4
012F2:  BRA    12F0
012F4:  MOVLB  F
012F6:  MOVWF  x1D
012F8:  MOVLB  1
012FA:  INCF   xBF,F
012FC:  BRA    12D0
....................    fprintf(PC, "\r\n");
012FE:  MOVLW  0D
01300:  BTFSS  FA4.4
01302:  BRA    1300
01304:  MOVLB  F
01306:  MOVWF  x1D
01308:  MOVLW  0A
0130A:  BTFSS  FA4.4
0130C:  BRA    130A
0130E:  MOVWF  x1D
01310:  MOVLB  0
01312:  GOTO   1394 (RETURN)
.................... }
.................... 
.................... 
.................... // ______ Common _______
.................... 
.................... static unsigned int8 calc_crc8(unsigned int8 frame[], int8 payload_size)
*
00D1A:  MOVLB  1
00D1C:  MOVFF  1DF,FE9
00D20:  MOVFF  1E0,FEA
00D24:  MOVFF  FEF,1E2
00D28:  MOVLW  01
00D2A:  MOVWF  xE3
.................... {
....................    unsigned int8 crc = frame[0], i = 1;
....................    while(i < payload_size)
00D2C:  MOVF   xE1,W
00D2E:  SUBWF  xE3,W
00D30:  BC    0D46
....................       crc ^= frame[i++];
00D32:  MOVF   xE3,W
00D34:  INCF   xE3,F
00D36:  ADDWF  xDF,W
00D38:  MOVWF  FE9
00D3A:  MOVLW  00
00D3C:  ADDWFC xE0,W
00D3E:  MOVWF  FEA
00D40:  MOVF   FEF,W
00D42:  XORWF  xE2,F
00D44:  BRA    0D2C
....................    return crc;
00D46:  MOVFF  1E2,01
00D4A:  MOVLB  0
00D4C:  RETURN 0
.................... }
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size)
*
01100:  MOVFF  154,1AC
01104:  MOVFF  153,1AB
01108:  MOVFF  155,1AD
0110C:  RCALL  0EC6
0110E:  MOVFF  02,03
01112:  MOVFF  01,FE1
01116:  MOVFF  02,FE2
0111A:  MOVLW  01
0111C:  MOVWF  FEA
0111E:  MOVLW  56
01120:  MOVWF  FE9
01122:  MOVLW  23
01124:  MOVWF  01
01126:  MOVFF  FE6,FEE
0112A:  DECFSZ 01,F
0112C:  BRA    1126
.................... {
....................    Command command = make_receive_command(receive_signal, receive_signal_size);
....................    return command;
0112E:  MOVLW  56
01130:  MOVWF  01
01132:  MOVLW  01
01134:  MOVWF  02
01136:  GOTO   24DE (RETURN)
.................... }
.................... 
.................... void transmit_ack()
.................... {
....................    transmit_command(ACK, 0, 0);
*
01396:  MOVLW  0F
01398:  MOVLB  1
0139A:  MOVWF  xA5
0139C:  CLRF   xA7
0139E:  CLRF   xA6
013A0:  CLRF   xA8
013A2:  MOVLB  0
013A4:  RCALL  1316
013A6:  RETURN 0
.................... }
.................... 
.................... void transmit_status()
.................... {
....................    transmit_command(MIS_MCU_STATUS, &status, 1);
*
018D4:  MOVLW  01
018D6:  MOVLB  1
018D8:  MOVWF  xA5
018DA:  CLRF   xA7
018DC:  MOVLW  1F
018DE:  MOVWF  xA6
018E0:  MOVLW  01
018E2:  MOVWF  xA8
018E4:  MOVLB  0
018E6:  RCALL  1316
018E8:  RETURN 0
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // _____________ define _______________
.................... 
.................... #define EXECUTED_MISSION_SIZE 8
.................... 
.................... 
.................... // _____________ typedef ________________
.................... 
.................... typedef struct {
....................    unsigned int8 executed_mission[EXECUTED_MISSION_SIZE];
....................    int8 executed_mission_count;
.................... } ExecutedMission;
.................... 
.................... 
.................... // ________________ fuctions ____________
.................... 
.................... // Value management using the Singleton pattern
.................... ExecutedMission get_executed_mission();
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id);
.................... 
.................... void add_executed_mission(unsigned int8 command_id);
.................... 
.................... // Use in missions you want to execute consecutively
.................... void executed_mission_pop(void);
.................... 
.................... 
.................... 
.................... // Check and reply to messages received from BOSS PIC
.................... void check_and_respond_to_boss();
.................... 
.................... // MIS MCU will be up and running duration_second seconds after mission completion
.................... void continue_mis_mcu(int16 duration_second);
.................... 
.................... 
.................... 
.................... // Request using SMF to BOSS PIC
.................... // !!!After use, you must call `void finished_use_smf()`
.................... int1 req_use_smf();
.................... 
.................... // Call after using SMF
.................... void finished_use_smf();
.................... 
.................... 
.................... #include "./src/mission_tools.c"
.................... ExecutedMission get_executed_mission()
.................... {
....................    static ExecutedMission executed_mission = {0};
....................    return executed_mission;
*
013A8:  MOVLW  1D
013AA:  MOVWF  01
013AC:  MOVLW  01
013AE:  MOVWF  02
013B0:  RETURN 0
.................... }
.................... 
.................... int1 is_executed_mission(unsigned int8 command_id)
013B2:  RCALL  13A8
013B4:  MOVFF  02,03
013B8:  MOVFF  01,FE1
013BC:  MOVFF  02,FE2
013C0:  MOVLW  01
013C2:  MOVWF  FEA
013C4:  MOVLW  57
013C6:  MOVWF  FE9
013C8:  MOVLW  09
013CA:  MOVWF  01
013CC:  MOVFF  FE6,FEE
013D0:  DECFSZ 01,F
013D2:  BRA    13CC
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    for (int i = 0; i < executed_mission.executed_mission_count; i++)
013D4:  MOVLB  1
013D6:  CLRF   x60
013D8:  MOVF   x5F,W
013DA:  SUBWF  x60,W
013DC:  BC    13FC
....................       if (command_id == executed_mission.executed_mission[i])
013DE:  CLRF   03
013E0:  MOVF   x60,W
013E2:  ADDLW  57
013E4:  MOVWF  FE9
013E6:  MOVLW  01
013E8:  ADDWFC 03,W
013EA:  MOVWF  FEA
013EC:  MOVF   FEF,W
013EE:  SUBWF  x56,W
013F0:  BNZ   13F8
....................          return TRUE;
013F2:  MOVLW  01
013F4:  MOVWF  01
013F6:  BRA    1400
013F8:  INCF   x60,F
013FA:  BRA    13D8
....................       
....................    return FALSE;
013FC:  MOVLW  00
013FE:  MOVWF  01
01400:  MOVLB  0
01402:  GOTO   1CDE (RETURN)
.................... }
.................... 
.................... void add_executed_mission(unsigned int8 command_id)
01406:  RCALL  13A8
01408:  MOVFF  02,03
0140C:  MOVFF  01,FE1
01410:  MOVFF  02,FE2
01414:  MOVLW  01
01416:  MOVWF  FEA
01418:  MOVLW  57
0141A:  MOVWF  FE9
0141C:  MOVLW  09
0141E:  MOVWF  01
01420:  MOVFF  FE6,FEE
01424:  DECFSZ 01,F
01426:  BRA    1420
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    
....................    if (executed_mission.executed_mission_count != EXECUTED_MISSION_SIZE)
01428:  MOVLB  1
0142A:  MOVF   x5F,W
0142C:  SUBLW  08
0142E:  BZ    1446
....................       executed_mission.executed_mission[executed_mission.executed_mission_count++] = command_id;
01430:  MOVF   x5F,W
01432:  INCF   x5F,F
01434:  CLRF   03
01436:  ADDLW  57
01438:  MOVWF  FE9
0143A:  MOVLW  01
0143C:  ADDWFC 03,W
0143E:  MOVWF  FEA
01440:  MOVFF  156,FEF
01444:  BRA    1466
....................    else
....................       fprintf(PC, "!!!overflow executed_mission list\r\n");
01446:  MOVLW  F0
01448:  MOVWF  FF6
0144A:  MOVLW  04
0144C:  MOVWF  FF7
0144E:  MOVLW  00
01450:  MOVWF  FF8
01452:  CLRF   1B
01454:  BTFSC  FF2.7
01456:  BSF    1B.7
01458:  BCF    FF2.7
0145A:  MOVLB  0
0145C:  CALL   0146
01460:  BTFSC  1B.7
01462:  BSF    FF2.7
01464:  MOVLB  1
01466:  MOVLB  0
01468:  GOTO   1D28 (RETURN)
.................... }
.................... 
.................... 
.................... int1 req_use_smf()
.................... {
....................    fprintf(PC, "Start SMF using reqest seaquence\r\n");
*
018EA:  MOVLW  14
018EC:  MOVWF  FF6
018EE:  MOVLW  05
018F0:  MOVWF  FF7
018F2:  MOVLW  00
018F4:  MOVWF  FF8
018F6:  CLRF   1B
018F8:  BTFSC  FF2.7
018FA:  BSF    1B.7
018FC:  BCF    FF2.7
018FE:  CALL   0146
01902:  BTFSC  1B.7
01904:  BSF    FF2.7
....................    status = SMF_USE_REQ;
01906:  MOVLW  04
01908:  MOVWF  1F
....................    is_use_smf_req_in_mission = TRUE;
0190A:  BSF    1E.0
....................    
....................    while (TRUE)
....................    {
....................       for (int16 i = 0; i < 1200; i++) // 10 min
0190C:  MOVLB  1
0190E:  CLRF   x5C
01910:  CLRF   x5B
01912:  MOVF   x5C,W
01914:  SUBLW  04
01916:  BNC   19B0
01918:  BNZ   1920
0191A:  MOVF   x5B,W
0191C:  SUBLW  AF
0191E:  BNC   19B0
....................       {
....................          if (boss_receive_buffer_size > 0)
01920:  MOVF   4A,F
01922:  BZ    1996
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size);
01924:  CLRF   xAC
01926:  MOVLW  2A
01928:  MOVWF  xAB
0192A:  MOVFF  4A,1AD
0192E:  MOVLB  0
01930:  CALL   0EC6
01934:  MOVFF  02,03
01938:  MOVFF  01,FE1
0193C:  MOVFF  02,FE2
01940:  MOVLW  01
01942:  MOVWF  FEA
01944:  MOVLW  5D
01946:  MOVWF  FE9
01948:  MOVLW  23
0194A:  MOVWF  01
0194C:  MOVFF  FE6,FEE
01950:  DECFSZ 01,F
01952:  BRA    194C
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
01954:  MOVLB  1
01956:  CLRF   xA6
01958:  MOVLW  2A
0195A:  MOVWF  xA5
0195C:  CLRF   xA8
0195E:  MOVLW  4A
01960:  MOVWF  xA7
01962:  MOVLB  0
01964:  RCALL  124E
....................             if (command.frame_id == STATUS_CHECK)
01966:  MOVLB  1
01968:  DECFSZ x5D,W
0196A:  BRA    1976
....................             {
....................                transmit_status();
0196C:  MOVLB  0
0196E:  RCALL  18D4
....................                break;
01970:  MOVLB  1
01972:  BRA    19B0
....................             }
01974:  BRA    1996
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
01976:  MOVLW  38
01978:  MOVWF  FF6
0197A:  MOVLW  05
0197C:  MOVWF  FF7
0197E:  MOVLW  00
01980:  MOVWF  FF8
01982:  CLRF   1B
01984:  BTFSC  FF2.7
01986:  BSF    1B.7
01988:  BCF    FF2.7
0198A:  MOVLB  0
0198C:  CALL   0146
01990:  BTFSC  1B.7
01992:  BSF    FF2.7
01994:  MOVLB  1
....................             }
....................          }
....................          delay_ms(500);
01996:  MOVLW  02
01998:  MOVWF  xA5
0199A:  MOVLW  FA
0199C:  MOVWF  xA6
0199E:  MOVLB  0
019A0:  RCALL  14A8
019A2:  MOVLB  1
019A4:  DECFSZ xA5,F
019A6:  BRA    199A
019A8:  INCF   x5B,F
019AA:  BTFSC  FD8.2
019AC:  INCF   x5C,F
019AE:  BRA    1912
....................       }
....................       
....................       for (int16 i = 0; i < 1200; i++) // 10 min
019B0:  CLRF   x81
019B2:  CLRF   x80
019B4:  MOVF   x81,W
019B6:  SUBLW  04
019B8:  BTFSS  FD8.0
019BA:  BRA    1ABE
019BC:  BNZ   19C6
019BE:  MOVF   x80,W
019C0:  SUBLW  AF
019C2:  BTFSS  FD8.0
019C4:  BRA    1ABE
....................       {
....................          if (boss_receive_buffer_size > 0)
019C6:  MOVF   4A,F
019C8:  BZ    1AA4
....................          {
....................             Command command = make_receive_command(boss_receive_buffer, boss_receive_buffer_size); 
019CA:  CLRF   xAC
019CC:  MOVLW  2A
019CE:  MOVWF  xAB
019D0:  MOVFF  4A,1AD
019D4:  MOVLB  0
019D6:  CALL   0EC6
019DA:  MOVFF  02,03
019DE:  MOVFF  01,FE1
019E2:  MOVFF  02,FE2
019E6:  MOVLW  01
019E8:  MOVWF  FEA
019EA:  MOVLW  82
019EC:  MOVWF  FE9
019EE:  MOVLW  23
019F0:  MOVWF  01
019F2:  MOVFF  FE6,FEE
019F6:  DECFSZ 01,F
019F8:  BRA    19F2
....................             clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
019FA:  MOVLB  1
019FC:  CLRF   xA6
019FE:  MOVLW  2A
01A00:  MOVWF  xA5
01A02:  CLRF   xA8
01A04:  MOVLW  4A
01A06:  MOVWF  xA7
01A08:  MOVLB  0
01A0A:  RCALL  124E
....................             if (command.frame_id == IS_SMF_AVAILABLE)
01A0C:  MOVLB  1
01A0E:  MOVF   x82,W
01A10:  SUBLW  02
01A12:  BNZ   1A84
....................             {
....................                if (command.content[0] == ALLOW)
01A14:  MOVF   x83,F
01A16:  BNZ   1A3E
....................                {
....................                   fprintf(PC, "SMF use request allowed\r\n");
01A18:  MOVLW  70
01A1A:  MOVWF  FF6
01A1C:  MOVLW  05
01A1E:  MOVWF  FF7
01A20:  MOVLW  00
01A22:  MOVWF  FF8
01A24:  CLRF   1B
01A26:  BTFSC  FF2.7
01A28:  BSF    1B.7
01A2A:  BCF    FF2.7
01A2C:  MOVLB  0
01A2E:  CALL   0146
01A32:  BTFSC  1B.7
01A34:  BSF    FF2.7
....................                   transmit_ack();
01A36:  RCALL  1396
....................                   goto NEXT;
01A38:  BRA    1AC2
....................                }
01A3A:  BRA    1A80
01A3C:  MOVLB  1
....................                else
....................                {
....................                   fprintf(PC, "SMF use request denyed\r\n");
01A3E:  MOVLW  8A
01A40:  MOVWF  FF6
01A42:  MOVLW  05
01A44:  MOVWF  FF7
01A46:  MOVLW  00
01A48:  MOVWF  FF8
01A4A:  CLRF   1B
01A4C:  BTFSC  FF2.7
01A4E:  BSF    1B.7
01A50:  BCF    FF2.7
01A52:  MOVLB  0
01A54:  CALL   0146
01A58:  BTFSC  1B.7
01A5A:  BSF    FF2.7
....................                   fprintf(PC, "Retry request to BOSS PIC\r\n");
01A5C:  MOVLW  A4
01A5E:  MOVWF  FF6
01A60:  MOVLW  05
01A62:  MOVWF  FF7
01A64:  MOVLW  00
01A66:  MOVWF  FF8
01A68:  CLRF   1B
01A6A:  BTFSC  FF2.7
01A6C:  BSF    1B.7
01A6E:  BCF    FF2.7
01A70:  CALL   0146
01A74:  BTFSC  1B.7
01A76:  BSF    FF2.7
....................                   transmit_ack();
01A78:  RCALL  1396
....................                   break;
01A7A:  MOVLB  1
01A7C:  BRA    1ABE
01A7E:  MOVLB  0
....................                }
....................             }
01A80:  BRA    1AA2
01A82:  MOVLB  1
....................             else
....................             {
....................                fprintf(PC, "Error! Receiving command inconsistent with the design\r\n");
01A84:  MOVLW  C0
01A86:  MOVWF  FF6
01A88:  MOVLW  05
01A8A:  MOVWF  FF7
01A8C:  MOVLW  00
01A8E:  MOVWF  FF8
01A90:  CLRF   1B
01A92:  BTFSC  FF2.7
01A94:  BSF    1B.7
01A96:  BCF    FF2.7
01A98:  MOVLB  0
01A9A:  CALL   0146
01A9E:  BTFSC  1B.7
01AA0:  BSF    FF2.7
01AA2:  MOVLB  1
....................             }
....................          }
....................          delay_ms(500);
01AA4:  MOVLW  02
01AA6:  MOVWF  xA5
01AA8:  MOVLW  FA
01AAA:  MOVWF  xA6
01AAC:  MOVLB  0
01AAE:  RCALL  14A8
01AB0:  MOVLB  1
01AB2:  DECFSZ xA5,F
01AB4:  BRA    1AA8
01AB6:  INCF   x80,F
01AB8:  BTFSC  FD8.2
01ABA:  INCF   x81,F
01ABC:  BRA    19B4
....................       }
01ABE:  BRA    190E
01AC0:  MOVLB  0
....................    }
....................    
.................... NEXT:
....................    is_use_smf_req_in_mission = FALSE;
01AC2:  BCF    1E.0
....................    status = COPYING;
01AC4:  MOVLW  05
01AC6:  MOVWF  1F
....................    return TRUE;
01AC8:  MOVLW  01
01ACA:  MOVWF  01
01ACC:  BRA    1AEC
....................    fprintf(PC, "End SMF using reqest seaquence\r\n");
01ACE:  MOVLW  F8
01AD0:  MOVWF  FF6
01AD2:  MOVLW  05
01AD4:  MOVWF  FF7
01AD6:  MOVLW  00
01AD8:  MOVWF  FF8
01ADA:  CLRF   1B
01ADC:  BTFSC  FF2.7
01ADE:  BSF    1B.7
01AE0:  BCF    FF2.7
01AE2:  MOVLB  0
01AE4:  CALL   0146
01AE8:  BTFSC  1B.7
01AEA:  BSF    FF2.7
01AEC:  MOVLB  0
01AEE:  GOTO   1BA8 (RETURN)
.................... }
.................... 
.................... 
.................... void finished_use_smf()
.................... {
....................    status = EXECUTING_MISSION;
01AF2:  MOVLW  02
01AF4:  MOVWF  1F
01AF6:  GOTO   1C26 (RETURN)
.................... }
.................... 
.................... void executed_mission_pop(void)
*
0146C:  RCALL  13A8
0146E:  MOVFF  02,03
01472:  MOVFF  01,FE1
01476:  MOVFF  02,FE2
0147A:  MOVLW  01
0147C:  MOVWF  FEA
0147E:  MOVLW  72
01480:  MOVWF  FE9
01482:  MOVLW  09
01484:  MOVWF  01
01486:  MOVFF  FE6,FEE
0148A:  DECFSZ 01,F
0148C:  BRA    1486
.................... {
....................    ExecutedMission executed_mission = get_executed_mission();
....................    executed_mission.executed_mission[executed_mission.executed_mission_count--] = 0x00;
0148E:  MOVLB  1
01490:  MOVF   x7A,W
01492:  DECF   x7A,F
01494:  CLRF   03
01496:  ADDLW  72
01498:  MOVWF  FE9
0149A:  MOVLW  01
0149C:  ADDWFC 03,W
0149E:  MOVWF  FEA
014A0:  CLRF   FEF
014A2:  MOVLB  0
014A4:  GOTO   168E (RETURN)
.................... }
.................... 
.................... void continue_mis_mcu(int16 duration_second)
.................... {  
....................    duration_sec = duration_second + sec;
.................... }
.................... 
.................... void check_and_respond_to_boss()
.................... {
....................    if (kbhit())
*
01AFA:  BTFSS  F9E.5
01AFC:  BRA    1B06
....................    {
....................       fgetc(BOSS);
01AFE:  BTFSS  F9E.5
01B00:  BRA    1AFE
01B02:  MOVF   FAE,W
....................       transmit_status();
01B04:  RCALL  18D4
....................    }
01B06:  GOTO   1C50 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... // fundamental fnction
.................... void execute_mission(unsigned int8 *content);
.................... 
.................... // missions
.................... void example_00(unsigned int8 parameter[]);
.................... void example_01(unsigned int8 parameter[]);
.................... void example_02(unsigned int8 parameter[]);
.................... 
.................... #include "./mission.c"
.................... //____________ main mission function _______________
.................... 
.................... void execute_mission(unsigned int8 *content)
*
01CB6:  MOVLB  1
01CB8:  MOVFF  151,FE9
01CBC:  MOVFF  152,FEA
01CC0:  MOVFF  FEF,153
01CC4:  MOVLW  01
01CC6:  ADDWF  x51,W
01CC8:  MOVWF  01
01CCA:  MOVLW  00
01CCC:  ADDWFC x52,W
01CCE:  MOVFF  01,154
01CD2:  MOVWF  x55
.................... {
....................    // record to executed mission list
....................    unsigned int8 command_id = content[0];
....................    unsigned int8 *parameter = &content[1];
....................    
....................    if (is_executed_mission(command_id))
01CD4:  MOVFF  153,156
01CD8:  MOVLB  0
01CDA:  GOTO   13B2
01CDE:  MOVF   01,F
01CE0:  BZ    1D20
....................    {
....................       fprintf(PC, "\r\nThis  mission is executed\r\n\t-> 0x%d\r\n", command_id);
01CE2:  MOVLW  1A
01CE4:  MOVWF  FF6
01CE6:  MOVLW  06
01CE8:  MOVWF  FF7
01CEA:  MOVLW  00
01CEC:  MOVWF  FF8
01CEE:  MOVLW  23
01CF0:  MOVLB  1
01CF2:  MOVWF  xDE
01CF4:  MOVLB  0
01CF6:  CALL   0C58
01CFA:  MOVFF  153,156
01CFE:  MOVLW  18
01D00:  MOVLB  1
01D02:  MOVWF  x57
01D04:  MOVLB  0
01D06:  CALL   1166
01D0A:  MOVLW  0D
01D0C:  BTFSS  FA4.4
01D0E:  BRA    1D0C
01D10:  MOVLB  F
01D12:  MOVWF  x1D
01D14:  MOVLW  0A
01D16:  BTFSS  FA4.4
01D18:  BRA    1D16
01D1A:  MOVWF  x1D
....................       return;
01D1C:  BRA    1DF6
01D1E:  MOVLB  0
....................    }
....................    
....................    add_executed_mission(command_id);
01D20:  MOVFF  153,156
01D24:  GOTO   1406
....................    
....................    // execution mission
....................    fprintf(PC, "\r\n______________________________\r\n_____Start execute_mission_____\r\n\r\n");
01D28:  MOVLW  42
01D2A:  MOVWF  FF6
01D2C:  MOVLW  06
01D2E:  MOVWF  FF7
01D30:  MOVLW  00
01D32:  MOVWF  FF8
01D34:  CLRF   1B
01D36:  BTFSC  FF2.7
01D38:  BSF    1B.7
01D3A:  BCF    FF2.7
01D3C:  CALL   0146
01D40:  BTFSC  1B.7
01D42:  BSF    FF2.7
....................    fprintf(PC, "Command ID: %X\r\n\r\n", command_id);
01D44:  MOVLW  88
01D46:  MOVWF  FF6
01D48:  MOVLW  06
01D4A:  MOVWF  FF7
01D4C:  MOVLW  00
01D4E:  MOVWF  FF8
01D50:  MOVLW  0C
01D52:  MOVLB  1
01D54:  MOVWF  xDE
01D56:  MOVLB  0
01D58:  CALL   0C58
01D5C:  MOVFF  153,1DE
01D60:  MOVLW  37
01D62:  MOVLB  1
01D64:  MOVWF  xDF
01D66:  MOVLB  0
01D68:  CALL   0B7C
01D6C:  MOVLW  96
01D6E:  MOVWF  FF6
01D70:  MOVLW  06
01D72:  MOVWF  FF7
01D74:  MOVLW  00
01D76:  MOVWF  FF8
01D78:  MOVLW  04
01D7A:  MOVLB  1
01D7C:  MOVWF  xDE
01D7E:  MOVLB  0
01D80:  CALL   0C58
....................    switch(command_id)
01D84:  MOVLB  1
01D86:  MOVF   x53,W
01D88:  XORLW  00
01D8A:  MOVLB  0
01D8C:  BZ    1D98
01D8E:  XORLW  01
01D90:  BZ    1DA4
01D92:  XORLW  03
01D94:  BZ    1DB0
01D96:  BRA    1DBC
....................    {
....................       case 0x00:
....................          example_00(parameter);
01D98:  MOVFF  155,157
01D9C:  MOVFF  154,156
01DA0:  BRA    160C
....................          break;
01DA2:  BRA    1DD8
....................       case 0x01:
....................          example_01(parameter);
01DA4:  MOVFF  155,157
01DA8:  MOVFF  154,156
01DAC:  BRA    17BC
....................          break;
01DAE:  BRA    1DD8
....................       case 0x02:
....................          example_02(parameter);
01DB0:  MOVFF  155,157
01DB4:  MOVFF  154,156
01DB8:  BRA    1B0A
....................          break;
01DBA:  BRA    1DD8
....................          
....................       default:
....................          fprintf(PC, "\t\t-> Invalid CMD ID!\r\n");
01DBC:  MOVLW  9C
01DBE:  MOVWF  FF6
01DC0:  MOVLW  06
01DC2:  MOVWF  FF7
01DC4:  MOVLW  00
01DC6:  MOVWF  FF8
01DC8:  CLRF   1B
01DCA:  BTFSC  FF2.7
01DCC:  BSF    1B.7
01DCE:  BCF    FF2.7
01DD0:  CALL   0146
01DD4:  BTFSC  1B.7
01DD6:  BSF    FF2.7
....................    }
....................    fprintf(PC, "\r\n______End execute_mission______\r\n_______________________________\r\n");
01DD8:  MOVLW  B4
01DDA:  MOVWF  FF6
01DDC:  MOVLW  06
01DDE:  MOVWF  FF7
01DE0:  MOVLW  00
01DE2:  MOVWF  FF8
01DE4:  CLRF   1B
01DE6:  BTFSC  FF2.7
01DE8:  BSF    1B.7
01DEA:  BCF    FF2.7
01DEC:  CALL   0146
01DF0:  BTFSC  1B.7
01DF2:  BSF    FF2.7
01DF4:  MOVLB  F
01DF6:  MOVLB  0
01DF8:  GOTO   218C (RETURN)
.................... }
.................... 
.................... // _________________ missions ______________________
.................... 
.................... void example_00(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_00\r\n");
*
0160C:  MOVLW  FA
0160E:  MOVWF  FF6
01610:  MOVLW  06
01612:  MOVWF  FF7
01614:  MOVLW  00
01616:  MOVWF  FF8
01618:  CLRF   1B
0161A:  BTFSC  FF2.7
0161C:  BSF    1B.7
0161E:  BCF    FF2.7
01620:  CALL   0146
01624:  BTFSC  1B.7
01626:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
01628:  MOVLW  0E
0162A:  MOVWF  FF6
0162C:  MOVLW  07
0162E:  MOVWF  FF7
01630:  MOVLW  00
01632:  MOVWF  FF8
01634:  CLRF   1B
01636:  BTFSC  FF2.7
01638:  BSF    1B.7
0163A:  BCF    FF2.7
0163C:  CALL   0146
01640:  BTFSC  1B.7
01642:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
01644:  MOVLB  1
01646:  CLRF   x58
01648:  MOVF   x58,W
0164A:  SUBLW  07
0164C:  BNC   1678
....................       fprintf(PC, "%X ", parameter[i]);
0164E:  MOVF   x58,W
01650:  ADDWF  x56,W
01652:  MOVWF  FE9
01654:  MOVLW  00
01656:  ADDWFC x57,W
01658:  MOVWF  FEA
0165A:  MOVFF  FEF,1DE
0165E:  MOVLW  37
01660:  MOVWF  xDF
01662:  MOVLB  0
01664:  CALL   0B7C
01668:  MOVLW  20
0166A:  BTFSS  FA4.4
0166C:  BRA    166A
0166E:  MOVLB  F
01670:  MOVWF  x1D
01672:  MOVLB  1
01674:  INCF   x58,F
01676:  BRA    1648
....................    fprintf(PC, "\r\n");
01678:  MOVLW  0D
0167A:  BTFSS  FA4.4
0167C:  BRA    167A
0167E:  MOVLB  F
01680:  MOVWF  x1D
01682:  MOVLW  0A
01684:  BTFSS  FA4.4
01686:  BRA    1684
01688:  MOVWF  x1D
....................    
....................    // accept continuous execute
....................    executed_mission_pop();
0168A:  MOVLB  0
0168C:  BRA    146C
....................    fprintf(PC, "(This mission can execute many time as you want)\r\n");
0168E:  MOVLW  1C
01690:  MOVWF  FF6
01692:  MOVLW  07
01694:  MOVWF  FF7
01696:  MOVLW  00
01698:  MOVWF  FF8
0169A:  CLRF   1B
0169C:  BTFSC  FF2.7
0169E:  BSF    1B.7
016A0:  BCF    FF2.7
016A2:  CALL   0146
016A6:  BTFSC  1B.7
016A8:  BSF    FF2.7
....................     
....................    // anything do
....................    fprintf(PC, "executing");
016AA:  MOVLW  50
016AC:  MOVWF  FF6
016AE:  MOVLW  07
016B0:  MOVWF  FF7
016B2:  MOVLW  00
016B4:  MOVWF  FF8
016B6:  CLRF   1B
016B8:  BTFSC  FF2.7
016BA:  BSF    1B.7
016BC:  BCF    FF2.7
016BE:  CALL   0146
016C2:  BTFSC  1B.7
016C4:  BSF    FF2.7
....................    delay_ms(1000);
016C6:  MOVLW  04
016C8:  MOVLB  1
016CA:  MOVWF  x72
016CC:  MOVLW  FA
016CE:  MOVWF  xA6
016D0:  MOVLB  0
016D2:  RCALL  14A8
016D4:  MOVLB  1
016D6:  DECFSZ x72,F
016D8:  BRA    16CC
....................    for (int8 i = 0; i < 5; i++)
016DA:  CLRF   x59
016DC:  MOVF   x59,W
016DE:  SUBLW  04
016E0:  BNC   1704
....................    {
....................       fprintf(PC, ".");
016E2:  MOVLW  2E
016E4:  BTFSS  FA4.4
016E6:  BRA    16E4
016E8:  MOVLB  F
016EA:  MOVWF  x1D
....................       delay_ms(1000);
016EC:  MOVLW  04
016EE:  MOVLB  1
016F0:  MOVWF  x72
016F2:  MOVLW  FA
016F4:  MOVWF  xA6
016F6:  MOVLB  0
016F8:  RCALL  14A8
016FA:  MOVLB  1
016FC:  DECFSZ x72,F
016FE:  BRA    16F2
01700:  INCF   x59,F
01702:  BRA    16DC
....................    }
....................    fprintf(PC, ".\r\n");
01704:  MOVLW  5A
01706:  MOVWF  FF6
01708:  MOVLW  07
0170A:  MOVWF  FF7
0170C:  MOVLW  00
0170E:  MOVWF  FF8
01710:  CLRF   1B
01712:  BTFSC  FF2.7
01714:  BSF    1B.7
01716:  BCF    FF2.7
01718:  MOVLB  0
0171A:  CALL   0146
0171E:  BTFSC  1B.7
01720:  BSF    FF2.7
....................    
....................    // order Copy to SMF data
....................    fprintf(PC, "order Copy smf_data\r\n");
01722:  MOVLW  5E
01724:  MOVWF  FF6
01726:  MOVLW  07
01728:  MOVWF  FF7
0172A:  MOVLW  00
0172C:  MOVWF  FF8
0172E:  CLRF   1B
01730:  BTFSC  FF2.7
01732:  BSF    1B.7
01734:  BCF    FF2.7
01736:  CALL   0146
0173A:  BTFSC  1B.7
0173C:  BSF    FF2.7
....................    unsigned int32 smf_data_destination_address = 0x00103D00; // (in SMF)
....................    unsigned int32 fm_data_source_address = 0x00005000; // (in self Flash memory)
....................    unsigned int32 data_size = 0x00000080;
....................    SmfDataStruct data;
0173E:  MOVLB  1
01740:  CLRF   x5D
01742:  MOVLW  10
01744:  MOVWF  x5C
01746:  MOVLW  3D
01748:  MOVWF  x5B
0174A:  CLRF   x5A
0174C:  CLRF   x61
0174E:  CLRF   x60
01750:  MOVLW  50
01752:  MOVWF  x5F
01754:  CLRF   x5E
01756:  CLRF   x65
01758:  CLRF   x64
0175A:  CLRF   x63
0175C:  MOVLW  80
0175E:  MOVWF  x62
....................    data.dest = smf_data_destination_address;
01760:  MOVFF  15D,16D
01764:  MOVFF  15C,16C
01768:  MOVFF  15B,16B
0176C:  MOVFF  15A,16A
....................    data.src = fm_data_source_address;
01770:  MOVFF  161,169
01774:  MOVFF  160,168
01778:  MOVFF  15F,167
0177C:  MOVFF  15E,166
....................    data.size = data_size;
01780:  MOVFF  165,171
01784:  MOVFF  164,170
01788:  MOVFF  163,16F
0178C:  MOVFF  162,16E
....................    enqueue_smf_data(&data);
01790:  MOVLW  01
01792:  MOVWF  x73
01794:  MOVLW  66
01796:  MOVWF  x72
01798:  MOVLB  0
0179A:  BRA    14D2
....................    
....................    fprintf(PC, "End example_00\r\n");
0179C:  MOVLW  74
0179E:  MOVWF  FF6
017A0:  MOVLW  07
017A2:  MOVWF  FF7
017A4:  MOVLW  00
017A6:  MOVWF  FF8
017A8:  CLRF   1B
017AA:  BTFSC  FF2.7
017AC:  BSF    1B.7
017AE:  BCF    FF2.7
017B0:  CALL   0146
017B4:  BTFSC  1B.7
017B6:  BSF    FF2.7
017B8:  GOTO   1DD8 (RETURN)
....................    
.................... }
.................... 
.................... void example_01(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_01\r\n");
017BC:  MOVLW  86
017BE:  MOVWF  FF6
017C0:  MOVLW  07
017C2:  MOVWF  FF7
017C4:  MOVLW  00
017C6:  MOVWF  FF8
017C8:  CLRF   1B
017CA:  BTFSC  FF2.7
017CC:  BSF    1B.7
017CE:  BCF    FF2.7
017D0:  CALL   0146
017D4:  BTFSC  1B.7
017D6:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
017D8:  MOVLW  9A
017DA:  MOVWF  FF6
017DC:  MOVLW  07
017DE:  MOVWF  FF7
017E0:  MOVLW  00
017E2:  MOVWF  FF8
017E4:  CLRF   1B
017E6:  BTFSC  FF2.7
017E8:  BSF    1B.7
017EA:  BCF    FF2.7
017EC:  CALL   0146
017F0:  BTFSC  1B.7
017F2:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
017F4:  MOVLB  1
017F6:  CLRF   x58
017F8:  MOVF   x58,W
017FA:  SUBLW  07
017FC:  BNC   1828
....................       fprintf(PC, "%X ", parameter[i]);
017FE:  MOVF   x58,W
01800:  ADDWF  x56,W
01802:  MOVWF  FE9
01804:  MOVLW  00
01806:  ADDWFC x57,W
01808:  MOVWF  FEA
0180A:  MOVFF  FEF,1DE
0180E:  MOVLW  37
01810:  MOVWF  xDF
01812:  MOVLB  0
01814:  CALL   0B7C
01818:  MOVLW  20
0181A:  BTFSS  FA4.4
0181C:  BRA    181A
0181E:  MOVLB  F
01820:  MOVWF  x1D
01822:  MOVLB  1
01824:  INCF   x58,F
01826:  BRA    17F8
....................    fprintf(PC, "\r\n");
01828:  MOVLW  0D
0182A:  BTFSS  FA4.4
0182C:  BRA    182A
0182E:  MOVLB  F
01830:  MOVWF  x1D
01832:  MOVLW  0A
01834:  BTFSS  FA4.4
01836:  BRA    1834
01838:  MOVWF  x1D
....................    
....................    fprintf(PC, "This mission wait for 5 seconds\r\n");
0183A:  MOVLW  A8
0183C:  MOVWF  FF6
0183E:  MOVLW  07
01840:  MOVWF  FF7
01842:  MOVLW  00
01844:  MOVWF  FF8
01846:  CLRF   1B
01848:  BTFSC  FF2.7
0184A:  BSF    1B.7
0184C:  BCF    FF2.7
0184E:  MOVLB  0
01850:  CALL   0146
01854:  BTFSC  1B.7
01856:  BSF    FF2.7
....................    fprintf(PC, "executing");
01858:  MOVLW  CA
0185A:  MOVWF  FF6
0185C:  MOVLW  07
0185E:  MOVWF  FF7
01860:  MOVLW  00
01862:  MOVWF  FF8
01864:  CLRF   1B
01866:  BTFSC  FF2.7
01868:  BSF    1B.7
0186A:  BCF    FF2.7
0186C:  CALL   0146
01870:  BTFSC  1B.7
01872:  BSF    FF2.7
....................    for (int8 i = 0; i < 5; i++)
01874:  MOVLB  1
01876:  CLRF   x59
01878:  MOVF   x59,W
0187A:  SUBLW  04
0187C:  BNC   18A0
....................    {
....................       delay_ms(1000);
0187E:  MOVLW  04
01880:  MOVWF  x5A
01882:  MOVLW  FA
01884:  MOVWF  xA6
01886:  MOVLB  0
01888:  RCALL  14A8
0188A:  MOVLB  1
0188C:  DECFSZ x5A,F
0188E:  BRA    1882
....................       fprintf(PC, ".");
01890:  MOVLW  2E
01892:  BTFSS  FA4.4
01894:  BRA    1892
01896:  MOVLB  F
01898:  MOVWF  x1D
0189A:  MOVLB  1
0189C:  INCF   x59,F
0189E:  BRA    1878
....................    }
....................    fprintf(PC, "\r\n");
018A0:  MOVLW  0D
018A2:  BTFSS  FA4.4
018A4:  BRA    18A2
018A6:  MOVLB  F
018A8:  MOVWF  x1D
018AA:  MOVLW  0A
018AC:  BTFSS  FA4.4
018AE:  BRA    18AC
018B0:  MOVWF  x1D
....................    fprintf(PC, "End example_01\r\n");
018B2:  MOVLW  D4
018B4:  MOVWF  FF6
018B6:  MOVLW  07
018B8:  MOVWF  FF7
018BA:  MOVLW  00
018BC:  MOVWF  FF8
018BE:  CLRF   1B
018C0:  BTFSC  FF2.7
018C2:  BSF    1B.7
018C4:  BCF    FF2.7
018C6:  MOVLB  0
018C8:  CALL   0146
018CC:  BTFSC  1B.7
018CE:  BSF    FF2.7
018D0:  GOTO   1DD8 (RETURN)
.................... }
.................... 
.................... void example_02(unsigned int8 parameter[])
.................... {
....................    fprintf(PC, "Start example_02\r\n");
*
01B0A:  MOVLW  E6
01B0C:  MOVWF  FF6
01B0E:  MOVLW  07
01B10:  MOVWF  FF7
01B12:  MOVLW  00
01B14:  MOVWF  FF8
01B16:  CLRF   1B
01B18:  BTFSC  FF2.7
01B1A:  BSF    1B.7
01B1C:  BCF    FF2.7
01B1E:  CALL   0146
01B22:  BTFSC  1B.7
01B24:  BSF    FF2.7
....................    
....................    fprintf(PC, "parameter : ");
01B26:  MOVLW  FA
01B28:  MOVWF  FF6
01B2A:  MOVLW  07
01B2C:  MOVWF  FF7
01B2E:  MOVLW  00
01B30:  MOVWF  FF8
01B32:  CLRF   1B
01B34:  BTFSC  FF2.7
01B36:  BSF    1B.7
01B38:  BCF    FF2.7
01B3A:  CALL   0146
01B3E:  BTFSC  1B.7
01B40:  BSF    FF2.7
....................    for(int8 i = 0; i < PARAMETER_LENGTH; i++)
01B42:  MOVLB  1
01B44:  CLRF   x58
01B46:  MOVF   x58,W
01B48:  SUBLW  07
01B4A:  BNC   1B76
....................       fprintf(PC, "%X ", parameter[i]);
01B4C:  MOVF   x58,W
01B4E:  ADDWF  x56,W
01B50:  MOVWF  FE9
01B52:  MOVLW  00
01B54:  ADDWFC x57,W
01B56:  MOVWF  FEA
01B58:  MOVFF  FEF,1DE
01B5C:  MOVLW  37
01B5E:  MOVWF  xDF
01B60:  MOVLB  0
01B62:  CALL   0B7C
01B66:  MOVLW  20
01B68:  BTFSS  FA4.4
01B6A:  BRA    1B68
01B6C:  MOVLB  F
01B6E:  MOVWF  x1D
01B70:  MOVLB  1
01B72:  INCF   x58,F
01B74:  BRA    1B46
....................    fprintf(PC, "\r\n");
01B76:  MOVLW  0D
01B78:  BTFSS  FA4.4
01B7A:  BRA    1B78
01B7C:  MOVLB  F
01B7E:  MOVWF  x1D
01B80:  MOVLW  0A
01B82:  BTFSS  FA4.4
01B84:  BRA    1B82
01B86:  MOVWF  x1D
....................    
....................    fprintf(PC, "This mission will first access smf and then wait for 5 seconds\r\n");
01B88:  MOVLW  08
01B8A:  MOVWF  FF6
01B8C:  MOVLW  08
01B8E:  MOVWF  FF7
01B90:  MOVLW  00
01B92:  MOVWF  FF8
01B94:  CLRF   1B
01B96:  BTFSC  FF2.7
01B98:  BSF    1B.7
01B9A:  BCF    FF2.7
01B9C:  MOVLB  0
01B9E:  CALL   0146
01BA2:  BTFSC  1B.7
01BA4:  BSF    FF2.7
....................    if (req_use_smf())
01BA6:  BRA    18EA
01BA8:  MOVF   01,F
01BAA:  BZ    1C76
....................    {
....................       fprintf(PC, "Access to SMF");
01BAC:  MOVLW  4A
01BAE:  MOVWF  FF6
01BB0:  MOVLW  08
01BB2:  MOVWF  FF7
01BB4:  MOVLW  00
01BB6:  MOVWF  FF8
01BB8:  CLRF   1B
01BBA:  BTFSC  FF2.7
01BBC:  BSF    1B.7
01BBE:  BCF    FF2.7
01BC0:  CALL   0146
01BC4:  BTFSC  1B.7
01BC6:  BSF    FF2.7
....................       for (int8 i = 0; i < 5; i++)
01BC8:  MOVLB  1
01BCA:  CLRF   x59
01BCC:  MOVF   x59,W
01BCE:  SUBLW  04
01BD0:  BNC   1BF4
....................       {
....................          fprintf(PC, ".");
01BD2:  MOVLW  2E
01BD4:  BTFSS  FA4.4
01BD6:  BRA    1BD4
01BD8:  MOVLB  F
01BDA:  MOVWF  x1D
....................          delay_ms(1000);
01BDC:  MOVLW  04
01BDE:  MOVLB  1
01BE0:  MOVWF  x5B
01BE2:  MOVLW  FA
01BE4:  MOVWF  xA6
01BE6:  MOVLB  0
01BE8:  RCALL  14A8
01BEA:  MOVLB  1
01BEC:  DECFSZ x5B,F
01BEE:  BRA    1BE2
01BF0:  INCF   x59,F
01BF2:  BRA    1BCC
....................       }
....................       fprintf(PC, "\r\n");
01BF4:  MOVLW  0D
01BF6:  BTFSS  FA4.4
01BF8:  BRA    1BF6
01BFA:  MOVLB  F
01BFC:  MOVWF  x1D
01BFE:  MOVLW  0A
01C00:  BTFSS  FA4.4
01C02:  BRA    1C00
01C04:  MOVWF  x1D
....................       fprintf(PC, "End use SMF\r\n");
01C06:  MOVLW  58
01C08:  MOVWF  FF6
01C0A:  MOVLW  08
01C0C:  MOVWF  FF7
01C0E:  MOVLW  00
01C10:  MOVWF  FF8
01C12:  CLRF   1B
01C14:  BTFSC  FF2.7
01C16:  BSF    1B.7
01C18:  BCF    FF2.7
01C1A:  MOVLB  0
01C1C:  CALL   0146
01C20:  BTFSC  1B.7
01C22:  BSF    FF2.7
....................       
....................       finished_use_smf();
01C24:  BRA    1AF2
....................       
....................       fprintf(PC, "wait for 10 seconods (exec mission sim)\r\n");
01C26:  MOVLW  66
01C28:  MOVWF  FF6
01C2A:  MOVLW  08
01C2C:  MOVWF  FF7
01C2E:  MOVLW  00
01C30:  MOVWF  FF8
01C32:  CLRF   1B
01C34:  BTFSC  FF2.7
01C36:  BSF    1B.7
01C38:  BCF    FF2.7
01C3A:  CALL   0146
01C3E:  BTFSC  1B.7
01C40:  BSF    FF2.7
....................       for (int8 i = 0; i < 30; i++)
01C42:  MOVLB  1
01C44:  CLRF   x5A
01C46:  MOVF   x5A,W
01C48:  SUBLW  1D
01C4A:  BNC   1C72
....................       {
....................          check_and_respond_to_boss();
01C4C:  MOVLB  0
01C4E:  BRA    1AFA
....................          fprintf(PC, ".");
01C50:  MOVLW  2E
01C52:  BTFSS  FA4.4
01C54:  BRA    1C52
01C56:  MOVLB  F
01C58:  MOVWF  x1D
....................          delay_ms(1000);
01C5A:  MOVLW  04
01C5C:  MOVLB  1
01C5E:  MOVWF  x5B
01C60:  MOVLW  FA
01C62:  MOVWF  xA6
01C64:  MOVLB  0
01C66:  RCALL  14A8
01C68:  MOVLB  1
01C6A:  DECFSZ x5B,F
01C6C:  BRA    1C60
01C6E:  INCF   x5A,F
01C70:  BRA    1C46
....................       }
....................    }
01C72:  BRA    1C94
01C74:  MOVLB  0
....................    else
....................       fprintf(PC, "Failure to Access to SMF");
01C76:  MOVLW  90
01C78:  MOVWF  FF6
01C7A:  MOVLW  08
01C7C:  MOVWF  FF7
01C7E:  MOVLW  00
01C80:  MOVWF  FF8
01C82:  CLRF   1B
01C84:  BTFSC  FF2.7
01C86:  BSF    1B.7
01C88:  BCF    FF2.7
01C8A:  CALL   0146
01C8E:  BTFSC  1B.7
01C90:  BSF    FF2.7
01C92:  MOVLB  1
....................       
....................    fprintf(PC, "End example_02\r\n");
01C94:  MOVLW  AA
01C96:  MOVWF  FF6
01C98:  MOVLW  08
01C9A:  MOVWF  FF7
01C9C:  MOVLW  00
01C9E:  MOVWF  FF8
01CA0:  CLRF   1B
01CA2:  BTFSC  FF2.7
01CA4:  BSF    1B.7
01CA6:  BCF    FF2.7
01CA8:  MOVLB  0
01CAA:  CALL   0146
01CAE:  BTFSC  1B.7
01CB0:  BSF    FF2.7
01CB2:  GOTO   1DD8 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... // SerialCommunication
.................... #include "./lib/communication_driver.h"
.................... #ifndef COMMUNICATION_DRIVER_H
.................... #define COMMUNICATION_DRIVER_H
.................... 
.................... #include "communication.h"
.................... 
.................... 
.................... // This is redundant, but it is a process to hide the Communication library as a driver.
.................... Command make_command(unsigned int8 receive_signal[], int8 receive_signal_size);
.................... 
.................... void transmit_ack();
.................... 
.................... void transmit_status();
.................... 
.................... int1 req_use_smf();
.................... 
.................... 
.................... #include "./src/communication_driver.c"
.................... 
.................... #endif
.................... 
.................... 
.................... // Copy to SMF
.................... #include "./lib/data_copy.h"
.................... #ifndef DATA_COPY_H
.................... #define DATA_COPY_H
.................... 
.................... #include "smf_queue.h"
.................... #ifndef SMF_QUEUE_H
.................... #define SMF_QUEUE_H
.................... 
.................... // ______________ defines (typedef) ____________
.................... 
.................... typedef struct {
....................     unsigned int32 src;
....................     unsigned int32 dest;
....................     unsigned int32 size;
.................... } SmfDataStruct;
.................... 
.................... #define SMF_DATA_SIZE 16
.................... typedef struct {
....................    SmfDataStruct smf_data[SMF_DATA_SIZE];
....................    int8 smf_data_head;
....................    int8 smf_data_tail;
.................... } SmfQueueStruct;
.................... 
.................... // _____________________ values _________________
.................... 
.................... volatile SmfQueueStruct smf_queue = {0};
.................... 
.................... 
.................... // ___________________ functions ________________
.................... 
.................... void enqueue_smf_data(SmfDataStruct *data);
.................... 
.................... SmfDataStruct *dequeue_smf_data();
.................... 
.................... int1 is_empty_smf_data(void);
.................... 
.................... 
.................... 
.................... #include "./src/smf_queue.c"
.................... 
.................... #endif
.................... 
.................... #include "flash.h"
.................... #ifndef FLASH_H
.................... #define FLASH_H
.................... ///////////////////////////////////////////////////////////////////////////////
.................... /////////////////////////GDNS_226_FlashOperation.h/////////////////////////////
.................... //////////////////////////////////ver 2.0//////////////////////////////////////
.................... /////////////////////////////last editor:T Kawai///////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... #define DEBUG
.................... //////////////////////////////port select//////////////////////////////////////
.................... #ifdef DEBUG
....................    #define DEBUG_PORT pc
.................... #endif
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define SPI STREAM////////////////////////////////
.................... #define FLASH_STREAM0 MIS_FM_STREAM     // <- Align the names to `config.h` Stream name
.................... #define FLASH_STREAM1 SMF_STREAM
.................... #define FLASH_STREAM2 SMF_STREAM // dont use
.................... #define FLASH_STREAM3 SMF_STREAM // dont use
.................... typedef enum spi_stream{
....................    SPI_0,
....................    SPI_1,
....................    SPI_2,
....................    SPI_3,
.................... }SpiStreamId;
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //////////////////////////////define Model name////////////////////////////////
.................... #define MT25QL128ABA 0x00     //Mission Flash
.................... #define MT25QL01GBBB 0x01     //SMF,CF
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////define structure member/////////////////////////////
.................... typedef struct select_stream_to_flash{
....................    SpiStreamId spi_stream_id;
....................    unsigned int8 flash_model;
....................    int16 cs_pin;
.................... }Flash;
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////    values    //////////////////////////////////////
.................... 
.................... Flash mis_fm = {SPI_0, MT25QL128ABA, SPI0_CS};
.................... Flash smf = {SPI_1, MT25QL01GBBB, SPI1_CS};
.................... 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////////////////CMD List///////////////////////////////////////
.................... #define CMD_READ_ID                     0x9F
.................... #define CMD_READ_STATUS_REGISTER        0x05
.................... #define CMD_READ                        0x03//for MT25QL128ABA
.................... #define CMD_4BYTE_READ                  0x13//for MT25QL01GBBB
.................... #define CMD_WRITE_ENABLE                0x06
.................... #define CMD_PAGE_PROGRAM                0x02//for MT25QL128ABA
.................... #define CMD_4BYTE_PAGE_PROGRAM          0x12//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_4KB_ERASE         0x20//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_4KB_ERASE   0x21//for MT25QL01GBBB
.................... #define CMD_SUBSECTOR_32KB_ERASE        0x52//for MT25QL128ABA
.................... #define CMD_4BYTE_SUBSECTOR_32KB_ERASE  0x5C//for MT25QL01GBBB
.................... #define CMD_SECTOR_ERASE                0xD8//for MT25QL128ABA
.................... #define CMD_4BYTE_SECTOR_ERASE          0xDC//for MT25QL01GBBB
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////function List///////////////////////////////////////
.................... //higher all spi csPINs
.................... void flash_setting(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //bit[7:2]status register control bit,bit[1]write enable bit T:ennable F:disable,bit[0]write in progress bit T:busy F:ready
.................... int8 status_register(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //T:Flash id read successfully(connect OK),F:Flash id read failed
.................... int8 read_id(Flash flash_stream);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //64kByte erase
.................... void sector_erase(Flash flash_stream, unsigned int32 sector_address);
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //32kByte erase
.................... void subsector_32kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                 
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //4kByte erase
.................... void subsector_4kByte_erase(Flash flash_stream, unsigned int32 subsector_address);                                  
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read 1 Byte data
.................... int8 read_data_byte(Flash flash_stream, unsigned int32 read_address);                                               
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //read multi Bytes data(max 128 MByte) and store to "read_data"
.................... void read_data_bytes(Flash flash_stream, unsigned int32 read_start_address, int8 *read_data, unsigned int32 read_amount);        
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write 1 Byte data to flash
.................... void write_data_byte(Flash flash_stream, unsigned int32 write_address,int8 write_data);                             
.................... ///////////////////////////////////////////////////////////////////////////////
.................... //write multi Bytes data(max256 Byte) in "write_data" to flash
.................... void write_data_bytes(Flash flash_stream, unsigned int32 write_start_address, int8 *write_data, unsigned int16 write_amount);              
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////////////////////end of GDNS_226_FlashOperation.h///////////////////////////
.................... #include "./src/flash.c"
.................... 
.................... #endif
.................... 
.................... 
.................... void copy_data(void);
.................... 
.................... 
.................... #include "./src/data_copy.c"
.................... void copy_data(void)
.................... {   
....................    while (!is_empty_smf_data())
*
01E68:  RCALL  1DFC
01E6A:  MOVF   01,F
01E6C:  BTFSS  FD8.2
01E6E:  BRA    20D4
....................    {
....................       SmfDataStruct *smf_data = dequeue_smf_data();
01E70:  BRA    1E10
01E72:  MOVFF  02,150
01E76:  MOVFF  01,14F
....................       fprintf(PC, "Destination address: \t0x%08LX\r\n", smf_data->dest);
01E7A:  MOVLW  04
01E7C:  MOVLB  1
01E7E:  ADDWF  x4F,W
01E80:  MOVWF  FE9
01E82:  MOVLW  00
01E84:  ADDWFC x50,W
01E86:  MOVWF  FEA
01E88:  MOVFF  FEF,151
01E8C:  MOVFF  FEC,152
01E90:  MOVFF  FEC,153
01E94:  MOVFF  FEC,154
01E98:  MOVLW  BC
01E9A:  MOVWF  FF6
01E9C:  MOVLW  08
01E9E:  MOVWF  FF7
01EA0:  MOVLW  00
01EA2:  MOVWF  FF8
01EA4:  MOVLW  18
01EA6:  MOVWF  xDE
01EA8:  MOVLB  0
01EAA:  CALL   0C58
01EAE:  MOVFF  154,1DE
01EB2:  MOVLW  37
01EB4:  MOVLB  1
01EB6:  MOVWF  xDF
01EB8:  MOVLB  0
01EBA:  CALL   0B7C
01EBE:  MOVFF  153,1DE
01EC2:  MOVLW  37
01EC4:  MOVLB  1
01EC6:  MOVWF  xDF
01EC8:  MOVLB  0
01ECA:  CALL   0B7C
01ECE:  MOVFF  152,1DE
01ED2:  MOVLW  37
01ED4:  MOVLB  1
01ED6:  MOVWF  xDF
01ED8:  MOVLB  0
01EDA:  CALL   0B7C
01EDE:  MOVFF  151,1DE
01EE2:  MOVLW  37
01EE4:  MOVLB  1
01EE6:  MOVWF  xDF
01EE8:  MOVLB  0
01EEA:  CALL   0B7C
01EEE:  MOVLW  0D
01EF0:  BTFSS  FA4.4
01EF2:  BRA    1EF0
01EF4:  MOVLB  F
01EF6:  MOVWF  x1D
01EF8:  MOVLW  0A
01EFA:  BTFSS  FA4.4
01EFC:  BRA    1EFA
01EFE:  MOVWF  x1D
....................       fprintf(PC, "Source address: \t0x%08LX\r\n", smf_data->src);
01F00:  MOVLB  1
01F02:  MOVFF  14F,FE9
01F06:  MOVFF  150,FEA
01F0A:  MOVFF  FEF,151
01F0E:  MOVFF  FEC,152
01F12:  MOVFF  FEC,153
01F16:  MOVFF  FEC,154
01F1A:  MOVLW  DC
01F1C:  MOVWF  FF6
01F1E:  MOVLW  08
01F20:  MOVWF  FF7
01F22:  MOVLW  00
01F24:  MOVWF  FF8
01F26:  MOVLW  13
01F28:  MOVWF  xDE
01F2A:  MOVLB  0
01F2C:  CALL   0C58
01F30:  MOVFF  154,1DE
01F34:  MOVLW  37
01F36:  MOVLB  1
01F38:  MOVWF  xDF
01F3A:  MOVLB  0
01F3C:  CALL   0B7C
01F40:  MOVFF  153,1DE
01F44:  MOVLW  37
01F46:  MOVLB  1
01F48:  MOVWF  xDF
01F4A:  MOVLB  0
01F4C:  CALL   0B7C
01F50:  MOVFF  152,1DE
01F54:  MOVLW  37
01F56:  MOVLB  1
01F58:  MOVWF  xDF
01F5A:  MOVLB  0
01F5C:  CALL   0B7C
01F60:  MOVFF  151,1DE
01F64:  MOVLW  37
01F66:  MOVLB  1
01F68:  MOVWF  xDF
01F6A:  MOVLB  0
01F6C:  CALL   0B7C
01F70:  MOVLW  0D
01F72:  BTFSS  FA4.4
01F74:  BRA    1F72
01F76:  MOVLB  F
01F78:  MOVWF  x1D
01F7A:  MOVLW  0A
01F7C:  BTFSS  FA4.4
01F7E:  BRA    1F7C
01F80:  MOVWF  x1D
....................       fprintf(PC, "Data size: \t\t  %08LX\r\n", smf_data->size);
01F82:  MOVLW  08
01F84:  MOVLB  1
01F86:  ADDWF  x4F,W
01F88:  MOVWF  FE9
01F8A:  MOVLW  00
01F8C:  ADDWFC x50,W
01F8E:  MOVWF  FEA
01F90:  MOVFF  FEF,151
01F94:  MOVFF  FEC,152
01F98:  MOVFF  FEC,153
01F9C:  MOVFF  FEC,154
01FA0:  MOVLW  F8
01FA2:  MOVWF  FF6
01FA4:  MOVLW  08
01FA6:  MOVWF  FF7
01FA8:  MOVLW  00
01FAA:  MOVWF  FF8
01FAC:  MOVLW  0F
01FAE:  MOVWF  xDE
01FB0:  MOVLB  0
01FB2:  CALL   0C58
01FB6:  MOVFF  154,1DE
01FBA:  MOVLW  37
01FBC:  MOVLB  1
01FBE:  MOVWF  xDF
01FC0:  MOVLB  0
01FC2:  CALL   0B7C
01FC6:  MOVFF  153,1DE
01FCA:  MOVLW  37
01FCC:  MOVLB  1
01FCE:  MOVWF  xDF
01FD0:  MOVLB  0
01FD2:  CALL   0B7C
01FD6:  MOVFF  152,1DE
01FDA:  MOVLW  37
01FDC:  MOVLB  1
01FDE:  MOVWF  xDF
01FE0:  MOVLB  0
01FE2:  CALL   0B7C
01FE6:  MOVFF  151,1DE
01FEA:  MOVLW  37
01FEC:  MOVLB  1
01FEE:  MOVWF  xDF
01FF0:  MOVLB  0
01FF2:  CALL   0B7C
01FF6:  MOVLW  0D
01FF8:  BTFSS  FA4.4
01FFA:  BRA    1FF8
01FFC:  MOVLB  F
01FFE:  MOVWF  x1D
02000:  MOVLW  0A
02002:  BTFSS  FA4.4
02004:  BRA    2002
02006:  MOVWF  x1D
....................       fprintf(PC, "Copying.");
02008:  MOVLW  10
0200A:  MOVWF  FF6
0200C:  MOVLW  09
0200E:  MOVWF  FF7
02010:  MOVLW  00
02012:  MOVWF  FF8
02014:  CLRF   1B
02016:  BTFSC  FF2.7
02018:  BSF    1B.7
0201A:  BCF    FF2.7
0201C:  MOVLB  0
0201E:  CALL   0146
02022:  BTFSC  1B.7
02024:  BSF    FF2.7
....................       delay_ms(1000);
02026:  MOVLW  04
02028:  MOVLB  1
0202A:  MOVWF  x51
0202C:  MOVLW  FA
0202E:  MOVWF  xA6
02030:  MOVLB  0
02032:  CALL   14A8
02036:  MOVLB  1
02038:  DECFSZ x51,F
0203A:  BRA    202C
....................       fprintf(PC, ".");
0203C:  MOVLW  2E
0203E:  BTFSS  FA4.4
02040:  BRA    203E
02042:  MOVLB  F
02044:  MOVWF  x1D
....................       delay_ms(1000);
02046:  MOVLW  04
02048:  MOVLB  1
0204A:  MOVWF  x51
0204C:  MOVLW  FA
0204E:  MOVWF  xA6
02050:  MOVLB  0
02052:  CALL   14A8
02056:  MOVLB  1
02058:  DECFSZ x51,F
0205A:  BRA    204C
....................       fprintf(PC, ".");
0205C:  MOVLW  2E
0205E:  BTFSS  FA4.4
02060:  BRA    205E
02062:  MOVLB  F
02064:  MOVWF  x1D
....................       delay_ms(1000);
02066:  MOVLW  04
02068:  MOVLB  1
0206A:  MOVWF  x51
0206C:  MOVLW  FA
0206E:  MOVWF  xA6
02070:  MOVLB  0
02072:  CALL   14A8
02076:  MOVLB  1
02078:  DECFSZ x51,F
0207A:  BRA    206C
....................       fprintf(PC, ".");   
0207C:  MOVLW  2E
0207E:  BTFSS  FA4.4
02080:  BRA    207E
02082:  MOVLB  F
02084:  MOVWF  x1D
....................       delay_ms(1000);
02086:  MOVLW  04
02088:  MOVLB  1
0208A:  MOVWF  x51
0208C:  MOVLW  FA
0208E:  MOVWF  xA6
02090:  MOVLB  0
02092:  CALL   14A8
02096:  MOVLB  1
02098:  DECFSZ x51,F
0209A:  BRA    208C
....................       fprintf(PC, ".\r\n");   
0209C:  MOVLW  1A
0209E:  MOVWF  FF6
020A0:  MOVLW  09
020A2:  MOVWF  FF7
020A4:  MOVLW  00
020A6:  MOVWF  FF8
020A8:  CLRF   1B
020AA:  BTFSC  FF2.7
020AC:  BSF    1B.7
020AE:  BCF    FF2.7
020B0:  MOVLB  0
020B2:  CALL   0146
020B6:  BTFSC  1B.7
020B8:  BSF    FF2.7
....................       delay_ms(1000);
020BA:  MOVLW  04
020BC:  MOVLB  1
020BE:  MOVWF  x51
020C0:  MOVLW  FA
020C2:  MOVWF  xA6
020C4:  MOVLB  0
020C6:  CALL   14A8
020CA:  MOVLB  1
020CC:  DECFSZ x51,F
020CE:  BRA    20C0
020D0:  MOVLB  0
020D2:  BRA    1E68
....................    }
....................    fprintf(PC, "_________End copy_data_________\r\n______________________________\r\n\r\n");
020D4:  MOVLW  1E
020D6:  MOVWF  FF6
020D8:  MOVLW  09
020DA:  MOVWF  FF7
020DC:  MOVLW  00
020DE:  MOVWF  FF8
020E0:  CLRF   1B
020E2:  BTFSC  FF2.7
020E4:  BSF    1B.7
020E6:  BCF    FF2.7
020E8:  CALL   0146
020EC:  BTFSC  1B.7
020EE:  BSF    FF2.7
020F0:  GOTO   22CE (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... void initialize(void)
.................... {
....................    fprintf(PC, "Start setting\r\n");
*
00B2A:  MOVLW  62
00B2C:  MOVWF  FF6
00B2E:  MOVLW  09
00B30:  MOVWF  FF7
00B32:  MOVLW  00
00B34:  MOVWF  FF8
00B36:  CLRF   1B
00B38:  BTFSC  FF2.7
00B3A:  BSF    1B.7
00B3C:  BCF    FF2.7
00B3E:  CALL   0146
00B42:  BTFSC  1B.7
00B44:  BSF    FF2.7
....................    setup_lcd(LCD_DISABLED);
00B46:  MOVLB  E
00B48:  CLRF   xD6
00B4A:  CLRF   xD7
00B4C:  CLRF   xDA
00B4E:  CLRF   xD8
00B50:  CLRF   xD9
....................    
....................    setup_timer();
00B52:  MOVLB  0
00B54:  BRA    0B1A
....................    setup_uart_to_boss();
00B56:  BRA    0B24
.................... 
....................    enable_interrupts(GLOBAL);
00B58:  MOVLW  C0
00B5A:  IORWF  FF2,F
....................    fprintf(PC, "End setting\r\n");
00B5C:  MOVLW  72
00B5E:  MOVWF  FF6
00B60:  MOVLW  09
00B62:  MOVWF  FF7
00B64:  MOVLW  00
00B66:  MOVWF  FF8
00B68:  CLRF   1B
00B6A:  BTFSC  FF2.7
00B6C:  BSF    1B.7
00B6E:  BCF    FF2.7
00B70:  CALL   0146
00B74:  BTFSC  1B.7
00B76:  BSF    FF2.7
00B78:  GOTO   24C0 (RETURN)
.................... }
.................... 
.................... 
.................... // ___________ command execution ___________
.................... 
.................... int1 execute_command(Command *command)
.................... {
....................    fprintf(PC, "\r\nStart execute_command\r\n");
*
020F4:  MOVLW  80
020F6:  MOVWF  FF6
020F8:  MOVLW  09
020FA:  MOVWF  FF7
020FC:  MOVLW  00
020FE:  MOVWF  FF8
02100:  CLRF   1B
02102:  BTFSC  FF2.7
02104:  BSF    1B.7
02106:  BCF    FF2.7
02108:  CALL   0146
0210C:  BTFSC  1B.7
0210E:  BSF    FF2.7
....................    
....................    switch(command->frame_id)
02110:  MOVLB  1
02112:  MOVF   x4D,W
02114:  MOVWF  FE9
02116:  MOVF   x4E,W
02118:  MOVWF  FEA
0211A:  MOVF   FEF,W
0211C:  XORLW  00
0211E:  MOVLB  0
02120:  BZ    212E
02122:  XORLW  01
02124:  BZ    21BA
02126:  XORLW  03
02128:  BTFSC  FD8.2
0212A:  BRA    225C
0212C:  BRA    22F4
....................    {
....................       case UPLINK_COMMAND:
....................          fprintf(PC, "\t-> Uplink command\r\n");
0212E:  MOVLW  9A
02130:  MOVWF  FF6
02132:  MOVLW  09
02134:  MOVWF  FF7
02136:  MOVLW  00
02138:  MOVWF  FF8
0213A:  CLRF   1B
0213C:  BTFSC  FF2.7
0213E:  BSF    1B.7
02140:  BCF    FF2.7
02142:  CALL   0146
02146:  BTFSC  1B.7
02148:  BSF    FF2.7
....................          fprintf(PC, "\t   Transmit Acknolegde\r\n");
0214A:  MOVLW  B0
0214C:  MOVWF  FF6
0214E:  MOVLW  09
02150:  MOVWF  FF7
02152:  MOVLW  00
02154:  MOVWF  FF8
02156:  CLRF   1B
02158:  BTFSC  FF2.7
0215A:  BSF    1B.7
0215C:  BCF    FF2.7
0215E:  CALL   0146
02162:  BTFSC  1B.7
02164:  BSF    FF2.7
....................          transmit_ack();
02166:  CALL   1396
.................... 
....................          status = EXECUTING_MISSION;
0216A:  MOVLW  02
0216C:  MOVWF  1F
....................          execute_mission(command->content);
0216E:  MOVLW  01
02170:  MOVLB  1
02172:  ADDWF  x4D,W
02174:  MOVWF  01
02176:  MOVLW  00
02178:  ADDWFC x4E,W
0217A:  MOVWF  03
0217C:  MOVFF  01,14F
02180:  MOVWF  x50
02182:  MOVWF  x52
02184:  MOVFF  01,151
02188:  MOVLB  0
0218A:  BRA    1CB6
....................          if (is_empty_smf_data())
0218C:  RCALL  1DFC
0218E:  MOVF   01,F
02190:  BZ    21B4
....................          {
....................             if (duration_sec < sec)
02192:  MOVF   27,F
02194:  BNZ   21A8
02196:  MOVF   26,F
02198:  BNZ   21A8
0219A:  MOVF   1D,W
0219C:  SUBWF  25,W
0219E:  BNC   21AE
021A0:  BNZ   21A8
021A2:  MOVF   24,W
021A4:  SUBWF  1C,W
021A6:  BC    21AE
....................                status = FINISHED;
021A8:  MOVLW  06
021AA:  MOVWF  1F
021AC:  BRA    21B2
....................             else
....................                status = IDLE;
021AE:  MOVLW  03
021B0:  MOVWF  1F
....................          }
021B2:  BRA    21B8
....................          else
....................             status = SMF_USE_REQ;
021B4:  MOVLW  04
021B6:  MOVWF  1F
....................          break;
021B8:  BRA    22F4
....................       
....................       case STATUS_CHECK:
....................          fprintf(PC, "\t-> Status check\r\n");
021BA:  MOVLW  CA
021BC:  MOVWF  FF6
021BE:  MOVLW  09
021C0:  MOVWF  FF7
021C2:  MOVLW  00
021C4:  MOVWF  FF8
021C6:  CLRF   1B
021C8:  BTFSC  FF2.7
021CA:  BSF    1B.7
021CC:  BCF    FF2.7
021CE:  CALL   0146
021D2:  BTFSC  1B.7
021D4:  BSF    FF2.7
....................          fprintf(PC, "\t\t-> My status is %d\r\n", status);
021D6:  MOVLW  DE
021D8:  MOVWF  FF6
021DA:  MOVLW  09
021DC:  MOVWF  FF7
021DE:  MOVLW  00
021E0:  MOVWF  FF8
021E2:  MOVLW  12
021E4:  MOVLB  1
021E6:  MOVWF  xDE
021E8:  MOVLB  0
021EA:  CALL   0C58
021EE:  MOVFF  1F,156
021F2:  MOVLW  18
021F4:  MOVLB  1
021F6:  MOVWF  x57
021F8:  MOVLB  0
021FA:  CALL   1166
021FE:  MOVLW  0D
02200:  BTFSS  FA4.4
02202:  BRA    2200
02204:  MOVLB  F
02206:  MOVWF  x1D
02208:  MOVLW  0A
0220A:  BTFSS  FA4.4
0220C:  BRA    220A
0220E:  MOVWF  x1D
....................          fprintf(PC, "\t   Transmit MIS MCU Status\r\n");
02210:  MOVLW  F6
02212:  MOVWF  FF6
02214:  MOVLW  09
02216:  MOVWF  FF7
02218:  MOVLW  00
0221A:  MOVWF  FF8
0221C:  CLRF   1B
0221E:  BTFSC  FF2.7
02220:  BSF    1B.7
02222:  BCF    FF2.7
02224:  MOVLB  0
02226:  CALL   0146
0222A:  BTFSC  1B.7
0222C:  BSF    FF2.7
....................          transmit_status();
0222E:  CALL   18D4
....................          if (status == FINISHED)
02232:  MOVF   1F,W
02234:  SUBLW  06
02236:  BNZ   225A
....................          {
....................             fprintf(PC, "finished in status_check\r\n");
02238:  MOVLW  14
0223A:  MOVWF  FF6
0223C:  MOVLW  0A
0223E:  MOVWF  FF7
02240:  MOVLW  00
02242:  MOVWF  FF8
02244:  CLRF   1B
02246:  BTFSC  FF2.7
02248:  BSF    1B.7
0224A:  BCF    FF2.7
0224C:  CALL   0146
02250:  BTFSC  1B.7
02252:  BSF    FF2.7
....................             return TRUE;
02254:  MOVLW  01
02256:  MOVWF  01
02258:  BRA    22F8
....................          }
....................          break;
0225A:  BRA    22F4
....................       
....................       case IS_SMF_AVAILABLE:
....................          fprintf(PC, "\t-> is SMF available\r\n");
0225C:  MOVLW  30
0225E:  MOVWF  FF6
02260:  MOVLW  0A
02262:  MOVWF  FF7
02264:  MOVLW  00
02266:  MOVWF  FF8
02268:  CLRF   1B
0226A:  BTFSC  FF2.7
0226C:  BSF    1B.7
0226E:  BCF    FF2.7
02270:  CALL   0146
02274:  BTFSC  1B.7
02276:  BSF    FF2.7
....................          fprintf(PC, "\t   Transmit Acknolegde\r\n");
02278:  MOVLW  48
0227A:  MOVWF  FF6
0227C:  MOVLW  0A
0227E:  MOVWF  FF7
02280:  MOVLW  00
02282:  MOVWF  FF8
02284:  CLRF   1B
02286:  BTFSC  FF2.7
02288:  BSF    1B.7
0228A:  BCF    FF2.7
0228C:  CALL   0146
02290:  BTFSC  1B.7
02292:  BSF    FF2.7
....................          transmit_ack();
02294:  CALL   1396
....................          if (command->content[0] == ALLOW)
02298:  MOVLW  01
0229A:  MOVLB  1
0229C:  ADDWF  x4D,W
0229E:  MOVWF  FE9
022A0:  MOVLW  00
022A2:  ADDWFC x4E,W
022A4:  MOVWF  FEA
022A6:  MOVF   FEF,F
022A8:  BNZ   22D6
....................          {
....................             fprintf(PC, "\t\t-> allowd\r\n");
022AA:  MOVLW  62
022AC:  MOVWF  FF6
022AE:  MOVLW  0A
022B0:  MOVWF  FF7
022B2:  MOVLW  00
022B4:  MOVWF  FF8
022B6:  CLRF   1B
022B8:  BTFSC  FF2.7
022BA:  BSF    1B.7
022BC:  BCF    FF2.7
022BE:  MOVLB  0
022C0:  CALL   0146
022C4:  BTFSC  1B.7
022C6:  BSF    FF2.7
....................             status = COPYING;
022C8:  MOVLW  05
022CA:  MOVWF  1F
....................             copy_data();
022CC:  BRA    1E68
....................             status = FINISHED;
022CE:  MOVLW  06
022D0:  MOVWF  1F
....................          }
022D2:  BRA    22F4
022D4:  MOVLB  1
....................          else
....................             fprintf(PC, "\t\t-> denyed\r\n");
022D6:  MOVLW  70
022D8:  MOVWF  FF6
022DA:  MOVLW  0A
022DC:  MOVWF  FF7
022DE:  MOVLW  00
022E0:  MOVWF  FF8
022E2:  CLRF   1B
022E4:  BTFSC  FF2.7
022E6:  BSF    1B.7
022E8:  BCF    FF2.7
022EA:  MOVLB  0
022EC:  CALL   0146
022F0:  BTFSC  1B.7
022F2:  BSF    FF2.7
....................    }
....................    return FALSE;
022F4:  MOVLW  00
022F6:  MOVWF  01
022F8:  GOTO   2606 (RETURN)
.................... }
.................... 
.................... 
.................... // ___________ main functoin _______________
.................... 
.................... void main()
022FC:  CLRF   FF8
022FE:  BCF    FD0.7
02300:  BSF    07.7
02302:  MOVLB  E
02304:  MOVLW  55
02306:  MOVWF  F7E
02308:  MOVLW  AA
0230A:  MOVWF  F7E
0230C:  BCF    F66.6
0230E:  MOVLW  F8
02310:  MOVWF  x2A
02312:  MOVLW  F5
02314:  MOVWF  x2B
02316:  MOVLW  F8
02318:  MOVWF  x2C
0231A:  MOVLW  F9
0231C:  MOVWF  x2D
0231E:  MOVLW  20
02320:  MOVWF  x1D
02322:  MOVLW  30
02324:  MOVWF  x22
02326:  MOVLW  20
02328:  MOVWF  x24
0232A:  MOVLW  01
0232C:  MOVWF  x25
0232E:  MOVLW  55
02330:  MOVWF  F7E
02332:  MOVLW  AA
02334:  MOVWF  F7E
02336:  BSF    F66.6
02338:  CLRF   F9B
0233A:  CLRF   F64
0233C:  CLRF   F65
0233E:  CLRF   F66
02340:  MOVLW  02
02342:  MOVWF  FD3
02344:  BSF    F67.3
02346:  MOVLW  A0
02348:  MOVWF  FAF
0234A:  MOVLW  01
0234C:  MOVLB  F
0234E:  MOVWF  x30
02350:  MOVLW  A6
02352:  MOVWF  FAC
02354:  MOVLW  90
02356:  MOVWF  FAB
02358:  BSF    x31.3
0235A:  MOVLW  A0
0235C:  MOVWF  x1F
0235E:  MOVLW  01
02360:  MOVWF  x20
02362:  MOVLW  A6
02364:  MOVWF  x32
02366:  MOVLW  90
02368:  MOVWF  x33
0236A:  BSF    x2D.3
0236C:  MOVLW  A0
0236E:  MOVWF  x2B
02370:  MOVLW  01
02372:  MOVWF  x2C
02374:  MOVLW  A6
02376:  MOVWF  x2E
02378:  MOVLW  90
0237A:  MOVWF  x2F
0237C:  MOVLB  E
0237E:  BSF    xFD.3
02380:  MOVLW  A0
02382:  MOVWF  xFB
02384:  MOVLW  01
02386:  MOVWF  xFC
02388:  MOVLW  A6
0238A:  MOVWF  xFE
0238C:  MOVLW  90
0238E:  MOVWF  xFF
02390:  BSF    F92.0
02392:  BCF    F92.1
02394:  BCF    F92.3
02396:  BCF    F89.3
02398:  BSF    F93.5
0239A:  BCF    F93.4
0239C:  BCF    F93.2
0239E:  BCF    F8A.2
023A0:  CLRF   1D
023A2:  CLRF   1C
023A4:  BCF    1E.0
023A6:  MOVLW  03
023A8:  MOVWF  1F
023AA:  CLRF   23
023AC:  CLRF   22
023AE:  CLRF   21
023B0:  CLRF   20
023B2:  CLRF   27
023B4:  CLRF   26
023B6:  CLRF   25
023B8:  CLRF   24
023BA:  CLRF   29
023BC:  CLRF   28
023BE:  CLRF   4A
023C0:  CLRF   4C
023C2:  CLRF   4B
023C4:  CLRF   xD9
023C6:  CLRF   xDA
023C8:  CLRF   xCE
023CA:  CLRF   xCF
023CC:  CLRF   xD0
023CE:  CLRF   xD1
023D0:  CLRF   xD2
023D2:  CLRF   xD3
023D4:  CLRF   xD4
023D6:  CLRF   xD5
023D8:  CLRF   x45
023DA:  CLRF   x46
023DC:  CLRF   x47
023DE:  BCF    x8D.7
023E0:  BCF    x8D.6
023E2:  BCF    x8D.5
023E4:  MOVLB  F
023E6:  CLRF   x53
023E8:  CLRF   x38
023EA:  CLRF   x37
023EC:  BRA    2408
023EE:  DATA 20,40
023F0:  DATA 2A,00
023F2:  DATA C4,40
023F4:  DATA 4D,00
023F6:  DATA 0C,80
023F8:  DATA 02,7C
023FA:  DATA 01,01
023FC:  DATA 0B,7C
023FE:  DATA 00,09
02400:  DATA 01,00
02402:  DATA 02,01
02404:  DATA 09,C0
02406:  DATA 00,00
02408:  MOVLW  00
0240A:  MOVWF  FF8
0240C:  MOVLW  23
0240E:  MOVWF  FF7
02410:  MOVLW  EE
02412:  MOVWF  FF6
02414:  TBLRD*+
02416:  MOVF   FF5,W
02418:  MOVWF  00
0241A:  XORLW  00
0241C:  BZ    2444
0241E:  TBLRD*+
02420:  MOVF   FF5,W
02422:  MOVWF  01
02424:  BTFSC  FE8.7
02426:  BRA    2432
02428:  ANDLW  3F
0242A:  MOVWF  FEA
0242C:  TBLRD*+
0242E:  MOVFF  FF5,FE9
02432:  BTFSC  01.6
02434:  TBLRD*+
02436:  BTFSS  01.6
02438:  TBLRD*+
0243A:  MOVFF  FF5,FEE
0243E:  DCFSNZ 00,F
02440:  BRA    2414
02442:  BRA    2436
02444:  CLRF   FF8
.................... {
....................    fprintf(PC, "\r\n\r\n");
02446:  MOVLW  7E
02448:  MOVWF  FF6
0244A:  MOVLW  0A
0244C:  MOVWF  FF7
0244E:  MOVLW  00
02450:  MOVWF  FF8
02452:  CLRF   1B
02454:  BTFSC  FF2.7
02456:  BSF    1B.7
02458:  BCF    FF2.7
0245A:  MOVLB  0
0245C:  CALL   0146
02460:  BTFSC  1B.7
02462:  BSF    FF2.7
....................    for (int8 i = 0; i < 3; i++)
02464:  MOVLB  1
02466:  CLRF   x26
02468:  MOVF   x26,W
0246A:  SUBLW  02
0246C:  BNC   249E
....................    {
....................       for (int8 j = 0; j < 31; j++)
0246E:  CLRF   x27
02470:  MOVF   x27,W
02472:  SUBLW  1E
02474:  BNC   2486
....................          fprintf(PC, "_");
02476:  MOVLW  5F
02478:  BTFSS  FA4.4
0247A:  BRA    2478
0247C:  MOVLB  F
0247E:  MOVWF  x1D
02480:  MOVLB  1
02482:  INCF   x27,F
02484:  BRA    2470
....................       fprintf(PC, "\r\n");
02486:  MOVLW  0D
02488:  BTFSS  FA4.4
0248A:  BRA    2488
0248C:  MOVLB  F
0248E:  MOVWF  x1D
02490:  MOVLW  0A
02492:  BTFSS  FA4.4
02494:  BRA    2492
02496:  MOVWF  x1D
02498:  MOVLB  1
0249A:  INCF   x26,F
0249C:  BRA    2468
....................    }
....................    fprintf(PC, "___________Start main__________\r\n\r\n");
0249E:  MOVLW  84
024A0:  MOVWF  FF6
024A2:  MOVLW  0A
024A4:  MOVWF  FF7
024A6:  MOVLW  00
024A8:  MOVWF  FF8
024AA:  CLRF   1B
024AC:  BTFSC  FF2.7
024AE:  BSF    1B.7
024B0:  BCF    FF2.7
024B2:  MOVLB  0
024B4:  CALL   0146
024B8:  BTFSC  1B.7
024BA:  BSF    FF2.7
....................    
....................    
....................    initialize();
024BC:  GOTO   0B2A
....................    
....................    int1 is_finished = FALSE;
024C0:  MOVLB  1
024C2:  BCF    x28.0
.................... 
....................    //Start loop
....................    while(!is_finished)
024C4:  BTFSC  x28.0
024C6:  BRA    265C
....................    {
....................       // handle from boss commands
....................       if(boss_receive_buffer_size > 0)
024C8:  MOVF   4A,F
024CA:  BTFSC  FD8.2
024CC:  BRA    260E
....................       {
....................          Command command = make_command(boss_receive_buffer, boss_receive_buffer_size);
024CE:  CLRF   x54
024D0:  MOVLW  2A
024D2:  MOVWF  x53
024D4:  MOVFF  4A,155
024D8:  MOVLB  0
024DA:  GOTO   1100
024DE:  MOVFF  02,03
024E2:  MOVFF  01,FE1
024E6:  MOVFF  02,FE2
024EA:  MOVLW  01
024EC:  MOVWF  FEA
024EE:  MOVLW  29
024F0:  MOVWF  FE9
024F2:  MOVLW  23
024F4:  MOVWF  01
024F6:  MOVFF  FE6,FEE
024FA:  DECFSZ 01,F
024FC:  BRA    24F6
....................          
....................          fprintf(PC, "FrameID: %X\r\n", command.frame_id);
024FE:  MOVLW  A8
02500:  MOVWF  FF6
02502:  MOVLW  0A
02504:  MOVWF  FF7
02506:  MOVLW  00
02508:  MOVWF  FF8
0250A:  MOVLW  09
0250C:  MOVLB  1
0250E:  MOVWF  xDE
02510:  MOVLB  0
02512:  CALL   0C58
02516:  MOVFF  129,1DE
0251A:  MOVLW  37
0251C:  MOVLB  1
0251E:  MOVWF  xDF
02520:  MOVLB  0
02522:  CALL   0B7C
02526:  MOVLW  0D
02528:  BTFSS  FA4.4
0252A:  BRA    2528
0252C:  MOVLB  F
0252E:  MOVWF  x1D
02530:  MOVLW  0A
02532:  BTFSS  FA4.4
02534:  BRA    2532
02536:  MOVWF  x1D
....................          fprintf(PC, "exist : %d\r\n", command.is_exist);
02538:  MOVLW  00
0253A:  MOVLB  1
0253C:  BTFSC  x4B.0
0253E:  MOVLW  01
02540:  MOVWF  x4D
02542:  MOVLW  B6
02544:  MOVWF  FF6
02546:  MOVLW  0A
02548:  MOVWF  FF7
0254A:  MOVLW  00
0254C:  MOVWF  FF8
0254E:  MOVLW  08
02550:  MOVWF  xDE
02552:  MOVLB  0
02554:  CALL   0C58
02558:  MOVFF  14D,156
0255C:  MOVLW  18
0255E:  MOVLB  1
02560:  MOVWF  x57
02562:  MOVLB  0
02564:  CALL   1166
02568:  MOVLW  0D
0256A:  BTFSS  FA4.4
0256C:  BRA    256A
0256E:  MOVLB  F
02570:  MOVWF  x1D
02572:  MOVLW  0A
02574:  BTFSS  FA4.4
02576:  BRA    2574
02578:  MOVWF  x1D
....................          
....................          fprintf(PC, "content: ");
0257A:  MOVLW  C4
0257C:  MOVWF  FF6
0257E:  MOVLW  0A
02580:  MOVWF  FF7
02582:  MOVLW  00
02584:  MOVWF  FF8
02586:  CLRF   1B
02588:  BTFSC  FF2.7
0258A:  BSF    1B.7
0258C:  BCF    FF2.7
0258E:  MOVLB  0
02590:  CALL   0146
02594:  BTFSC  1B.7
02596:  BSF    FF2.7
....................          for(int8 i = 0; i < command.size; i++)
02598:  MOVLB  1
0259A:  CLRF   x4C
0259C:  MOVF   x4A,W
0259E:  SUBWF  x4C,W
025A0:  BC    25CE
....................             fprintf(PC, "%X ", command.content[i]);
025A2:  CLRF   03
025A4:  MOVF   x4C,W
025A6:  ADDLW  2A
025A8:  MOVWF  FE9
025AA:  MOVLW  01
025AC:  ADDWFC 03,W
025AE:  MOVWF  FEA
025B0:  MOVFF  FEF,1DE
025B4:  MOVLW  37
025B6:  MOVWF  xDF
025B8:  MOVLB  0
025BA:  CALL   0B7C
025BE:  MOVLW  20
025C0:  BTFSS  FA4.4
025C2:  BRA    25C0
025C4:  MOVLB  F
025C6:  MOVWF  x1D
025C8:  MOVLB  1
025CA:  INCF   x4C,F
025CC:  BRA    259C
....................          fprintf(PC, "\r\n");
025CE:  MOVLW  0D
025D0:  BTFSS  FA4.4
025D2:  BRA    25D0
025D4:  MOVLB  F
025D6:  MOVWF  x1D
025D8:  MOVLW  0A
025DA:  BTFSS  FA4.4
025DC:  BRA    25DA
025DE:  MOVWF  x1D
....................          
....................          clear_receive_signal(boss_receive_buffer, &boss_receive_buffer_size);
025E0:  MOVLB  1
025E2:  CLRF   xA6
025E4:  MOVLW  2A
025E6:  MOVWF  xA5
025E8:  CLRF   xA8
025EA:  MOVLW  4A
025EC:  MOVWF  xA7
025EE:  MOVLB  0
025F0:  CALL   124E
....................             
....................          if(command.is_exist)
025F4:  MOVLB  1
025F6:  BTFSS  x4B.0
025F8:  BRA    260E
....................             is_finished = execute_command(&command); 
025FA:  MOVLW  01
025FC:  MOVWF  x4E
025FE:  MOVLW  29
02600:  MOVWF  x4D
02602:  MOVLB  0
02604:  BRA    20F4
02606:  MOVLB  1
02608:  BCF    x28.0
0260A:  BTFSC  01.0
0260C:  BSF    x28.0
....................       }
....................       
....................       // check mis mcu duration seconds (used in mission.c \ void continue_mis_mcu(int16 duration_sec))
....................       if (status == IDLE)
0260E:  MOVF   1F,W
02610:  SUBLW  03
02612:  BNZ   2640
....................          if (duration_sec < sec && is_empty_smf_data())
02614:  MOVF   27,F
02616:  BNZ   262A
02618:  MOVF   26,F
0261A:  BNZ   262A
0261C:  MOVF   1D,W
0261E:  SUBWF  25,W
02620:  BNC   2640
02622:  BNZ   262A
02624:  MOVF   24,W
02626:  SUBWF  1C,W
02628:  BC    2640
0262A:  MOVLB  0
0262C:  CALL   1DFC
02630:  MOVF   01,F
02632:  BTFSS  FD8.2
02634:  BRA    263A
02636:  MOVLB  1
02638:  BRA    2640
....................             status = FINISHED;
0263A:  MOVLW  06
0263C:  MOVWF  1F
0263E:  MOVLB  1
....................       
....................       // check `is break while loop`
....................       if(is_finished == TRUE)
02640:  BTFSS  x28.0
02642:  BRA    2646
....................          break;
02644:  BRA    265C
....................          
....................       delay_ms(400);
02646:  MOVLW  02
02648:  MOVWF  x4D
0264A:  MOVLW  C8
0264C:  MOVWF  xA6
0264E:  MOVLB  0
02650:  CALL   14A8
02654:  MOVLB  1
02656:  DECFSZ x4D,F
02658:  BRA    264A
0265A:  BRA    24C4
....................    }
....................    
....................    
....................    fprintf(PC, "\r\n\r\n======\r\n\r\nFinished process.\r\nWait for BOSS PIC turn off me");
0265C:  MOVLW  CE
0265E:  MOVWF  FF6
02660:  MOVLW  0A
02662:  MOVWF  FF7
02664:  MOVLW  00
02666:  MOVWF  FF8
02668:  CLRF   1B
0266A:  BTFSC  FF2.7
0266C:  BSF    1B.7
0266E:  BCF    FF2.7
02670:  MOVLB  0
02672:  CALL   0146
02676:  BTFSC  1B.7
02678:  BSF    FF2.7
....................    
....................    while (TRUE)
....................    {
....................       fprintf(PC, ".");
0267A:  MOVLW  2E
0267C:  BTFSS  FA4.4
0267E:  BRA    267C
02680:  MOVLB  F
02682:  MOVWF  x1D
....................       delay_ms(1000);
02684:  MOVLW  04
02686:  MOVLB  1
02688:  MOVWF  x4D
0268A:  MOVLW  FA
0268C:  MOVWF  xA6
0268E:  MOVLB  0
02690:  CALL   14A8
02694:  MOVLB  1
02696:  DECFSZ x4D,F
02698:  BRA    268A
0269A:  MOVLB  0
0269C:  BRA    267A
....................    }
....................    
....................    fprintf(PC, "End main\r\n");
0269E:  MOVLW  0E
026A0:  MOVWF  FF6
026A2:  MOVLW  0B
026A4:  MOVWF  FF7
026A6:  MOVLW  00
026A8:  MOVWF  FF8
026AA:  CLRF   1B
026AC:  BTFSC  FF2.7
026AE:  BSF    1B.7
026B0:  BCF    FF2.7
026B2:  CALL   0146
026B6:  BTFSC  1B.7
026B8:  BSF    FF2.7
.................... }
026BA:  SLEEP 

Configuration Fuses:
   Word  1: F7A0   STVREN NOXINST NODEBUG BROWNOUT_SW BORV18 NOPROTECT
   Word  2: FF82   PR SOSC_DIG NOCLOCKOUT IESO NOPLL
   Word  3: F032   HS
   Word  4: F7FF   WPFP WPDIS WPEND NOWPCFG
   Word  5: FF03   T5G_IS_T5G CINA_DEFAULT IOL1WAY LS48MHZ MSSP2MSK7 MSSPMSK7
   Word  6: FCFF   WDTWIN_25% WDTCLK_FRC WDT32768 NOWDT WINDIS WPRES128
   Word  7: F01D   NOVREGSLEEP VBATBOR DSBOR DS_SW
   Word  8: F3F8   DSWDT_25DAYS NODSWDT DSWDTOSC_INT
